<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Presentation Studio</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600;700&family=Work+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<!-- Firebase SDK -->
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js'
  import { getAnalytics } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js'
  import { getFirestore } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
  import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js'

  const firebaseConfig = {
    apiKey: 'AIzaSyDPzRqV-_hGNedZoeGNtorLTGWTBMmqdkc',
    authDomain: 'prj-adc-gcp-coop-test.firebaseapp.com',
    projectId: 'prj-adc-gcp-coop-test',
    storageBucket: 'prj-adc-gcp-coop-test.firebasestorage.app',
    messagingSenderId: '472242813268',
    appId: '1:472242813268:web:4e7b4650015fd473d4f0c1',
    measurementId: 'G-RGEPGD1T9T',
  }

  const firebaseApp = initializeApp(firebaseConfig)
  const analytics = getAnalytics(firebaseApp)
  const db = getFirestore(firebaseApp, 'bettercallus')
  const auth = getAuth(firebaseApp)

  window.firebaseApp = firebaseApp
  window.firebaseAnalytics = analytics
  window.firebaseDb = db
  window.firebaseAuth = auth

  const markLoggedOut = () => {
    localStorage.removeItem('pm-logged-in')
    localStorage.removeItem('pm-user-id')
  }

      // Get stored user ID if available
      const storedUserId = localStorage.getItem('pm-user-id')
      if (storedUserId) {
        window.currentUserId = storedUserId
  }

  onAuthStateChanged(auth, (user) => {
    if (user) {
      window.currentUser = user
          window.currentUserId = user.uid
      localStorage.setItem('pm-logged-in', 'true')
      localStorage.setItem('pm-user-id', user.uid)
      if (user.email) {
        localStorage.setItem('pm-user-email', user.email)
      }
      if (user.displayName) {
        localStorage.setItem('pm-user-name', user.displayName)
      }
      window.dispatchEvent(new CustomEvent('pm-user-ready', { detail: { user } }))
    } else {
      window.currentUser = null
          window.currentUserId = storedUserId || null
      markLoggedOut()
      if (localStorage.getItem('pm-logged-in') !== 'true') {
        window.location.replace('login.html')
      }
    }
  })

  console.log('Firebase initialized in editor with database: bettercallus')
</script>
<style>
        @font-face {
            font-family: 'Kraft Mono';
            src: url('assets/fonts/KraftMono.woff2') format('woff2'),
                 url('assets/fonts/KraftMono.woff') format('woff'),
                 url('assets/fonts/KraftMono.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'ID Grotesk';
            src: url('assets/fonts/IDGrotesk-Regular.woff2') format('woff2'),
                 url('assets/fonts/IDGrotesk-Regular.woff') format('woff'),
                 url('assets/fonts/IDGrotesk-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'ID Grotesk';
            src: url('assets/fonts/IDGrotesk-Medium.woff2') format('woff2'),
                 url('assets/fonts/IDGrotesk-Medium.woff') format('woff'),
                 url('assets/fonts/IDGrotesk-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'ID Grotesk';
            src: url('assets/fonts/IDGrotesk-SemiBold.woff2') format('woff2'),
                 url('assets/fonts/IDGrotesk-SemiBold.woff') format('woff'),
                 url('assets/fonts/IDGrotesk-SemiBold.ttf') format('truetype');
            font-weight: 600;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'ID Grotesk';
            src: url('assets/fonts/IDGrotesk-Bold.woff2') format('woff2'),
                 url('assets/fonts/IDGrotesk-Bold.woff') format('woff'),
                 url('assets/fonts/IDGrotesk-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom right, #f8fafc, #ffffff, #ecfdf5);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(16, 185, 129, 0.16), transparent 55%),
              radial-gradient(circle at top right, rgba(56, 189, 248, 0.15), transparent 45%),
              radial-gradient(circle at bottom, rgba(6, 95, 70, 0.15), transparent 60%);
            z-index: -2;
            pointer-events: none;
        }

        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.6);
            color: #0f172a;
            padding: 14px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.05);
            position: relative;
            z-index: 200;
        }

        .header-left, .header-right { display: flex; align-items: center; gap: 10px; }

        .templates-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            color: #64748b;
            padding: 6px 12px;
            border-radius: 9999px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
        }

        .templates-btn:hover {
            background: rgba(16, 185, 129, 0.12);
            border-color: rgba(16, 185, 129, 0.4);
            color: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-brand img {
            height: 32px;
            width: auto;
        }

        .header-brand-text {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.32em;
            color: #64748b;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            color: #1e293b;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        }

        .header-btn:hover { 
            background: rgba(16, 185, 129, 0.12); 
            border-color: rgba(16, 185, 129, 0.4);
            color: #047857;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        }
        .header-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
            color: #94a3b8;
        }

        .header-btn.grey-style {
            color: #94a3b8 !important;
            opacity: 0.5 !important;
        }

        .header-btn.grey-style:hover {
            color: #94a3b8 !important;
            opacity: 0.5 !important;
            background: rgba(255, 255, 255, 0.95) !important;
            border-color: rgba(203, 213, 225, 0.9) !important;
            transform: none !important;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08) !important;
        }

        .title-input {
            background: rgba(255, 255, 255, 0.95);
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            color: #1e293b;
            font-size: 14px;
            font-weight: 500;
            padding: 9px 16px;
            border-radius: 8px;
            outline: none;
            min-width: 320px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        }

        .title-input::placeholder { color: rgba(100, 116, 139, 0.7); }
        .title-input:focus { 
            background: rgba(255, 255, 255, 0.95); 
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .share-btn {
            background: linear-gradient(to right, #10b981, #059669) !important;
            color: white !important;
            padding: 9px 24px;
            border: none !important;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .share-btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            background: linear-gradient(to right, #059669, #047857) !important;
            color: white !important;
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            display: none;
            min-width: 220px;
            z-index: 1000;
            overflow: hidden;
        }

        .dropdown-menu.show { display: block; }

        .dropdown-item {
            padding: 14px 18px;
            cursor: pointer;
            color: #374151;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s;
        }

        .dropdown-item:hover { background: rgba(16, 185, 129, 0.1); color: #059669; }

        /* Category Panel Dropdowns */
        .dropdown-wrapper {
            position: relative;
            display: inline-block;
        }

        .category-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(15, 23, 42, 0.15);
            display: none;
            min-width: 180px;
            z-index: 1000;
            overflow: hidden;
            border: 1px solid rgba(226, 232, 240, 0.8);
        }

        .category-dropdown.show {
            display: block;
        }

        .category-dropdown-item {
            padding: 10px 14px;
            cursor: pointer;
            color: #374151;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.15s;
            border-bottom: 1px solid rgba(226, 232, 240, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .category-dropdown-item:last-child {
            border-bottom: none;
        }

        .category-dropdown-item:hover {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
        }

        .dropdown-btn {
            position: relative;
            padding-right: 24px;
        }

        .dropdown-btn::after {
            display: none;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(226, 232, 240, 0.8);
            padding: 0;
            box-shadow: 0 2px 8px rgba(15, 23, 42, 0.08);
            position: relative;
            z-index: 200;
        }

        .toolbar-nav {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 10px 24px;
        }

        .category-tab {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: #475569;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-tab:hover {
            background: rgba(16, 185, 129, 0.12);
            color: #047857;
            border-color: rgba(16, 185, 129, 0.3);
        }

        .category-tab.active {
            background: rgba(16, 185, 129, 0.15);
            color: #047857;
            border: 1px solid rgba(16, 185, 129, 0.5);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.15);
        }

        .category-tab .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #cbd5e1;
            transition: background 0.2s;
        }

        .category-tab.active .dot,
        .category-tab:hover .dot {
            background: #10b981;
        }

        .category-panel {
            display: none;
            border-top: 1px solid rgba(226, 232, 240, 0.8);
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            padding: 10px 16px;
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            box-shadow: 0 2px 8px rgba(15, 23, 42, 0.06);
        }

        .category-panel.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .animate-slideInUp {
            animation: slideInUp 0.5s ease-out;
        }
        
        .animate-fadeIn {
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .category-panel-content {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            min-height: 36px;
        }

        .category-panel-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
            visibility: visible;
            opacity: 1;
        }

        .category-panel-group + .category-panel-group::before {
            content: '';
            width: 1px;
            height: 24px;
            background: rgba(226, 232, 240, 0.6);
            margin-right: 6px;
        }

        .category-panel-label {
            font-size: 9.5px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #64748b;
            margin-right: 4px;
            white-space: nowrap;
        }

        .shape-pill {
            padding: 6px 12px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            background: rgba(255, 255, 255, 1);
            border-radius: 8px;
            cursor: pointer;
            font-size: 9.5px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #334155;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 4px rgba(15, 23, 42, 0.08), 0 1px 2px rgba(15, 23, 42, 0.04);
            visibility: visible;
            opacity: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .shape-pill:hover {
            background: rgba(16, 185, 129, 0.12);
            border-color: rgba(16, 185, 129, 0.5);
            color: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25), 0 2px 6px rgba(16, 185, 129, 0.15);
        }

        .tool-btn-danger {
            color: #ef4444 !important;
            border-color: rgba(239, 68, 68, 0.3) !important;
        }

        .tool-btn-danger:hover {
            background: rgba(239, 68, 68, 0.1) !important;
            border-color: rgba(239, 68, 68, 0.5) !important;
            color: #dc2626 !important;
        }

        .tool-btn {
            padding: 6px 10px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            background: rgba(255, 255, 255, 1);
            border-radius: 8px;
            cursor: pointer;
            font-size: 9.5px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #334155;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 4px rgba(15, 23, 42, 0.08), 0 1px 2px rgba(15, 23, 42, 0.04);
            position: relative;
            overflow: hidden;
            visibility: visible;
            opacity: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .tool-btn:hover::before {
            left: 100%;
        }

        .tool-btn:hover { 
            background: rgba(16, 185, 129, 0.12); 
            border-color: rgba(16, 185, 129, 0.5); 
            color: #047857; 
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25), 0 2px 6px rgba(16, 185, 129, 0.15);
        }

        .tool-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.15);
        }

        .tool-btn-primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-color: rgba(16, 185, 129, 0.3);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3), 0 2px 4px rgba(16, 185, 129, 0.2);
            font-size: 9.5px;
        }

        .tool-btn-primary:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4), 0 2px 4px rgba(16, 185, 129, 0.3);
        }

        .tool-btn-icon {
            padding: 6px;
            width: 28px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 9.5px;
        }

        .tool-divider { width: 1px; height: 32px; background: #e5e7eb; margin: 0 6px; }

        select.tool-btn { 
            padding: 6px 10px; 
            padding-right: 28px;
            text-transform: none;
            letter-spacing: 0;
            font-size: 9.5px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 12 12'%3E%3Cpath fill='%23475569' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
        }
        input[type="number"].tool-btn { 
            width: 70px; 
            padding: 6px 10px; 
            text-transform: none;
            letter-spacing: 0;
            font-size: 9.5px;
        }
        input[type="color"] { 
            width: 44px; 
            height: 40px; 
            border: 1px solid rgba(226, 232, 240, 0.8); 
            border-radius: 10px; 
            cursor: pointer; 
            box-shadow: 0 2px 4px rgba(15, 23, 42, 0.08);
            transition: all 0.2s;
        }
        input[type="color"]:hover {
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.2);
            transform: translateY(-1px);
        }

        .container { 
            display: flex; 
            height: calc(100vh - 112px);
            margin-top: 112px;
        }

        .properties-panel {
            width: 0;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-left: none;
            display: flex;
            flex-direction: column;
            padding: 0;
            gap: 16px;
            overflow: hidden;
            box-shadow: none;
            transition: width 0.3s ease, padding 0.3s ease, padding-top 0.3s ease, border-left 0.3s ease, box-shadow 0.3s ease;
        }

        .properties-panel.visible {
            width: 280px;
            padding: 20px;
            padding-top: 60px;
            border-left: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: -2px 0 8px rgba(15, 23, 42, 0.05);
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
            transition: padding-top 0.2s ease;
        }

        .properties-panel.visible.category-panel-open {
            padding-top: 100px;
        }

        .properties-panel-header {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            color: #64748b;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .properties-panel-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .properties-action-btn {
            width: 28px;
            height: 28px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            background: rgba(255, 255, 255, 1);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        }

        .properties-action-btn:hover {
            background: rgba(16, 185, 129, 0.12);
            border-color: rgba(16, 185, 129, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        }

        .properties-action-btn.delete {
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .properties-action-btn.delete:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.5);
            color: #dc2626;
        }

        .properties-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
            overflow-x: hidden;
        }

        .properties-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
            overflow-x: hidden;
        }

        .properties-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.25em;
            color: #94a3b8;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .properties-input {
            width: 100%;
            padding: 10px 14px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            background: rgba(255, 255, 255, 1);
            border-radius: 10px;
            font-size: 13px;
            color: #1e293b;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        }

        .properties-input:focus {
            outline: none;
            border-color: rgba(16, 185, 129, 0.5);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .properties-color-input {
            width: 100%;
            height: 48px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        }

        .properties-color-input:hover {
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        }

        .properties-arrange-btn {
            width: 100%;
            height: 36px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            background: rgba(255, 255, 255, 1);
            border-radius: 8px;
            font-size: 14px;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        }

        .properties-arrange-btn:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.5);
            color: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        }

        .properties-arrange-btn:active {
            transform: translateY(0);
            background: rgba(16, 185, 129, 0.2);
        }

        .properties-empty {
            text-align: center;
            padding: 40px 20px;
            color: #94a3b8;
        }

        .properties-empty-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.25em;
            color: #64748b;
            margin-bottom: 8px;
        }

        .properties-empty-text {
            font-size: 12px;
            color: #94a3b8;
            line-height: 1.6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .sidebar {
            width: 200px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.6);
            display: flex;
            flex-direction: column;
            padding: 16px 12px;
            padding-top: 60px;
            gap: 12px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(15, 23, 42, 0.05);
            scroll-behavior: smooth;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .sidebar-header {
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            padding: 8px 12px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 8px;
            margin-top: 20px;
        }

        .sidebar-slide {
            width: 100%;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .sidebar-slide:hover {
            border-color: rgba(16, 185, 129, 0.4);
            transform: translateX(-4px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.15);
        }

        .sidebar-slide.active {
            border-color: rgba(16, 185, 129, 0.7);
            border-width: 3px;
            background: rgba(16, 185, 129, 0.06);
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.25);
        }

        .sidebar-slide-preview {
            width: 100%;
            aspect-ratio: 16/9;
            background: white;
            position: relative;
            font-size: 8px;
        }

        .sidebar-slide-number {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .sidebar-slide-delete {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .sidebar-slide:hover .sidebar-slide-delete {
            display: flex;
        }

        .sidebar-add-slide {
            width: 100%;
            padding: 12px;
            background: #f9fafb;
            border: 2px dashed #cbd5e1;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.2s;
        }

        .sidebar-add-slide:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.4);
            color: #059669;
        }

        .main-canvas {
            flex: 1;
            padding: 32px;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            scroll-behavior: smooth;
        }

        .main-canvas::-webkit-scrollbar {
            width: 10px;
        }

        .main-canvas::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .main-canvas::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 5px;
        }

        .main-canvas::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .canvas-wrapper {
            transform-origin: center center;
            transition: transform 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 32px;
            padding: 20px;
        }

        .canvas-slide {
            width: 960px;
            height: 540px;
            background: white;
            position: relative;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            border-radius: 4px;
            overflow: hidden;
            transition: all 0.3s ease;
            z-index: 1;
            contain: layout style paint;
        }

        .canvas-slide:hover {
            box-shadow: 0 12px 40px rgba(0,0,0,0.18);
            transform: translateY(-2px);
        }

        .canvas-slide.active {
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.5), 0 12px 40px rgba(16, 185, 129, 0.3);
        }

        .slide-number-badge {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            z-index: 5;
            backdrop-filter: blur(10px);
        }

        .element {
            position: absolute;
            cursor: move;
            user-select: none;
            overflow: hidden;
            box-sizing: border-box;
        }

        .element.selected {
            outline: 2px solid rgba(16, 185, 129, 0.45);
            outline-offset: 2px;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.45), 0 20px 40px -25px rgba(16, 185, 129, 0.35);
        }

        .element.text-element {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
            max-width: 100%;
            max-height: 100%;
        }

        .element.shape-element {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .element.image-element img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .resize-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border: 2px solid rgba(16, 185, 129, 0.8);
            border-radius: 50%;
            display: none;
            box-shadow: 0 4px 14px rgba(15, 23, 42, 0.3);
        }

        .element.selected .resize-handle { display: block; }

        .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

        /* Zoom Control Bar - Bottom Right */
        .zoom-control {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(15, 23, 42, 0.15);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.6);
        }

        .zoom-divider {
            width: 1px;
            height: 32px;
            background: #e5e7eb;
        }

        .present-mode-btn {
            padding: 8px 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .present-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .present-mode-btn:active {
            transform: translateY(0);
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            background: rgba(255, 255, 255, 0.9);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #475569;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
        }

        .zoom-btn:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.4);
            color: #059669;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-slider {
            width: 120px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: #e5e7eb;
            outline: none;
            border-radius: 2px;
            cursor: pointer;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .zoom-slider::-webkit-slider-thumb:hover {
            background: #059669;
            transform: scale(1.2);
        }

        .zoom-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .zoom-slider::-moz-range-thumb:hover {
            background: #059669;
            transform: scale(1.2);
        }

        .zoom-value {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            min-width: 45px;
            text-align: center;
        }

        .zoom-reset {
            font-size: 11px;
            padding: 4px 8px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            cursor: pointer;
            color: #64748b;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
        }

        .zoom-reset:hover {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
            border-color: rgba(16, 185, 129, 0.4);
        }

        .modal {
            display: none;
            position: fixed;
            top: 112px;
            left: 0;
            width: 100%;
            height: calc(100% - 112px);
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            z-index: 5000;
            align-items: center;
            justify-content: center;
        }

        .modal.show { display: flex; }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(15, 23, 42, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #1f2937;
        }

        .modal-close {
            float: right;
            font-size: 28px;
            font-weight: 300;
            color: #9ca3af;
            cursor: pointer;
            line-height: 1;
            transition: all 0.2s;
        }

        .modal-close:hover { color: #ef4444; transform: rotate(90deg); }

        .bg-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 20px;
        }

        .bg-option {
            aspect-ratio: 16/9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
        }

        .bg-option:hover {
            transform: scale(1.05);
            border-color: rgba(16, 185, 129, 0.5);
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.3);
        }

        .bg-color-item {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .bg-color-item:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
        }

        /* Range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            border: 2px solid #10b981;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            border: 2px solid #10b981;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
        }

        .animation-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .animation-option {
            padding: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.2s;
            color: #374151;
        }

        .animation-option:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.4);
            color: #059669;
            transform: translateY(-2px);
        }

        .present-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 3000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .present-mode.active { display: flex; }

        .present-slide {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .present-canvas {
            background: white;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        }

        .present-controls {
            background: rgba(0,0,0,0.8);
            padding: 16px 24px;
            display: flex;
            gap: 16px;
            align-items: center;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .present-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .present-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .present-counter {
            color: white;
            font-weight: 600;
            font-size: 14px;
            padding: 0 16px;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideInLeft { from { transform: translateX(-50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideInRight { from { transform: translateX(50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideInUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideInDown { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes zoomIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }

        .animate-fadeIn { animation: fadeIn 0.6s ease-out; }
        .animate-slideInLeft { animation: slideInLeft 0.6s ease-out; }
        .animate-slideInRight { animation: slideInRight 0.6s ease-out; }
        .animate-slideInUp { animation: slideInUp 0.6s ease-out; }
        .animate-slideInDown { animation: slideInDown 0.6s ease-out; }
        .animate-zoomIn { animation: zoomIn 0.6s ease-out; }
        .animate-bounce { animation: bounce 0.8s ease-in-out; }

        .slide-transition-fade { animation: fadeIn 0.5s; }
        .slide-transition-slide { animation: slideInRight 0.5s; }
        .slide-transition-zoom { animation: zoomIn 0.5s; }

        /* Professional Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 24px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(15, 23, 42, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
            border-left: 4px solid #10b981;
        }

        .notification.error {
            border-left-color: #ef4444;
        }

        .notification.warning {
            border-left-color: #f59e0b;
        }

        .notification-icon {
            font-size: 20px;
        }

        .notification-text {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        /* Loading Spinner */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(4px);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Professional Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 12px;
            background: #1f2937;
            color: white;
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            animation: tooltipFadeIn 0.2s ease-out forwards;
        }

        [data-tooltip]:hover::after {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1f2937;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            animation: tooltipFadeIn 0.2s ease-out forwards;
        }

        @keyframes tooltipFadeIn {
            to { opacity: 1; }
        }

        /* Context Menu for Arrange */
        .context-menu {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            padding: 8px;
            z-index: 10000;
            display: none;
            min-width: 200px;
            border: 1px solid rgba(203, 213, 225, 0.5);
        }

        .context-menu.show {
            display: block;
        }

        .context-menu-label {
            padding: 6px 14px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #94a3b8;
        }

        .context-menu-item {
            padding: 10px 14px;
            cursor: pointer;
            border-radius: 8px;
            font-size: 13px;
            color: #475569;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
        }

        .context-menu-separator {
            height: 1px;
            background: rgba(203, 213, 225, 0.5);
            margin: 4px 0;
        }

        .context-menu-arrange-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            padding: 4px;
        }

        .context-menu-arrange-btn {
            width: 100%;
            height: 32px;
            border: 1.5px solid rgba(203, 213, 225, 0.9);
            background: rgba(255, 255, 255, 1);
            border-radius: 6px;
            font-size: 14px;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
        }

        .context-menu-arrange-btn:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.5);
            color: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }

        /* Professional Grid Overlay */
        .canvas-grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .canvas-grid-overlay.show {
            opacity: 0.1;
            background-image: 
                linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Snap Guidelines */
        .snap-line {
            position: absolute;
            background: rgba(16, 185, 129, 0.8);
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }

        .snap-line.horizontal {
            height: 1px;
            width: 100%;
            left: 0;
        }

        .snap-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }
    

/* ===================== FIXES OVERRIDES (Do not remove) ===================== */
/* Keep the top bars fixed and ensure tooltips render above them */
.header {
  position: fixed !important;
  top: 0;
  left: 0;
  right: 0;
  z-index: 4000 !important;
}

.toolbar {
  position: fixed !important;
  top: 60px; /* adjust if header height changes */
  left: 0;
  right: 0;
  z-index: 3500 !important;
}

.container {
  margin-top: 120px; /* header (60px) + toolbar (60px) */
  height: calc(100vh - 130px);
}

[data-tooltip]:hover::before,
[data-tooltip]:hover::after {
  z-index: 5000 !important; /* render above fixed bars */
}

/* Menus & overlays should stack correctly above the fixed bars */
.dropdown-menu {
  z-index: 5000 !important;
}

.present-mode {
  z-index: 6000 !important; /* presentation overlay above everything */
}
/* =================== END FIXES OVERRIDES =================== */



/* ===================== TOOLTIP CLIP FIXES ===================== */
/* Allow tooltips inside slides to escape the slide box */
.canvas-slide { overflow: visible !important; }
/* Ensure any element that shows tooltip is not clipping its pseudo-elements */
.element, [data-tooltip] { overflow: visible !important; }
/* Lift slide itself above toolbar if needed when hovering */
.canvas-slide:hover { z-index: 4500; }
/* Keep tooltips the highest */
[data-tooltip]:hover::before, [data-tooltip]:hover::after { z-index: 5000 !important; }
/* =================== END TOOLTIP CLIP FIXES =================== */


/* ============ JS Tooltip Portal Overrides ============ */
[data-tooltip]::before, [data-tooltip]::after { display: none !important; }
.js-tooltip {
  position: fixed;
  padding: 6px 10px;
  background: #1f2937;
  color: #fff;
  font-size: 12px;
  font-weight: 600;
  border-radius: 6px;
  white-space: nowrap;
  z-index: 10000; /* above header/toolbar */
  pointer-events: none;
  box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  transform: translate(-50%, -6px);
}
.js-tooltip-arrow {
  position: fixed;
  width: 0;
  height: 0;
  border: 6px solid transparent;
  border-top-color: #1f2937;
  z-index: 10000;
  pointer-events: none;
  transform: translate(-50%, 0);
}
/* ============ End Overrides ============ */


/* ===================== COMPACT UI PASS ===================== */
:root{
  --btn-h: 34px;
  --btn-fs: 12px;
  --btn-px: 10px;
  --gap: 8px;
  --radius: 10px;
  --toolbar-top: 56px; /* header height */
}

/* Header refinement */
.header{
  padding: 10px 16px !important;
  min-height: var(--toolbar-top);
}
.title-input{ min-width: 260px !important; font-size: 13px !important; padding: 8px 12px !important; }

/* Toolbar refinement */
.toolbar{
  top: var(--toolbar-top) !important;
  padding: 10px 16px !important;
  gap: var(--gap) !important;
}

/* Button base */
.header-btn, .tool-btn, .zoom-btn, .zoom-reset {
  height: var(--btn-h) !important;
  padding: 0 var(--btn-px) !important;
  font-size: var(--btn-fs) !important;
  border-radius: var(--radius) !important;
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  border: 1px solid #e5e7eb !important;
  background: #fff;
  box-shadow: none !important;
}

/* Share button should keep emerald gradient */
.share-btn {
  background: linear-gradient(to right, #10b981, #059669) !important;
  color: white !important;
  border: none !important;
  box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3) !important;
}
.share-btn:hover {
  background: linear-gradient(to right, #059669, #047857) !important;
  color: white !important;
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4) !important;
}

/* Icons boldness */
.tool-btn strong, .tool-btn em, .tool-btn u { font-size: 12px !important; }

/* Selects & number inputs same height */
select.tool-btn, input[type="number"].tool-btn {
  height: var(--btn-h) !important;
  padding: 0 8px !important;
  min-width: 64px;
}

/* Color inputs smaller */
input[type="color"]{
  width: 30px !important;
  height: 30px !important;
  padding: 0 !important;
  border-radius: 6px !important;
}

/* Divider slimmer */
.tool-divider{ height: 26px !important; margin: 0 4px !important; background: #eef2f7 !important; }

/* Dropdown menu tighter */
.dropdown-menu{ min-width: 180px !important; }
.dropdown-item{ padding: 10px 12px !important; font-size: 12px !important; }

/* Sidebar spacing */
.sidebar{ padding: 12px 10px !important; gap: 10px !important; }
.sidebar-add-slide{ padding: 10px !important; font-size: 12px !important; }
.sidebar-slide-number{ font-size: 9px !important; padding: 2px 6px !important; }
.sidebar-slide{ border-width: 2px !important; }

/* Slide badge smaller */
.slide-number-badge{ font-size: 11px !important; padding: 4px 10px !important; }

/* Zoom control smaller */
.zoom-control{
  padding: 10px 12px !important;
  gap: 10px !important;
  border-radius: 10px !important;
}
.zoom-slider{ width: 100px !important; }
.zoom-value{ font-size: 12px !important; min-width: 40px !important; }

/* Container offset update to match tighter bars */
/* Removed - using unified container margin-top below */
/* =================== END COMPACT UI PASS =================== */



/* ===================== KEEP HEADER AS-IS & BEAUTIFY TOOLBAR ===================== */
:root{
  --header-h: 60px;        /* header fixed height */
  --toolbar-h: 52px;       /* toolbar visual height after compacting */
}

/* 1) Restore original header styling (no compact changes) */
.header {
  padding: 14px 24px !important;     /* original spacing */
  min-height: unset !important;
}
.header .header-btn{
  background: rgba(255, 255, 255, 0.95) !important;
  border: 1.5px solid rgba(203, 213, 225, 0.9) !important;
  color: #1e293b !important;
  padding: 8px 16px !important;
  border-radius: 8px !important;
  font-size: 13px !important;
  font-weight: 600 !important;
  box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08) !important;
  height: auto !important;
}
.header .header-btn:hover{ 
  background: rgba(16, 185, 129, 0.12) !important; 
  border-color: rgba(16, 185, 129, 0.4) !important;
  color: #047857 !important;
  box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2) !important;
}
.header .share-btn{
  background: linear-gradient(to right, #10b981, #059669) !important;
  color: white !important;
  padding: 9px 24px !important;
  border: none !important;
  border-radius: 8px !important;
  font-weight: 600 !important;
  font-size: 13px !important;
  box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3) !important;
  height: auto !important;
}
.header .share-btn:hover {
  background: linear-gradient(to right, #059669, #047857) !important;
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4) !important;
}
.title-input{
  background: rgba(255, 255, 255, 0.95) !important;
  border: 1.5px solid rgba(203, 213, 225, 0.9) !important;
  color: #1e293b !important;
  font-size: 14px !important;
  font-weight: 500 !important;
  padding: 9px 16px !important;
  border-radius: 8px !important;
  min-width: 320px !important;
  box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08) !important;
}
.title-input::placeholder {
  color: rgba(100, 116, 139, 0.7) !important;
}

/* 2) Toolbar tidy look (smaller buttons, subtle hover) */
.toolbar{
  top: var(--header-h) !important;
  padding: 10px 20px !important;
  gap: 8px !important;
  background: #fff !important;
  border-bottom: 1px solid #e5e7eb !important;
  box-shadow: 0 2px 8px rgba(0,0,0,0.03) !important;
}

.tool-btn{
  height: 34px !important;
  padding: 0 10px !important;
  font-size: 12.5px !important;
  background: #f9fafb !important;
  border: 1px solid #e5e7eb !important;
  border-radius: 6px !important;
  box-shadow: none !important;
  color: #374151 !important;
}
.tool-btn:hover{
  background: rgba(16, 185, 129, 0.1) !important;
  border-color: rgba(16, 185, 129, 0.3) !important;
  color: #059669 !important;
}
.tool-btn:active, .tool-btn:focus{
  background: rgba(16, 185, 129, 0.15) !important;
  color: #047857 !important;
  outline: none !important;
}

/* Inputs same height as buttons */
select.tool-btn, input[type="number"].tool-btn{
  height: 34px !important;
  min-width: 64px;
}
input[type="color"]{
  width: 30px !important; height: 30px !important; border-radius: 6px !important;
}

/* Divider thinner */
.tool-divider{ height: 26px !important; margin: 0 4px !important; background: #eef2f7 !important; }

/* 3) Proper top offset so content doesn't hide under bars */
.container{
  margin-top: 112px !important;
  height: calc(100vh - 112px) !important;
}

/* Keep tooltips over everything */
[data-tooltip]::before, [data-tooltip]::after{ z-index: 5000 !important; }

/* =================== AI Assistant Sidebar =================== */
.ai-message {
    margin-bottom: 12px;
    display: flex;
    flex-direction: column;
}

.ai-message.user {
    align-items: flex-end;
}

.ai-message.ai-assistant {
    align-items: flex-start;
}

.ai-message-content {
    max-width: 85%;
    padding: 12px 16px;
    border-radius: 12px;
    background: white;
    border: 1px solid #e5e7eb;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    word-wrap: break-word;
}

.ai-message.user .ai-message-content {
    background: linear-gradient(135deg, #10b981 0%, #14b8a6 50%, #38bdf8 100%);
    color: white;
    border: none;
}

.ai-message.ai-assistant .ai-message-content {
    background: #f8fafc;
    border: 1px solid #e5e7eb;
}

.ai-message-content ul {
    margin: 8px 0;
    padding-left: 20px;
    color: #64748b;
}

.ai-message-content li {
    margin: 4px 0;
}

.ai-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid #bae6fd;
    border-top-color: #0369a1;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.ai-sidebar {
    position: fixed;
    right: 0;
    top: 120px;
    width: 400px;
    height: calc(100vh - 120px);
    background: white;
    border-left: 1px solid #e5e7eb;
    box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
    z-index: 1500;
    display: flex;
    flex-direction: column;
    transform: translateX(100%);
    transition: transform 0.3s ease-out;
    overflow: hidden;
}

.ai-sidebar.visible {
    transform: translateX(0);
}

.ai-sidebar-header {
    padding: 20px 20px 16px 20px;
    border-bottom: 1px solid #e5e7eb;
    background: linear-gradient(135deg, #10b981 0%, #14b8a6 50%, #38bdf8 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 0;
}

.ai-sidebar-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
}

.ai-sidebar-close {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.ai-sidebar-close:hover {
    background: rgba(255, 255, 255, 0.3);
}

.ai-sidebar-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.ai-sidebar-messages {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    background: #f8fafc;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.ai-sidebar-input-area {
    padding: 16px;
    border-top: 1px solid #e5e7eb;
    background: white;
}

/* Adjust container when AI sidebar is open */
.container.ai-sidebar-open {
    margin-right: 400px;
}

/* =================== END =================== */

</style>
</head>
<body>
<div id="contextMenu" class="context-menu">
    <div class="context-menu-item" onclick="app.groupElements(); app.hideContextMenu();">Group</div>
    <div class="context-menu-item" onclick="app.ungroupElements(); app.hideContextMenu();">Ungroup</div>
    <div class="context-menu-item" onclick="app.duplicateElement(); app.hideContextMenu();">Duplicate</div>
    <div class="context-menu-item" onclick="app.deleteElement(); app.hideContextMenu();">Delete</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="app.moveLayer('forward'); app.hideContextMenu();">Bring Forward</div>
    <div class="context-menu-item" onclick="app.moveLayer('backward'); app.hideContextMenu();">Send Backward</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="app.copyStyle(); app.hideContextMenu();">Copy Style</div>
    <div class="context-menu-item" onclick="app.pasteStyle(); app.hideContextMenu();">Paste Style</div>
</div>
<div class="header">
<div class="header-left">
<a href="templates.html" class="templates-btn"> Templates</a>
<div class="header-brand">
<img src="assets/aramco-digital-logo.png" alt="Aramco Digital" />
<span class="header-brand-text">Presentation Lab</span>
</div>
<input class="title-input" id="title" placeholder="Untitled Presentation" type="text"/>
</div>
<div class="header-right">
<button class="header-btn grey-style" onclick="app.newPresentation()">New</button>
<button class="header-btn grey-style" onclick="app.saveJSON()">Save</button>
<button class="header-btn grey-style" onclick="app.loadJSON()">Load</button>
<button class="header-btn" data-tooltip="Undo (Ctrl+Z)" disabled="" id="undoBtn" onclick="app.undo()">Undo</button>
<button class="header-btn" data-tooltip="Redo (Ctrl+Y)" disabled="" id="redoBtn" onclick="app.redo()">Redo</button>
<div style="position: relative;">
<button class="share-btn" onclick="app.toggleExport()">Export </button>
<div class="dropdown-menu" id="exportMenu">
<div class="dropdown-item" onclick="app.exportPDF()">Export as PDF</div>
<div class="dropdown-item" onclick="app.exportImages()">Export as Images</div>
<div class="dropdown-item" onclick="app.shareLink()">Share Link</div>
</div>
</div>
</div>
</div>
<div class="toolbar">
<div class="toolbar-nav">
<nav style="flex: 1; display: flex; align-items: center; gap: 4px;">
<button class="category-tab" data-category="design" onclick="app.showCategory('design')">
<span class="dot"></span> Design
            </button>
<button class="category-tab" data-category="text" onclick="app.showCategory('text')">
<span class="dot"></span> Text
</button>
<button class="category-tab" data-category="image" onclick="app.showCategory('image')">
<span class="dot"></span> Image
</button>
<button class="category-tab" data-category="shape-data" onclick="app.showCategory('shape-data')">
<span class="dot"></span> Shape & Data
</button>
<button class="category-tab" data-category="effects" onclick="app.showCategory('effects')">
<span class="dot"></span> Effects
</button>
<button class="category-tab ai-button-glow" onclick="app.toggleAIPanel()" style="background: linear-gradient(135deg, #10b981 0%, #14b8a6 50%, #38bdf8 100%); color: white; border: none; margin-left: 4px; position: relative; overflow: hidden;">
<span style="position: relative; z-index: 1;">AI</span>
</button>
</nav>
<div style="display: flex; align-items: center; gap: 8px;">
<button class="share-btn" data-tooltip="Start Presentation (F5)" onclick="app.presentMode()" style="padding: 8px 20px; font-size: 13px;">
<span></span> Present
</button>
<button class="share-btn" onclick="app.toggleExport()" style="padding: 8px 20px; font-size: 13px;">Share</button>
                </div>
                </div>
<div class="category-panel" id="categoryPanel">
<div class="category-panel-content" id="categoryPanelContent">
<!-- Content will be dynamically inserted here -->
                </div>
                </div>
</div>
<div class="container">
<div class="sidebar" id="sidebar">
<div class="sidebar-header">Slides</div>
<div id="slides"></div>
<button class="sidebar-add-slide" onclick="app.addSlide()">+ Add Slide</button>
</div>
<div class="main-canvas" id="mainCanvas">
<div class="canvas-wrapper" id="canvasWrapper">
<!-- Slides will be rendered here -->
</div>
</div>
<div class="properties-panel" id="propertiesPanel">
<div class="properties-panel-header">
<span>Properties</span>
<div class="properties-panel-actions" id="propertiesActions" style="display: none;">
<button class="properties-action-btn" onclick="app.duplicateElement()" title="Duplicate"></button>
<button class="properties-action-btn delete" onclick="app.deleteElement()" title="Delete"></button>
</div>
</div>
<div id="propertiesContent" class="properties-section">
<div class="properties-empty">
<div class="properties-empty-title">No Selection</div>
<div class="properties-empty-text">Select an element on the canvas to edit its properties</div>
</div>
</div>
</div>
</div>
<!-- Zoom Control Bar with Present Button -->
<div class="zoom-control">
<button class="share-btn" data-tooltip="Start Presentation (F5)" onclick="app.presentMode()">
<span></span> Present
        </button>
<div class="zoom-divider"></div>
<button class="zoom-btn" data-tooltip="Zoom Out" onclick="app.zoomOut()" title="Zoom Out"></button>
<input class="zoom-slider" id="zoomSlider" max="200" min="25" oninput="app.setZoom(this.value)" step="5" type="range" value="100"/>
<div class="zoom-value" id="zoomValue">100%</div>
<button class="zoom-btn" data-tooltip="Zoom In" onclick="app.zoomIn()" title="Zoom In">+</button>
<button class="zoom-reset" data-tooltip="Reset Zoom" onclick="app.resetZoom()">Reset</button>
</div>
<!-- Background Modal -->
<div class="modal" id="bgModal">
<div class="modal-content">
<span class="modal-close" onclick="app.closeModal('bgModal')"></span>
<div class="modal-header">Choose Slide Background</div>
<div class="bg-grid">
<div class="bg-option" onclick="app.applyBg('white')" style="background: white;"></div>
<div class="bg-option" onclick="app.applyBg('#f0fdf4')" style="background: #f0fdf4;"></div>
<div class="bg-option" onclick="app.applyBg('#ecfdf5')" style="background: #ecfdf5;"></div>
<div class="bg-option" onclick="app.applyBg('#dcfce7')" style="background: #dcfce7;"></div>
<div class="bg-option" onclick="app.applyBg('#d1fae5')" style="background: #d1fae5;"></div>
<div class="bg-option" onclick="app.applyBg('#a7f3d0')" style="background: #a7f3d0;"></div>
<div class="bg-option" onclick="app.applyBg('#e0f2fe')" style="background: #e0f2fe;"></div>
<div class="bg-option" onclick="app.applyBg('#bae6fd')" style="background: #bae6fd;"></div>
<div class="bg-option" onclick="app.applyBg('#7dd3fc')" style="background: #7dd3fc;"></div>
<div class="bg-option" onclick="app.applyBg('#ccfbf1')" style="background: #ccfbf1;"></div>
<div class="bg-option" onclick="app.applyBg('#99f6e4')" style="background: #99f6e4;"></div>
<div class="bg-option" onclick="app.applyBg('#5eead4')" style="background: #5eead4;"></div>
<div class="bg-option" onclick="app.applyBg('#dbeafe')" style="background: #dbeafe;"></div>
<div class="bg-option" onclick="app.applyBg('#bfdbfe')" style="background: #bfdbfe;"></div>
<div class="bg-option" onclick="app.applyBg('#93c5fd')" style="background: #93c5fd;"></div>
<div class="bg-option" onclick="app.applyBg('#e0e7ff')" style="background: #e0e7ff;"></div>
<div class="bg-option" onclick="app.applyBg('#c7d2fe')" style="background: #c7d2fe;"></div>
<div class="bg-option" onclick="app.applyBg('#a5b4fc')" style="background: #a5b4fc;"></div>
<div class="bg-option" onclick="app.applyBg('linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%)')" style="background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);"></div>
<div class="bg-option" onclick="app.applyBg('linear-gradient(135deg, #bae6fd 0%, #7dd3fc 100%)')" style="background: linear-gradient(135deg, #bae6fd 0%, #7dd3fc 100%);"></div>
<div class="bg-option" onclick="app.applyBg('linear-gradient(135deg, #99f6e4 0%, #5eead4 100%)')" style="background: linear-gradient(135deg, #99f6e4 0%, #5eead4 100%);"></div>
</div>
<button class="tool-btn" onclick="app.uploadBgImage()" style="margin-top: 24px; width: 100%;">Upload Image</button>
</div>
</div>
<!-- Templates Modal -->
<div class="modal" id="templatesModal">
<div class="modal-content" style="max-width: 900px;">
<span class="modal-close" onclick="app.closeModal('templatesModal')"></span>
<div class="modal-header">Choose Layout</div>
<div class="bg-grid" id="templatesGrid">
<!-- Templates will be loaded here -->
</div>
</div>
</div>
<!-- Crop Modal -->
<div class="modal" id="cropModal">
<div class="modal-content" style="max-width: 800px;">
<span class="modal-close" onclick="app.closeModal('cropModal')"></span>
<div class="modal-header">Crop Image</div>
<div style="padding: 20px; text-align: center;">
<div style="background: #f3f4f6; border-radius: 12px; padding: 40px; margin-bottom: 20px; min-height: 400px; display: flex; align-items: center; justify-content: center;">
<img id="cropImagePreview" src="" alt="Image to crop" style="max-width: 100%; max-height: 400px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
</div>
<div style="display: flex; gap: 12px; justify-content: center;">
<button class="tool-btn" onclick="app.closeModal('cropModal')" style="padding: 12px 24px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db;">Cancel</button>
<button class="tool-btn tool-btn-primary" onclick="app.applyCrop()" style="padding: 12px 24px;">Apply Crop</button>
</div>
<div style="margin-top: 20px; padding: 16px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
<p style="margin: 0; font-size: 13px; color: #92400e; line-height: 1.5;">
<strong>Note:</strong> Full crop functionality is coming soon. For now, you can use image editing software to crop images before uploading.
</p>
</div>
</div>
</div>
</div>
<!-- Adjust Image Modal -->
<div class="modal" id="adjustImageModal">
<div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
<span class="modal-close" onclick="app.closeModal('adjustImageModal')"></span>
<div class="modal-header">Adjust Image</div>
<div style="padding: 20px;">
<!-- Preview -->
<div style="background: #f3f4f6; border-radius: 12px; padding: 20px; margin-bottom: 24px; text-align: center;">
<img id="adjustImagePreview" src="" alt="Image preview" style="max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
</div>

<!-- Correction Section -->
<div style="margin-bottom: 24px; padding: 16px; background: #f9fafb; border-radius: 12px;">
<h3 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #374151;">Correction</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
<div>
<label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 8px;">Sharpen / Soften</label>
<div style="display: flex; align-items: center; gap: 12px;">
<input type="range" id="sharpenSlider" min="-100" max="100" value="0" oninput="app.updateImageFilter('sharpen', this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none;">
<input type="number" id="sharpenInput" min="-100" max="100" value="0" onchange="app.updateImageFilter('sharpen', this.value)" style="width: 70px; padding: 6px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center;">
</div>
</div>
<div>
<label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 8px;">Brightness</label>
<div style="display: flex; align-items: center; gap: 12px;">
<input type="range" id="brightnessSlider" min="-100" max="100" value="0" oninput="app.updateImageFilter('brightness', this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none;">
<input type="number" id="brightnessInput" min="-100" max="100" value="0" onchange="app.updateImageFilter('brightness', this.value)" style="width: 70px; padding: 6px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center;">
</div>
</div>
<div>
<label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 8px;">Contrast</label>
<div style="display: flex; align-items: center; gap: 12px;">
<input type="range" id="contrastSlider" min="-100" max="100" value="0" oninput="app.updateImageFilter('contrast', this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none;">
<input type="number" id="contrastInput" min="-100" max="100" value="0" onchange="app.updateImageFilter('contrast', this.value)" style="width: 70px; padding: 6px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center;">
</div>
</div>
</div>
</div>

<!-- Color Section -->
<div style="margin-bottom: 24px; padding: 16px; background: #f9fafb; border-radius: 12px;">
<h3 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #374151;">Color</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px;">
<div>
<label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 8px;">Saturation</label>
<div style="display: flex; align-items: center; gap: 12px;">
<input type="range" id="saturationSlider" min="-100" max="100" value="0" oninput="app.updateImageFilter('saturation', this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none;">
<input type="number" id="saturationInput" min="-100" max="100" value="0" onchange="app.updateImageFilter('saturation', this.value)" style="width: 70px; padding: 6px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center;">
</div>
</div>
<div>
<label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 8px;">Color Tone</label>
<div style="display: flex; align-items: center; gap: 12px;">
<input type="range" id="toneSlider" min="-100" max="100" value="0" oninput="app.updateImageFilter('tone', this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none;">
<input type="number" id="toneInput" min="-100" max="100" value="0" onchange="app.updateImageFilter('tone', this.value)" style="width: 70px; padding: 6px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center;">
</div>
</div>
<div>
<label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 8px;">Recolor</label>
<select id="recolorSelect" onchange="app.updateImageFilter('recolor', this.value)" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; background: white;">
<option value="none">None</option>
<option value="sepia">Sepia</option>
<option value="grayscale">Grayscale</option>
<option value="invert">Invert</option>
<option value="warm">Warm</option>
<option value="cool">Cool</option>
</select>
</div>
</div>
</div>

<!-- Artistic Effects Section -->
<div style="margin-bottom: 24px; padding: 16px; background: #f9fafb; border-radius: 12px;">
<h3 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #374151;">Artistic Effects</h3>
<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('none')" style="padding: 12px;">None</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('blur')" style="padding: 12px;">Blur</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('fog')" style="padding: 12px;">Fog</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('paper')" style="padding: 12px;">Paper</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('vintage')" style="padding: 12px;">Vintage</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('pencil')" style="padding: 12px;">Pencil</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('watercolor')" style="padding: 12px;">Watercolor</button>
<button class="properties-arrange-btn" onclick="app.applyArtisticEffect('oil')" style="padding: 12px;">Oil</button>
</div>
</div>

<!-- Actions -->
<div style="display: flex; gap: 12px; justify-content: center; padding-top: 16px; border-top: 1px solid #e5e7eb;">
<button class="tool-btn" onclick="app.resetImageFilters()" style="padding: 12px 24px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db;">Reset Image</button>
<button class="tool-btn" onclick="app.closeModal('adjustImageModal')" style="padding: 12px 24px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db;">Cancel</button>
<button class="tool-btn tool-btn-primary" onclick="app.applyImageFilters()" style="padding: 12px 24px;">Apply</button>
</div>
</div>
</div>
</div>
<!-- Themes Modal -->
<div class="modal" id="themesModal">
<div class="modal-content" style="max-width: 900px;">
<span class="modal-close" onclick="app.closeModal('themesModal')"></span>
<div class="modal-header">Choose Theme</div>
<div class="bg-grid" id="themesGrid">
<!-- Themes will be loaded here -->
</div>
</div>
</div>
<!-- Animation Modal -->
<div class="modal" id="animModal">
<div class="modal-content">
<span class="modal-close" onclick="app.closeModal('animModal')"></span>
<div class="modal-header">Choose Animation</div>
<div class="animation-grid">
<div class="animation-option" onclick="app.applyAnimation('none')">None</div>
<div class="animation-option" onclick="app.applyAnimation('fadeIn')">Fade In</div>
<div class="animation-option" onclick="app.applyAnimation('slideInLeft')">Slide In Left</div>
<div class="animation-option" onclick="app.applyAnimation('slideInRight')">Slide In Right</div>
<div class="animation-option" onclick="app.applyAnimation('slideInUp')">Slide In Up</div>
<div class="animation-option" onclick="app.applyAnimation('slideInDown')">Slide In Down</div>
<div class="animation-option" onclick="app.applyAnimation('zoomIn')">Zoom In</div>
<div class="animation-option" onclick="app.applyAnimation('bounce')">Bounce</div>
</div>
</div>
</div>
<!-- AI Assistant Sidebar -->
<div class="ai-sidebar" id="aiSidebar">
<div class="ai-sidebar-header">
<h3>
<span>AI Smart Assistant</span>
</h3>
<button class="ai-sidebar-close" onclick="app.toggleAIPanel()"></button>
</div>
<div class="ai-sidebar-content">
<div class="ai-sidebar-messages" id="aiChatMessages">
<div class="ai-message ai-assistant">
<div class="ai-message-content">
<div style="font-weight: 600; margin-bottom: 4px; color: #10b981;">AI Assistant</div>
<div>Hello! I'm your creative AI assistant. I can automatically:</div>
<ul style="margin: 8px 0; padding-left: 20px; color: #64748b;">
<li>Create complete slides with titles, content, and visuals</li>
<li>Add images from the internet related to your topic</li>
<li>Create charts and graphs with data</li>
<li>Add bullet points and organize content beautifully</li>
<li>Design professional layouts automatically</li>
</ul>
<div style="margin-top: 16px; padding: 12px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bae6fd;">
<div style="font-weight: 600; margin-bottom: 8px; color: #0369a1;">Choose Language:</div>
<div style="display: flex; gap: 8px;">
<button onclick="app.setAILanguage('ar')" class="ai-lang-btn" style="flex: 1; padding: 10px; background: white; border: 2px solid #bae6fd; border-radius: 8px; cursor: pointer; font-weight: 600; color: #0369a1; transition: all 0.2s;"> </button>
<button onclick="app.setAILanguage('en')" class="ai-lang-btn" style="flex: 1; padding: 10px; background: #0369a1; color: white; border: 2px solid #0369a1; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s;"> English</button>
</div>
</div>
</div>
</div>
</div>
<div id="aiPreviewContainer" style="display: none; padding: 0 20px 20px 20px;"></div>
</div>
<div class="ai-sidebar-input-area">
<div style="display: flex; gap: 8px;">
<input type="text" id="aiChatInput" placeholder="Type your request... (e.g., Create 5 slides about AI)" style="flex: 1; padding: 12px 16px; border: 2px solid #e5e7eb; border-radius: 12px; font-size: 14px; font-family: inherit; outline: none; transition: border-color 0.2s;" onkeypress="if(event.key === 'Enter') app.sendAIMessage()">
<button onclick="app.sendAIMessage()" style="padding: 12px 24px; background: linear-gradient(135deg, #10b981 0%, #14b8a6 50%, #38bdf8 100%); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">Send</button>
</div>
<div id="aiLoading" style="display: none; margin-top: 12px; padding: 12px; background: #f0f9ff; border-radius: 8px; color: #0369a1; font-size: 13px;">
<div style="display: flex; align-items: center; gap: 8px;">
<div class="ai-spinner"></div>
<span id="aiLoadingText">Processing...</span>
</div>
</div>
</div>
</div>
</div>
<script>
        const app = {
            data: [{ els: [], bg: 'white', transition: 'fade' }],
            curr: 0,
            sel: null,
            drag: null,
            resize: null,
            history: [],
            historyIndex: -1,
            presenting: false,
            presentSlide: 0,
            copiedStyle: null,
            zoom: 100,
            gridVisible: false,
            snapToGrid: false,
            snapThreshold: 10,

            activeCategory: null,
            thumbnailUpdateTimeout: null,

            init() {
                this.loadCanvas();
                this.renderSlides();
                this.setupDragDrop();
                this.setupKeyboardShortcuts();
                this.saveState();
                
                // Auto-generate slides when title is entered
                this.setupAutoGenerateFromTitle();
                
                // Hide context menu on click anywhere
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#contextMenu')) {
                        this.hideContextMenu();
                    }
                });
            },
            
            titleAutoGenerateTimeout: null,
            hasAutoGenerated: false,
            
            setupAutoGenerateFromTitle() {
                const titleInput = document.getElementById('title');
                if (!titleInput) return;
                
                // Clear any existing timeout
                if (this.titleAutoGenerateTimeout) {
                    clearTimeout(this.titleAutoGenerateTimeout);
                }
                
                // Listen for when user finishes typing (blur event)
                titleInput.addEventListener('blur', () => {
                    this.handleTitleChange();
                });
                
                // Also listen for Enter key
                titleInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        titleInput.blur(); // Trigger blur to generate slides
                    }
                });
            },
            
            async handleTitleChange() {
                const titleInput = document.getElementById('title');
                if (!titleInput) return;
                
                const title = titleInput.value.trim();
                
                // Only auto-generate if:
                // 1. Title is not empty
                // 2. Title is meaningful (at least 3 characters)
                if (!title || title.length < 3) {
                    return;
                }
                
                // Check if we should auto-generate
                // Only auto-generate if there are no slides OR slides are empty
                const hasRealContent = this.data.length > 0 && this.data.some(slide => {
                    // Check if slide has meaningful content (not just empty)
                    if (slide.variant === 'ai' && slide.title && slide.title !== 'Untitled Presentation') {
                        return true; // AI slide with title is considered content
                    }
                    if (slide.els && slide.els.length > 0) {
                        // Check if elements have actual content
                        return slide.els.some(el => {
                            if (el.type === 'text' && el.content && el.content.trim().length > 10) {
                                return true;
                            }
                            return el.type === 'image' || el.type === 'chart';
                        });
                    }
                    return false;
                });
                
                // Check if title has changed significantly
                const lastTitle = localStorage.getItem('lastAutoGeneratedTitle');
                if (lastTitle === title && hasRealContent) {
                    console.log(' Skipping auto-generation: Same title and content already exists');
                    return;
                }
                
                // Only auto-generate if there's no real content yet
                if (hasRealContent && this.hasAutoGenerated) {
                    console.log(' Skipping auto-generation: Content already exists');
                    return;
                }
                
                console.log(' Auto-generating slides for title:', title);
                
                // Show loading message in AI chat if available
                const aiMessages = document.getElementById('aiChatMessages');
                if (aiMessages) {
                    const loadingMsg = document.createElement('div');
                    loadingMsg.className = 'ai-message ai-assistant';
                    loadingMsg.innerHTML = `
                        <div class="ai-message-content">
                            <div style="font-weight: 600; margin-bottom: 4px; color: #10b981;">AI Assistant</div>
                            <div> Creating slides automatically for "${title}"...</div>
                        </div>
                    `;
                    aiMessages.appendChild(loadingMsg);
                    aiMessages.scrollTop = aiMessages.scrollHeight;
                }
                
                try {
                    // Use default slide count (5 slides)
                    const slideCount = 5;
                    
                    // Use the existing AI generation function
                    if (typeof replaceSlidesWithAIGeneration === 'function') {
                        // Call the function (now async - generates images with DALL-E)
                        await replaceSlidesWithAIGeneration(
                            { 
                                title: title, 
                                description: '', 
                                slideCount: slideCount 
                            },
                            { silent: false }
                        );
                        
                        // Mark as auto-generated
                        this.hasAutoGenerated = true;
                        localStorage.setItem('lastAutoGeneratedTitle', title);
                        
                        // Show success message
                        if (aiMessages) {
                            const successMsg = document.createElement('div');
                            successMsg.className = 'ai-message ai-assistant';
                            successMsg.innerHTML = `
                                <div class="ai-message-content">
                                    <div style="font-weight: 600; margin-bottom: 4px; color: #10b981;">AI Assistant</div>
                                    <div> Successfully created ${slideCount} slides about "${title}"!</div>
                                </div>
                            `;
                            aiMessages.appendChild(successMsg);
                            aiMessages.scrollTop = aiMessages.scrollHeight;
                        }
                        
                        console.log(' Auto-generation complete!');
                    } else {
                        throw new Error('replaceSlidesWithAIGeneration function not found');
                    }
                } catch (error) {
                    console.error(' Auto-generation failed:', error);
                    
                    // Show error message
                    if (aiMessages) {
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'ai-message ai-assistant';
                        errorMsg.innerHTML = `
                            <div class="ai-message-content" style="background: #fee2e2; border-color: #ef4444; color: #991b1b;">
                                <div style="font-weight: 600; margin-bottom: 4px; color: #dc2626;">AI Assistant</div>
                                <div> Error: ${error.message}</div>
                            </div>
                        `;
                        aiMessages.appendChild(errorMsg);
                        aiMessages.scrollTop = aiMessages.scrollHeight;
                    }
                }
            },

            showCategory(category) {
                console.log('showCategory called with:', category);
                
                // Handle AI Assistant button separately
                if (category === 'ai-assistant' || !category) {
                    const chatbotModal = document.getElementById('chatbot-modal');
                    if (chatbotModal) {
                        chatbotModal.classList.remove('hidden');
                        chatbotModal.classList.add('flex');
                    }
                    // Toggle active state for the button
                    const chatbotToggle = document.getElementById('chatbot-toggle');
                    if (chatbotToggle) {
                        if (chatbotToggle.classList.contains('active')) {
                            chatbotToggle.classList.remove('active');
                            if (chatbotModal) {
                                chatbotModal.classList.add('hidden');
                                chatbotModal.classList.remove('flex');
                            }
                        } else {
                            chatbotToggle.classList.add('active');
                        }
                    }
                    return;
                }
                
                const panel = document.getElementById('categoryPanel');
                const content = document.getElementById('categoryPanelContent');
                const tabs = document.querySelectorAll('.category-tab');
                const propertiesPanel = document.getElementById('propertiesPanel');
                
                if (!panel || !content) {
                    console.error('Category panel or content not found!');
                    return;
                }
                
                // Toggle active state
                if (this.activeCategory === category) {
                    // Close panel if clicking same category
                    panel.classList.remove('show');
                    tabs.forEach(tab => {
                        if (tab.dataset.category === category) {
                            tab.classList.remove('active');
                        }
                    });
                    this.activeCategory = null;
                    // Remove padding from properties panel
                    if (propertiesPanel) {
                        propertiesPanel.classList.remove('category-panel-open');
                    }
                    return;
                }

                // Update active tab
                tabs.forEach(tab => {
                    const tabCategory = tab.dataset.category || (tab.id === 'chatbot-toggle' ? 'ai-assistant' : null);
                    tab.classList.toggle('active', tabCategory === category);
                });

                // Show panel and set content
                this.activeCategory = category;
                const categoryContent = this.getCategoryContent(category);
                if (categoryContent) {
                    content.innerHTML = categoryContent;
                panel.classList.add('show');
                } else {
                    console.warn('No content found for category:', category);
                }
                
                // Add padding to properties panel when category panel is open
                if (propertiesPanel) {
                    propertiesPanel.classList.add('category-panel-open');
                }
            },

            getCategoryContent(category) {
                const contents = {
                    design: `
                        <div class="category-panel-group">
                            <div class="dropdown-wrapper">
                                <button class="tool-btn dropdown-btn" onclick="app.toggleDropdown('bgColorDropdown')">Background Color</button>
                                <div class="category-dropdown" id="bgColorDropdown">
                                    <div class="category-dropdown-item" onclick="app.uploadBgImage(); app.closeDropdown('bgColorDropdown');" style="display: flex; align-items: center; gap: 8px; padding: 10px;">
                                        <span style="font-size: 16px;"></span>
                                        <span>Upload Image</span>
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; padding: 10px;">
                                        <div class="bg-color-item" onclick="app.applyBg('white'); app.closeDropdown('bgColorDropdown');" style="background: white; border: 1px solid #e5e7eb;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#f0fdf4'); app.closeDropdown('bgColorDropdown');" style="background: #f0fdf4;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#ecfdf5'); app.closeDropdown('bgColorDropdown');" style="background: #ecfdf5;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#dcfce7'); app.closeDropdown('bgColorDropdown');" style="background: #dcfce7;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#d1fae5'); app.closeDropdown('bgColorDropdown');" style="background: #d1fae5;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#a7f3d0'); app.closeDropdown('bgColorDropdown');" style="background: #a7f3d0;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#e0f2fe'); app.closeDropdown('bgColorDropdown');" style="background: #e0f2fe;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#bae6fd'); app.closeDropdown('bgColorDropdown');" style="background: #bae6fd;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#7dd3fc'); app.closeDropdown('bgColorDropdown');" style="background: #7dd3fc;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#ccfbf1'); app.closeDropdown('bgColorDropdown');" style="background: #ccfbf1;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#99f6e4'); app.closeDropdown('bgColorDropdown');" style="background: #99f6e4;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#5eead4'); app.closeDropdown('bgColorDropdown');" style="background: #5eead4;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#dbeafe'); app.closeDropdown('bgColorDropdown');" style="background: #dbeafe;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#bfdbfe'); app.closeDropdown('bgColorDropdown');" style="background: #bfdbfe;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#93c5fd'); app.closeDropdown('bgColorDropdown');" style="background: #93c5fd;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#e0e7ff'); app.closeDropdown('bgColorDropdown');" style="background: #e0e7ff;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#c7d2fe'); app.closeDropdown('bgColorDropdown');" style="background: #c7d2fe;"></div>
                                        <div class="bg-color-item" onclick="app.applyBg('#a5b4fc'); app.closeDropdown('bgColorDropdown');" style="background: #a5b4fc;"></div>
                                    </div>
                                    <div style="padding: 10px; border-top: 1px solid #e5e7eb; margin-top: 8px;">
                                        <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #64748b; margin-bottom: 10px;">Gradients</div>
                                        <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px;">
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #bae6fd 0%, #7dd3fc 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #bae6fd 0%, #7dd3fc 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #99f6e4 0%, #5eead4 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #99f6e4 0%, #5eead4 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #f472b6 0%, #ec4899 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #f472b6 0%, #ec4899 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #34d399 0%, #10b981 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #34d399 0%, #10b981 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #fda4af 0%, #f43f5e 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #fda4af 0%, #f43f5e 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #818cf8 0%, #6366f1 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #818cf8 0%, #6366f1 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #fb923c 0%, #f97316 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);"></div>
                                            <div class="bg-color-item" onclick="app.applyBg('linear-gradient(135deg, #2dd4bf 0%, #14b8a6 100%)'); app.closeDropdown('bgColorDropdown');" style="background: linear-gradient(135deg, #2dd4bf 0%, #14b8a6 100%);"></div>
                                        </div>
                                    </div>
                                    <div style="padding: 10px; border-top: 1px solid #e5e7eb; margin-top: 8px;">
                                        <div style="display: flex; align-items: center; gap: 12px;">
                                            <label style="font-size: 12px; font-weight: 500; color: #374151; min-width: 90px;">Transparency</label>
                                            <input type="range" id="bgTransparencySlider" min="0" max="100" value="0" oninput="app.updateBgTransparency(this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none;">
                                            <div style="display: flex; align-items: center; gap: 4px;">
                                                <input type="number" id="bgTransparencyInput" min="0" max="100" value="0" onchange="app.updateBgTransparency(this.value)" oninput="app.updateBgTransparency(this.value)" style="width: 60px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center; outline: none;">
                                                <span style="font-size: 12px; color: #6b7280;">%</span>
                                                <div style="display: flex; flex-direction: column; gap: 2px;">
                                                    <button type="button" onclick="app.adjustTransparency(1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                                    <button type="button" onclick="app.adjustTransparency(-1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <button class="tool-btn" onclick="app.showTemplates()">Layout</button>
                            <button class="tool-btn" onclick="app.showThemes()">Themes</button>
                        </div>
                    `,
                    text: `
                        <div class="category-panel-group">
                            <button class="tool-btn tool-btn-primary" onclick="app.addText()">+ Add Text</button>
                        </div>
                        <div class="category-panel-group">
                            <span class="category-panel-label">Font</span>
                            <select class="tool-btn" id="fontFamily" onchange="app.changeFont()" style="text-transform: none; letter-spacing: 0;">
                                <option value="Arial">Arial</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Kraft Mono">Kraft Mono</option>
                                <option value="ID Grotesk">ID Grotesk</option>
                            </select>
                            <input class="tool-btn" id="fontSize" type="number" min="8" max="200" value="24" onchange="app.changeFontSize()" placeholder="Size" style="width: 80px; text-transform: none; letter-spacing: 0;" />
                        </div>
                        <div class="category-panel-group">
                            <button class="tool-btn tool-btn-icon" onclick="app.toggleBold()" title="Bold"><strong>B</strong></button>
                            <button class="tool-btn tool-btn-icon" onclick="app.toggleItalic()" title="Italic"><em>I</em></button>
                            <button class="tool-btn tool-btn-icon" onclick="app.toggleUnderline()" title="Underline"><u>U</u></button>
                        </div>
                        <div class="category-panel-group">
                            <span class="category-panel-label">Color</span>
                            <input type="color" id="textColor" value="#000000" onchange="app.changeTextColor()" style="width: 44px; height: 40px; border: 1px solid rgba(226, 232, 240, 0.8); border-radius: 10px; cursor: pointer; box-shadow: 0 2px 4px rgba(15, 23, 42, 0.08);" />
                            <input type="color" id="bgColor" value="#ffffff" onchange="app.changeBgColor()" style="width: 44px; height: 40px; border: 1px solid rgba(226, 232, 240, 0.8); border-radius: 10px; cursor: pointer; box-shadow: 0 2px 4px rgba(15, 23, 42, 0.08);" />
                        </div>
                        <div class="category-panel-group">
                            <span class="category-panel-label">Align</span>
                            <button class="tool-btn tool-btn-icon" onclick="app.alignText('left')" title="Align Left"></button>
                            <button class="tool-btn tool-btn-icon" onclick="app.alignText('center')" title="Align Center"></button>
                            <button class="tool-btn tool-btn-icon" onclick="app.alignText('right')" title="Align Right"></button>
                        </div>
                    `,
                    image: `
                        <div class="category-panel-group">
                            <button class="tool-btn tool-btn-primary" onclick="app.addImage()">Upload Image</button>
                        </div>
                        <div class="category-panel-group">
                            <button class="tool-btn" onclick="app.removeBackground()">Remove Background</button>
                        </div>
                    `,
                    'shape-data': `
                        <div class="category-panel-group">
                            <div class="dropdown-wrapper">
                                <button class="tool-btn dropdown-btn" onclick="app.toggleDropdown('shapesDropdown')">Shapes</button>
                                <div class="category-dropdown" id="shapesDropdown">
                                    <div class="category-dropdown-item" onclick="app.addShape('rectangle'); app.closeDropdown('shapesDropdown')">Rectangle</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('circle'); app.closeDropdown('shapesDropdown')">Circle</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('triangle'); app.closeDropdown('shapesDropdown')">Triangle</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('star'); app.closeDropdown('shapesDropdown')">Star</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('hexagon'); app.closeDropdown('shapesDropdown')">Hexagon</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('diamond'); app.closeDropdown('shapesDropdown')">Diamond</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('arrow-right'); app.closeDropdown('shapesDropdown')">Arrow Right</div>
                                    <div class="category-dropdown-item" onclick="app.addShape('arrow-left'); app.closeDropdown('shapesDropdown')">Arrow Left</div>
                                </div>
                            </div>
                            <div class="dropdown-wrapper">
                                <button class="tool-btn dropdown-btn" onclick="app.toggleDropdown('chartsDropdown')">Charts</button>
                                <div class="category-dropdown" id="chartsDropdown">
                                    <div class="category-dropdown-item" onclick="app.addChart('bar'); app.closeDropdown('chartsDropdown')">Bar Chart</div>
                                    <div class="category-dropdown-item" onclick="app.addChart('line'); app.closeDropdown('chartsDropdown')">Line Chart</div>
                                    <div class="category-dropdown-item" onclick="app.addChart('pie'); app.closeDropdown('chartsDropdown')">Pie Chart</div>
                                    <div class="category-dropdown-item" onclick="app.addChart('flow'); app.closeDropdown('chartsDropdown')">Flow Chart</div>
                                </div>
                            </div>
                            <div class="dropdown-wrapper">
                                <button class="tool-btn dropdown-btn" onclick="app.toggleDropdown('tablesDropdown')">Tables</button>
                                <div class="category-dropdown" id="tablesDropdown">
                                    <div class="category-dropdown-item" onclick="app.addTable(2, 2); app.closeDropdown('tablesDropdown')">2x2 Table</div>
                                    <div class="category-dropdown-item" onclick="app.addTable(3, 3); app.closeDropdown('tablesDropdown')">3x3 Table</div>
                                    <div class="category-dropdown-item" onclick="app.addTable(4, 4); app.closeDropdown('tablesDropdown')">4x4 Table</div>
                                </div>
                            </div>
                            <div class="dropdown-wrapper">
                                <button class="tool-btn dropdown-btn" onclick="app.toggleDropdown('iconsDropdown')">Symbols</button>
                                <div class="category-dropdown" id="iconsDropdown">
                                    <div class="category-dropdown-item" onclick="app.showSymbols('arrows'); app.closeDropdown('iconsDropdown')">Arrows</div>
                                    <div class="category-dropdown-item" onclick="app.showSymbols('shapes'); app.closeDropdown('iconsDropdown')">Shapes</div>
                                    <div class="category-dropdown-item" onclick="app.showSymbols('symbols'); app.closeDropdown('iconsDropdown')">Symbols</div>
                                </div>
                            </div>
                        </div>
                    `,
                    arrange: `
                        <div class="category-panel-group">
                            <div class="dropdown-wrapper">
                                <button class="tool-btn dropdown-btn" onclick="app.toggleDropdown('alignDropdown')">Align</button>
                                <div class="category-dropdown" id="alignDropdown">
                                    <div class="category-dropdown-item" onclick="app.alignElements('left'); app.closeDropdown('alignDropdown')">Align Left</div>
                                    <div class="category-dropdown-item" onclick="app.alignElements('center'); app.closeDropdown('alignDropdown')">Align Center</div>
                                    <div class="category-dropdown-item" onclick="app.alignElements('right'); app.closeDropdown('alignDropdown')">Align Right</div>
                                    <div class="category-dropdown-item" onclick="app.alignElements('top'); app.closeDropdown('alignDropdown')">Align Top</div>
                                    <div class="category-dropdown-item" onclick="app.alignElements('middle'); app.closeDropdown('alignDropdown')">Align Middle</div>
                                    <div class="category-dropdown-item" onclick="app.alignElements('bottom'); app.closeDropdown('alignDropdown')">Align Bottom</div>
                                </div>
                            </div>
                            <button class="tool-btn" onclick="app.groupElements()">Group</button>
                            <button class="tool-btn" onclick="app.ungroupElements()">Ungroup</button>
                            <button class="tool-btn" onclick="app.duplicateElement()">Duplicate</button>
                            <button class="tool-btn tool-btn-danger" onclick="app.deleteElement()">Delete</button>
                        </div>
                        <div class="category-panel-group">
                            <button class="tool-btn" onclick="app.moveLayer('forward')">Bring Forward</button>
                            <button class="tool-btn" onclick="app.moveLayer('backward')">Send Backward</button>
                            <button class="tool-btn" onclick="app.copyStyle()">Copy Style</button>
                            <button class="tool-btn" onclick="app.pasteStyle()">Paste Style</button>
                            <button class="tool-btn" id="gridBtn" onclick="app.toggleGrid()">Grid</button>
                        </div>
                    `,
                    effects: `
                        <div class="category-panel-group">
                            <span class="category-panel-label">Animations</span>
                            <button class="tool-btn" onclick="app.showAnimations()">Element Animations</button>
                        </div>
                        <div class="category-panel-group">
                            <span class="category-panel-label">Transitions</span>
                            <button class="tool-btn" onclick="app.showTransitions()">Slide Transitions</button>
                        </div>
                    `
                };
                return contents[category] || '';
            },

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in input fields
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true') {
                        return;
                    }

                    // Presentation Mode: F5
                    if (e.key === 'F5') {
                        e.preventDefault();
                        this.presentMode();
                    }

                    // Add Text: T
                    if (e.key === 't' || e.key === 'T') {
                        e.preventDefault();
                        this.addText();
                    }

                    // Add Image: I
                    if (e.key === 'i' || e.key === 'I') {
                        e.preventDefault();
                        this.addImage();
                    }

                    // Toggle Grid: G
                    if (e.key === 'g' || e.key === 'G') {
                        e.preventDefault();
                        this.toggleGrid();
                    }

                    // Delete: Delete or Backspace
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.sel) {
                        e.preventDefault();
                        this.deleteElement();
                    }

                    // Undo: Ctrl+Z
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    }

                    // Redo: Ctrl+Y
                    if (e.ctrlKey && e.key === 'y') {
                        e.preventDefault();
                        this.redo();
                    }

                    // Duplicate: Ctrl+D
                    if (e.ctrlKey && e.key === 'd') {
                        e.preventDefault();
                        this.duplicateElement();
                    }

                    // Bold: Ctrl+B
                    if (e.ctrlKey && e.key === 'b') {
                        e.preventDefault();
                        this.toggleBold();
                    }

                    // Italic: Ctrl+I
                    if (e.ctrlKey && e.key === 'i') {
                        e.preventDefault();
                        this.toggleItalic();
                    }

                    // Underline: Ctrl+U
                    if (e.ctrlKey && e.key === 'u') {
                        e.preventDefault();
                        this.toggleUnderline();
                    }

                    // Save: Ctrl+S
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        this.saveJSON();
                    }

                    // Arrow keys to move selected element
                    if (this.sel && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                        const step = e.shiftKey ? 10 : 1;
                        const currentLeft = parseInt(this.sel.style.left) || 0;
                        const currentTop = parseInt(this.sel.style.top) || 0;

                        switch(e.key) {
                            case 'ArrowLeft':
                                this.sel.style.left = Math.max(0, currentLeft - step) + 'px';
                                break;
                            case 'ArrowRight':
                                this.sel.style.left = Math.min(960 - this.sel.offsetWidth, currentLeft + step) + 'px';
                                break;
                            case 'ArrowUp':
                                this.sel.style.top = Math.max(0, currentTop - step) + 'px';
                                break;
                            case 'ArrowDown':
                                this.sel.style.top = Math.min(540 - this.sel.offsetHeight, currentTop + step) + 'px';
                                break;
                        }
                        this.saveElementPosition();
                    }
                });
            },

            toggleGrid() {
                this.gridVisible = !this.gridVisible;
                const overlays = document.querySelectorAll('.canvas-grid-overlay');
                const btn = document.getElementById('gridBtn');
                
                if (this.gridVisible) {
                    overlays.forEach(overlay => overlay.classList.add('show'));
                    btn.style.background = '#ecfeff';
                    btn.style.color = '#0891b2';
                } else {
                    overlays.forEach(overlay => overlay.classList.remove('show'));
                    btn.style.background = 'white';
                    btn.style.color = '#374151';
                }
            },

            snapToGridPosition(value) {
                if (!this.snapToGrid) return value;
                const gridSize = 20;
                return Math.round(value / gridSize) * gridSize;
            },

            showSnapLine(type, position) {
                const slides = document.querySelectorAll('.canvas-slide');
                const currentSlide = slides[this.curr];
                if (!currentSlide) return;
                
                const line = document.createElement('div');
                line.className = `snap-line ${type}`;
                if (type === 'horizontal') {
                    line.style.top = position + 'px';
                } else {
                    line.style.left = position + 'px';
                }
                currentSlide.appendChild(line);
                setTimeout(() => line.remove(), 500);
            },

            showNotification(message, type = 'success') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                const icons = {
                    success: '',
                    error: '',
                    warning: ''
                };
                
                notification.innerHTML = `
                    <span class="notification-icon">${icons[type] || icons.success}</span>
                    <span class="notification-text">${message}</span>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            },

            showLoading() {
                const overlay = document.createElement('div');
                overlay.className = 'loading-overlay';
                overlay.id = 'loadingOverlay';
                overlay.innerHTML = '<div class="loading-spinner"></div>';
                document.body.appendChild(overlay);
            },

            hideLoading() {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.remove();
            },

            setupDragDrop() {
                const wrapper = document.getElementById('canvasWrapper');
                
                wrapper.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('resize-handle')) {
                        const parentEl = e.target.parentElement;
                        // Don't allow resizing locked elements
                        if (parentEl.dataset.locked === 'true') {
                            return;
                        }
                        this.resize = {
                            el: parentEl,
                            handle: e.target.className.split(' ')[1],
                            startX: e.clientX,
                            startY: e.clientY,
                            startWidth: parentEl.offsetWidth,
                            startHeight: parentEl.offsetHeight,
                            startLeft: parentEl.offsetLeft,
                            startTop: parentEl.offsetTop
                        };
                        return;
                    }
                    
                    if (e.target.classList.contains('element') || e.target.closest('.element')) {
                        const el = e.target.classList.contains('element') ? e.target : e.target.closest('.element');
                        
                        // Check if element is locked
                        if (el.dataset.locked === 'true') {
                            return; // Don't allow interaction with locked elements
                        }
                        
                        const slideIndex = parseInt(el.dataset.slideIndex);
                        
                        // Switch to this slide if not current
                        if (slideIndex !== this.curr) {
                            this.switchSlide(slideIndex);
                            return;
                        }
                        
                        this.selectElement(el);
                        this.drag = {
                            el: el,
                            startX: e.clientX,
                            startY: e.clientY,
                            startLeft: el.offsetLeft,
                            startTop: el.offsetTop
                        };
                    } else {
                        this.deselectAll();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.drag) {
                        const dx = (e.clientX - this.drag.startX) / (this.zoom / 100);
                        const dy = (e.clientY - this.drag.startY) / (this.zoom / 100);
                        
                        let newLeft = this.drag.startLeft + dx;
                        let newTop = this.drag.startTop + dy;

                        // Snap to grid if enabled
                        if (e.shiftKey) {
                            newLeft = this.snapToGridPosition(newLeft);
                            newTop = this.snapToGridPosition(newTop);
                        }

                        // Keep element within canvas bounds
                        newLeft = Math.max(0, Math.min(960 - this.drag.el.offsetWidth, newLeft));
                        newTop = Math.max(0, Math.min(540 - this.drag.el.offsetHeight, newTop));

                        this.drag.el.style.left = newLeft + 'px';
                        this.drag.el.style.top = newTop + 'px';

                        // Show snap guidelines at center
                        const centerX = newLeft + this.drag.el.offsetWidth / 2;
                        const centerY = newTop + this.drag.el.offsetHeight / 2;
                        
                        if (Math.abs(centerX - 480) < this.snapThreshold) {
                            this.showSnapLine('vertical', 480);
                            this.drag.el.style.left = (480 - this.drag.el.offsetWidth / 2) + 'px';
                        }
                        if (Math.abs(centerY - 270) < this.snapThreshold) {
                            this.showSnapLine('horizontal', 270);
                            this.drag.el.style.top = (270 - this.drag.el.offsetHeight / 2) + 'px';
                        }
                    }
                    
                    if (this.resize) {
                        const dx = (e.clientX - this.resize.startX) / (this.zoom / 100);
                        const dy = (e.clientY - this.resize.startY) / (this.zoom / 100);
                        
                        if (this.resize.handle.includes('e')) {
                            this.resize.el.style.width = Math.max(20, this.resize.startWidth + dx) + 'px';
                        }
                        if (this.resize.handle.includes('w')) {
                            const newWidth = Math.max(20, this.resize.startWidth - dx);
                            this.resize.el.style.width = newWidth + 'px';
                            this.resize.el.style.left = (this.resize.startLeft + dx) + 'px';
                        }
                        if (this.resize.handle.includes('s')) {
                            this.resize.el.style.height = Math.max(20, this.resize.startHeight + dy) + 'px';
                        }
                        if (this.resize.handle.includes('n')) {
                            const newHeight = Math.max(20, this.resize.startHeight - dy);
                            this.resize.el.style.height = newHeight + 'px';
                            this.resize.el.style.top = (this.resize.startTop + dy) + 'px';
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.drag || this.resize) {
                        this.saveElementPosition();
                        this.drag = null;
                        this.resize = null;
                    }
                });
            },

            selectElement(el) {
                if (!el || !el.dataset || !el.dataset.id) {
                    console.error('Invalid element selected');
                    return;
                }
                
                // Don't allow selection of locked elements
                if (el.dataset.locked === 'true') {
                    return;
                }
                
                this.deselectAll();
                el.classList.add('selected');
                this.sel = el;
                
                // Convert dataset.id to number for comparison (dataset.id is always a string)
                const elementId = parseInt(el.dataset.id, 10);
                const data = this.data[this.curr].els.find(e => e.id == elementId || e.id == el.dataset.id);
                if (!data) {
                    console.error('Element data not found for id:', el.dataset.id, 'Current slide:', this.curr, 'Available elements:', this.data[this.curr].els.map(e => e.id));
                    this.renderPropertiesPanel(null);
                    return;
                }
                
                if (data.type === 'text') {
                    const fontFamily = document.getElementById('fontFamily');
                    const fontSize = document.getElementById('fontSize');
                    const textColor = document.getElementById('textColor');
                    const bgColor = document.getElementById('bgColor');
                    
                    if (fontFamily) fontFamily.value = data.font || 'Arial';
                    if (fontSize) fontSize.value = data.size || 24;
                    if (textColor) textColor.value = data.color || '#000000';
                    if (bgColor) bgColor.value = data.bg || '#ffffff';
                }
                
                // Always render properties panel with the data
                this.renderPropertiesPanel(data);
            },

            deselectAll() {
                document.querySelectorAll('.element').forEach(el => el.classList.remove('selected'));
                this.sel = null;
                this.renderPropertiesPanel(null);
            },

            renderPropertiesPanel(data) {
                try {
                    const panel = document.getElementById('propertiesPanel');
                    const content = document.getElementById('propertiesContent');
                    const actions = document.getElementById('propertiesActions');
                    
                    if (!panel || !content) {
                        console.error('Properties panel elements not found');
                        return;
                    }

                    if (!data || !this.sel) {
                        // Hide panel when no selection
                        panel.classList.remove('visible');
                        panel.classList.remove('category-panel-open');
                        if (actions) actions.style.display = 'none';
                        content.innerHTML = `
                            <div class="properties-empty">
                                <div class="properties-empty-title">No Selection</div>
                                <div class="properties-empty-text">Select an element on the canvas to edit its properties</div>
                            </div>
                        `;
                        return;
                    }

                    // Show panel when element is selected
                    panel.classList.add('visible');
                    if (actions) actions.style.display = 'flex';
                    
                    // Check if category panel is open and add padding
                    const categoryPanel = document.getElementById('categoryPanel');
                    if (categoryPanel && categoryPanel.classList.contains('show')) {
                        panel.classList.add('category-panel-open');
                    } else {
                        panel.classList.remove('category-panel-open');
                    }

                    let html = '';

                    // Validate data type
                    if (!data.type) {
                        console.error('Element data missing type:', data);
                        content.innerHTML = `
                            <div class="properties-empty">
                                <div class="properties-empty-title">Error</div>
                                <div class="properties-empty-text">Invalid element data</div>
                            </div>
                        `;
                        return;
                    }

                if (data.type === 'shape') {
                    html = `
                        <div class="properties-group">
                            <label class="properties-label">Fill Color</label>
                            <input type="color" class="properties-color-input" id="propFillColor" value="${data.bg || '#10b981'}" onchange="app.updateShapeProperty('bg', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Border Color</label>
                            <input type="color" class="properties-color-input" id="propBorderColor" value="${data.border || '#047857'}" onchange="app.updateShapeProperty('border', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Border Width</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="number" class="properties-input" id="propBorderWidth" min="0" max="20" value="${data.thick || 2}" onchange="app.updateShapeProperty('thick', parseInt(this.value))" style="flex: 1;">
                                <div style="display: flex; flex-direction: column; gap: 2px;">
                                    <button type="button" onclick="app.adjustProperty('propBorderWidth', 1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                    <button type="button" onclick="app.adjustProperty('propBorderWidth', -1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                </div>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Arrange</label>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('left')" title="Align Left"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('center')" title="Align Center"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('right')" title="Align Right"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('top')" title="Align Top"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('middle')" title="Align Middle"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('bottom')" title="Align Bottom"></button>
                            </div>
                        </div>
                    `;
                } else if (data.type === 'text') {
                    html = `
                        <div class="properties-group">
                            <label class="properties-label">Text Color</label>
                            <input type="color" class="properties-color-input" id="propTextColor" value="${data.color || '#000000'}" onchange="app.updateTextProperty('color', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Background Color</label>
                            <input type="color" class="properties-color-input" id="propTextBg" value="${data.bg || 'transparent'}" onchange="app.updateTextProperty('bg', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Border Color</label>
                            <input type="color" class="properties-color-input" id="propTextBorderColor" value="${data.borderColor || '#000000'}" onchange="app.updateTextProperty('borderColor', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Border Width</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="number" class="properties-input" id="propTextBorderWidth" min="0" max="20" value="${data.borderWidth || 0}" onchange="app.updateTextProperty('borderWidth', parseInt(this.value))" style="flex: 1;">
                                <div style="display: flex; flex-direction: column; gap: 2px;">
                                    <button type="button" onclick="app.adjustProperty('propTextBorderWidth', 1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                    <button type="button" onclick="app.adjustProperty('propTextBorderWidth', -1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                </div>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Font Size</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="number" class="properties-input" id="propFontSize" min="8" max="200" value="${data.size || 24}" onchange="app.updateTextProperty('size', parseInt(this.value))" style="flex: 1;">
                                <div style="display: flex; flex-direction: column; gap: 2px;">
                                    <button type="button" onclick="app.adjustProperty('propFontSize', 1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                    <button type="button" onclick="app.adjustProperty('propFontSize', -1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                </div>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Arrange</label>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('left')" title="Align Left"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('center')" title="Align Center"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('right')" title="Align Right"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('top')" title="Align Top"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('middle')" title="Align Middle"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('bottom')" title="Align Bottom"></button>
                            </div>
                        </div>
                    `;
                } else if (data.type === 'image') {
                    html = `
                        <div class="properties-group">
                            <label class="properties-label">Border Color</label>
                            <input type="color" class="properties-color-input" id="propImgBorderColor" value="${data.borderColor || '#000000'}" onchange="app.updateImageProperty('borderColor', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Border Width</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="number" class="properties-input" id="propImgBorderWidth" min="0" max="20" value="${data.borderWidth || 0}" onchange="app.updateImageProperty('borderWidth', parseInt(this.value))" style="flex: 1;">
                                <div style="display: flex; flex-direction: column; gap: 2px;">
                                    <button type="button" onclick="app.adjustProperty('propImgBorderWidth', 1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                    <button type="button" onclick="app.adjustProperty('propImgBorderWidth', -1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                </div>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Transparency</label>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <input type="range" id="imgTransparencySlider" min="0" max="100" value="${data.transparency || 0}" oninput="app.updateImageTransparency(this.value)" style="flex: 1; height: 6px; border-radius: 3px; background: #e5e7eb; outline: none; cursor: pointer; -webkit-appearance: none;">
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <input type="number" id="imgTransparencyInput" min="0" max="100" value="${data.transparency || 0}" onchange="app.updateImageTransparency(this.value)" oninput="app.updateImageTransparency(this.value)" style="width: 60px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; text-align: center; outline: none;">
                                    <span style="font-size: 12px; color: #6b7280;">%</span>
                                    <div style="display: flex; flex-direction: column; gap: 2px;">
                                        <button type="button" onclick="app.adjustImageTransparency(1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                        <button type="button" onclick="app.adjustImageTransparency(-1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Shape</label>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.applyImageShape('none')" title="Rectangle" style="${data.shape === 'none' || !data.shape ? 'background: rgba(16, 185, 129, 0.2); border-color: rgba(16, 185, 129, 0.5);' : ''}"></button>
                                <button class="properties-arrange-btn" onclick="app.applyImageShape('circle')" title="Circle" style="${data.shape === 'circle' ? 'background: rgba(16, 185, 129, 0.2); border-color: rgba(16, 185, 129, 0.5);' : ''}"></button>
                                <button class="properties-arrange-btn" onclick="app.applyImageShape('rounded')" title="Rounded" style="${data.shape === 'rounded' ? 'background: rgba(16, 185, 129, 0.2); border-color: rgba(16, 185, 129, 0.5);' : ''}"></button>
                                <button class="properties-arrange-btn" onclick="app.applyImageShape('triangle')" title="Triangle" style="${data.shape === 'triangle' ? 'background: rgba(16, 185, 129, 0.2); border-color: rgba(16, 185, 129, 0.5);' : ''}"></button>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Adjust Image</label>
                            <button class="properties-arrange-btn" onclick="app.showAdjustImageModal()" style="width: 100%;">Adjust Image</button>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Arrange</label>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('left')" title="Align Left"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('center')" title="Align Center"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('right')" title="Align Right"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('top')" title="Align Top"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('middle')" title="Align Middle"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('bottom')" title="Align Bottom"></button>
                            </div>
                        </div>
                    `;
                } else if (data.type === 'chart') {
                    // Convert old data format to new format if needed
                    if (data.data && data.data.datasets && !data.labels) {
                        const oldData = data.data;
                        data.labels = oldData.labels || [];
                        if (oldData.datasets && oldData.datasets[0]) {
                            data.values = oldData.datasets[0].data || [];
                            if (data.chartType === 'line') {
                                data.colors = [oldData.datasets[0].borderColor || '#10b981'];
                            } else {
                                data.colors = oldData.datasets[0].backgroundColor || [];
                            }
                        }
                        delete data.data;
                        this.saveState();
                    }
                    
                    // Ensure data exists, if not use defaults
                    if (!data.labels || data.labels.length === 0) {
                        const defaultData = this.getDefaultChartData(data.chartType || 'bar');
                        data.labels = defaultData.labels || [];
                        data.values = defaultData.values || [];
                        data.colors = defaultData.colors || [];
                        this.saveState();
                    }
                    
                    const labels = data.labels || [];
                    const values = data.values || [];
                    const colors = data.colors || [];
                    const maxLength = Math.max(labels.length, values.length, colors.length, 1);
                    
                    let chartItemsHtml = '';
                    for (let i = 0; i < maxLength; i++) {
                        const labelValue = labels[i] !== undefined ? labels[i] : '';
                        const valueValue = values[i] !== undefined ? values[i] : 0;
                        const colorValue = colors[i] !== undefined ? colors[i] : '#10b981';
                        
                        chartItemsHtml += `
                            <div style="display: grid; grid-template-columns: 1fr 80px 50px 30px; gap: 6px; align-items: center; padding: 6px; background: ${i % 2 === 0 ? '#f9fafb' : 'white'}; border-radius: 4px; margin-bottom: 4px;">
                                <input type="text" class="properties-input" value="${labelValue}" placeholder="Label" onchange="app.updateChartData('${data.id}', 'label', ${i}, this.value)" style="font-size: 11px; padding: 4px 6px;">
                                <input type="number" class="properties-input" value="${valueValue}" placeholder="Value" onchange="app.updateChartData('${data.id}', 'value', ${i}, this.value)" style="font-size: 11px; padding: 4px 6px;">
                                <input type="color" class="properties-color-input" value="${colorValue}" onchange="app.updateChartData('${data.id}', 'color', ${i}, this.value)" style="width: 100%; height: 28px; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer;">
                                <button onclick="app.removeChartItem('${data.id}', ${i})" style="width: 24px; height: 24px; border: 1px solid #ef4444; background: white; color: #ef4444; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; padding: 0;"></button>
                            </div>
                        `;
                    }
                    
                    html = `
                        <div class="properties-group">
                            <label class="properties-label">Chart Type</label>
                            <select class="properties-input" onchange="app.updateChartType('${data.id}', this.value)">
                                <option value="bar" ${data.chartType === 'bar' ? 'selected' : ''}>Bar Chart</option>
                                <option value="line" ${data.chartType === 'line' ? 'selected' : ''}>Line Chart</option>
                                <option value="pie" ${data.chartType === 'pie' ? 'selected' : ''}>Pie Chart</option>
                                <option value="flow" ${data.chartType === 'flow' ? 'selected' : ''}>Flow Chart</option>
                            </select>
                        </div>
                        <div class="properties-group">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <label class="properties-label" style="margin: 0;">Chart Data</label>
                                <button onclick="app.addChartItem('${data.id}')" style="padding: 4px 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;">+ Add</button>
                            </div>
                            <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 6px; padding: 8px; background: white;">
                                ${maxLength > 0 ? chartItemsHtml : '<div style="text-align: center; color: #9ca3af; padding: 20px; font-size: 12px;">No data. Click "+ Add" to add items.</div>'}
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Arrange</label>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('left')" title="Align Left"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('center')" title="Align Center"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('right')" title="Align Right"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('top')" title="Align Top"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('middle')" title="Align Middle"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('bottom')" title="Align Bottom"></button>
                            </div>
                        </div>
                    `;
                } else if (data.type === 'table') {
                    html = `
                        <div class="properties-group">
                            <label class="properties-label">Table Size</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <input type="number" class="properties-input" min="1" max="10" value="${data.rows || 3}" onchange="app.updateTableSize('${data.id}', 'rows', parseInt(this.value))" placeholder="Rows">
                                <input type="number" class="properties-input" min="1" max="10" value="${data.cols || 3}" onchange="app.updateTableSize('${data.id}', 'cols', parseInt(this.value))" placeholder="Cols">
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Arrange</label>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('left')" title="Align Left"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('center')" title="Align Center"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('right')" title="Align Right"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('top')" title="Align Top"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('middle')" title="Align Middle"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('bottom')" title="Align Bottom"></button>
                            </div>
                        </div>
                    `;
                } else if (data.type === 'symbol') {
                    html = `
                        <div class="properties-group">
                            <label class="properties-label">Symbol</label>
                            <div style="font-size: 48px; text-align: center; padding: 20px; background: #f9fafb; border-radius: 8px; border: 1px solid #e5e7eb;">
                                ${data.symbol || ''}
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Color</label>
                            <input type="color" class="properties-color-input" value="${data.color || '#000000'}" onchange="app.updateSymbolProperty('${data.id}', 'color', this.value)">
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Size</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="number" class="properties-input" min="12" max="200" value="${data.fontSize || 48}" onchange="app.updateSymbolProperty('${data.id}', 'fontSize', parseInt(this.value))" style="flex: 1;">
                                <div style="display: flex; flex-direction: column; gap: 2px;">
                                    <button type="button" onclick="app.adjustProperty('propSymbolSize', 1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-radius: 4px 4px 0 0; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                    <button type="button" onclick="app.adjustProperty('propSymbolSize', -1)" style="width: 20px; height: 14px; border: 1px solid #d1d5db; border-top: none; border-radius: 0 0 4px 4px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 8px; color: #374151;"></button>
                                </div>
                            </div>
                        </div>
                        <div class="properties-group">
                            <label class="properties-label">Arrange</label>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('left')" title="Align Left"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('center')" title="Align Center"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('right')" title="Align Right"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('top')" title="Align Top"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('middle')" title="Align Middle"></button>
                                <button class="properties-arrange-btn" onclick="app.arrangeElement('bottom')" title="Align Bottom"></button>
                            </div>
                        </div>
                    `;
                }

                content.innerHTML = html;
                } catch (error) {
                    console.error('Error rendering properties panel:', error);
                    // Fallback: show empty state
                    if (panel) {
                        panel.classList.remove('visible');
                        panel.classList.remove('category-panel-open');
                    }
                    if (content) {
                        content.innerHTML = `
                            <div class="properties-empty">
                                <div class="properties-empty-title">Error</div>
                                <div class="properties-empty-text">Failed to load properties</div>
                            </div>
                        `;
                    }
                }
            },

            updateShapeProperty(prop, value) {
                if (!this.sel) return;
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'shape') return;

                data[prop] = value;
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${data.id}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            updateTextProperty(prop, value) {
                if (!this.sel) return;
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'text') return;

                // Preserve content when updating properties
                if (prop === 'size' || prop === 'width' || prop === 'height') {
                    const currentContent = this.sel.innerText || this.sel.textContent || data.content || '';
                    data.content = currentContent;
                }

                data[prop] = value;
                
                // Apply border changes immediately
                if (prop === 'borderColor' || prop === 'borderWidth') {
                    if (data.borderWidth && data.borderWidth > 0) {
                        this.sel.style.border = `${data.borderWidth}px solid ${data.borderColor || '#000000'}`;
                    } else {
                        this.sel.style.border = 'none';
                    }
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${data.id}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            adjustProperty(inputId, delta) {
                const input = document.getElementById(inputId);
                if (!input) return;
                
                const min = parseInt(input.min) || 0;
                const max = parseInt(input.max) || 200;
                let currentValue = parseInt(input.value) || 0;
                currentValue = Math.max(min, Math.min(max, currentValue + delta));
                input.value = currentValue;
                
                // Trigger change event
                input.dispatchEvent(new Event('change'));
            },

            arrangeElement(position) {
                if (!this.sel) return;
                
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data) return;
                
                const slideWidth = 960;
                const slideHeight = 540;
                const elementWidth = parseInt(this.sel.style.width) || data.width || 200;
                const elementHeight = parseInt(this.sel.style.height) || data.height || 100;
                
                let newX = data.x;
                let newY = data.y;
                
                switch(position) {
                    case 'left':
                        newX = 0;
                        break;
                    case 'center':
                        newX = (slideWidth - elementWidth) / 2;
                        break;
                    case 'right':
                        newX = slideWidth - elementWidth;
                        break;
                    case 'top':
                        newY = 0;
                        break;
                    case 'middle':
                        newY = (slideHeight - elementHeight) / 2;
                        break;
                    case 'bottom':
                        newY = slideHeight - elementHeight;
                        break;
                }
                
                // Update position
                data.x = Math.max(0, Math.min(slideWidth - elementWidth, newX));
                data.y = Math.max(0, Math.min(slideHeight - elementHeight, newY));
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${data.id}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            showContextMenu(x, y) {
                const contextMenu = document.getElementById('contextMenu');
                if (!contextMenu) return;
                
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.classList.add('show');
                
                // Hide menu when clicking elsewhere
                const hideMenu = (e) => {
                    if (!contextMenu.contains(e.target)) {
                        contextMenu.classList.remove('show');
                        document.removeEventListener('click', hideMenu);
                        document.removeEventListener('contextmenu', hideMenu);
                    }
                };
                
                // Use setTimeout to avoid immediate hide
                setTimeout(() => {
                    document.addEventListener('click', hideMenu);
                    document.addEventListener('contextmenu', hideMenu);
                }, 10);
            },

            hideContextMenu() {
                const contextMenu = document.getElementById('contextMenu');
                if (contextMenu) {
                    contextMenu.classList.remove('show');
                }
            },

            updateImageProperty(prop, value) {
                if (!this.sel) return;
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') return;

                data[prop] = value;
                
                // Apply border changes immediately
                if (prop === 'borderColor' || prop === 'borderWidth') {
                    if (data.borderWidth && data.borderWidth > 0) {
                        this.sel.style.border = `${data.borderWidth}px solid ${data.borderColor || '#000000'}`;
                    } else {
                        this.sel.style.border = 'none';
                    }
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${data.id}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            updateImageTransparency(value) {
                if (!this.sel) return;
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') return;
                
                const transparency = parseInt(value) || 0;
                data.transparency = transparency;
                
                // Update slider and input
                const slider = document.getElementById('imgTransparencySlider');
                const input = document.getElementById('imgTransparencyInput');
                if (slider) slider.value = transparency;
                if (input) input.value = transparency;
                
                // Apply transparency to image
                const opacity = (100 - transparency) / 100;
                if (this.sel) {
                    const img = this.sel.querySelector('img');
                    if (img) img.style.opacity = opacity;
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
            },

            adjustImageTransparency(delta) {
                const input = document.getElementById('imgTransparencyInput');
                if (!input) return;
                
                let currentValue = parseInt(input.value) || 0;
                currentValue = Math.max(0, Math.min(100, currentValue + delta));
                
                this.updateImageTransparency(currentValue);
            },

            applyImageShape(shape) {
                if (!this.sel) return;
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') return;
                
                data.shape = shape;
                
                // Apply shape styling
                if (this.sel) {
                    const img = this.sel.querySelector('img');
                    if (img) {
                        switch(shape) {
                            case 'circle':
                                img.style.borderRadius = '50%';
                                img.style.clipPath = 'none';
                                break;
                            case 'rounded':
                                img.style.borderRadius = '20px';
                                img.style.clipPath = 'none';
                                break;
                            case 'triangle':
                                img.style.borderRadius = '0';
                                img.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                                break;
                            case 'none':
                            default:
                                img.style.borderRadius = '0';
                                img.style.clipPath = 'none';
                                break;
                        }
                    }
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${data.id}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            cropImage() {
                if (!this.sel) {
                    this.showNotification('Select an image first', 'warning');
                    return;
                }
                
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') {
                    this.showNotification('Selected element is not an image', 'warning');
                    return;
                }
                
                // Show crop modal
                const modal = document.getElementById('cropModal');
                if (modal) {
                    modal.classList.add('show');
                    // Load image into crop area
                    const cropImg = document.getElementById('cropImagePreview');
                    if (cropImg) {
                        cropImg.src = data.src;
                    }
                } else {
                    this.showNotification('Crop feature coming soon! Use image editing software to crop images before uploading.', 'info');
                }
            },

            applyCrop() {
                // For now, just close the modal
                // Full crop functionality would require canvas-based cropping
                this.closeModal('cropModal');
                this.showNotification('Crop feature coming soon! Use image editing software to crop images before uploading.', 'info');
            },

            showAdjustImageModal() {
                if (!this.sel) {
                    this.showNotification('Select an image first', 'warning');
                    return;
                }
                
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') {
                    this.showNotification('Selected element is not an image', 'warning');
                    return;
                }
                
                const modal = document.getElementById('adjustImageModal');
                if (modal) {
                    modal.classList.add('show');
                    // Load image into preview
                    const previewImg = document.getElementById('adjustImagePreview');
                    if (previewImg) {
                        previewImg.src = data.src;
                    }
                    
                    // Reset all sliders to current values or 0
                    const filters = data.filters || {};
                    document.getElementById('sharpenSlider').value = filters.sharpen || 0;
                    document.getElementById('sharpenInput').value = filters.sharpen || 0;
                    document.getElementById('brightnessSlider').value = filters.brightness || 0;
                    document.getElementById('brightnessInput').value = filters.brightness || 0;
                    document.getElementById('contrastSlider').value = filters.contrast || 0;
                    document.getElementById('contrastInput').value = filters.contrast || 0;
                    document.getElementById('saturationSlider').value = filters.saturation || 0;
                    document.getElementById('saturationInput').value = filters.saturation || 0;
                    document.getElementById('toneSlider').value = filters.tone || 0;
                    document.getElementById('toneInput').value = filters.tone || 0;
                    document.getElementById('recolorSelect').value = filters.recolor || 'none';
                    
                    // Apply current filters to preview
                    this.tempFilters = { ...filters };
                    this.updateImagePreviewFilters();
                }
            },

            updateImageFilter(type, value) {
                // Update input field
                const input = document.getElementById(type + 'Input');
                if (input) input.value = value;
                
                // Update slider
                const slider = document.getElementById(type + 'Slider');
                if (slider) slider.value = value;
                
                // Store filter value temporarily
                if (!this.tempFilters) this.tempFilters = {};
                this.tempFilters[type] = parseInt(value);
                
                // Apply to preview
                this.updateImagePreviewFilters();
            },

            updateImagePreviewFilters() {
                const previewImg = document.getElementById('adjustImagePreview');
                if (!previewImg) return;
                
                const filters = this.tempFilters || {};
                let filterString = '';
                
                // Brightness
                if (filters.brightness) {
                    filterString += `brightness(${100 + filters.brightness}%) `;
                }
                
                // Contrast
                if (filters.contrast) {
                    filterString += `contrast(${100 + filters.contrast}%) `;
                }
                
                // Saturation
                if (filters.saturation) {
                    filterString += `saturate(${100 + filters.saturation}%) `;
                }
                
                // Sharpen/Blur (using blur inversely)
                if (filters.sharpen) {
                    const blurValue = Math.abs(filters.sharpen) / 10;
                    if (filters.sharpen < 0) {
                        filterString += `blur(${blurValue}px) `;
                    }
                }
                
                // Recolor
                if (filters.recolor) {
                    switch(filters.recolor) {
                        case 'sepia':
                            filterString += 'sepia(100%) ';
                            break;
                        case 'grayscale':
                            filterString += 'grayscale(100%) ';
                            break;
                        case 'invert':
                            filterString += 'invert(100%) ';
                            break;
                        case 'warm':
                            filterString += 'sepia(50%) saturate(150%) ';
                            break;
                        case 'cool':
                            filterString += 'sepia(20%) saturate(80%) hue-rotate(180deg) ';
                            break;
                    }
                }
                
                previewImg.style.filter = filterString.trim() || 'none';
            },

            applyArtisticEffect(effect) {
                if (!this.tempFilters) this.tempFilters = {};
                
                // Reset other filters when applying artistic effect
                if (effect !== 'none') {
                    this.tempFilters.artistic = effect;
                    // Apply effect-specific filters
                    switch(effect) {
                        case 'blur':
                            this.tempFilters.sharpen = -30;
                            break;
                        case 'fog':
                            this.tempFilters.sharpen = -20;
                            this.tempFilters.brightness = 10;
                            this.tempFilters.contrast = -10;
                            break;
                        case 'paper':
                            this.tempFilters.contrast = -20;
                            this.tempFilters.saturation = -30;
                            break;
                        case 'vintage':
                            this.tempFilters.recolor = 'sepia';
                            this.tempFilters.contrast = 10;
                            break;
                        case 'pencil':
                            this.tempFilters.recolor = 'grayscale';
                            this.tempFilters.contrast = 30;
                            break;
                        case 'watercolor':
                            this.tempFilters.saturation = 20;
                            this.tempFilters.contrast = -15;
                            break;
                        case 'oil':
                            this.tempFilters.saturation = 30;
                            this.tempFilters.contrast = 20;
                            break;
                    }
                } else {
                    delete this.tempFilters.artistic;
                }
                
                // Update all inputs
                if (this.tempFilters.sharpen !== undefined) {
                    document.getElementById('sharpenSlider').value = this.tempFilters.sharpen;
                    document.getElementById('sharpenInput').value = this.tempFilters.sharpen;
                }
                if (this.tempFilters.brightness !== undefined) {
                    document.getElementById('brightnessSlider').value = this.tempFilters.brightness;
                    document.getElementById('brightnessInput').value = this.tempFilters.brightness;
                }
                if (this.tempFilters.contrast !== undefined) {
                    document.getElementById('contrastSlider').value = this.tempFilters.contrast;
                    document.getElementById('contrastInput').value = this.tempFilters.contrast;
                }
                if (this.tempFilters.saturation !== undefined) {
                    document.getElementById('saturationSlider').value = this.tempFilters.saturation;
                    document.getElementById('saturationInput').value = this.tempFilters.saturation;
                }
                if (this.tempFilters.recolor) {
                    document.getElementById('recolorSelect').value = this.tempFilters.recolor;
                }
                
                this.updateImagePreviewFilters();
            },

            applyImageFilters() {
                if (!this.sel) return;
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') return;
                
                // Save filters to data
                data.filters = { ...this.tempFilters };
                
                // Apply filters to actual image
                const img = this.sel.querySelector('img');
                if (img) {
                    this.applyFiltersToImage(img, data.filters);
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                this.closeModal('adjustImageModal');
                this.tempFilters = null;
            },

            applyFiltersToImage(img, filters) {
                if (!filters) return;
                
                let filterString = '';
                
                if (filters.brightness) {
                    filterString += `brightness(${100 + filters.brightness}%) `;
                }
                if (filters.contrast) {
                    filterString += `contrast(${100 + filters.contrast}%) `;
                }
                if (filters.saturation) {
                    filterString += `saturate(${100 + filters.saturation}%) `;
                }
                if (filters.sharpen) {
                    const blurValue = Math.abs(filters.sharpen) / 10;
                    if (filters.sharpen < 0) {
                        filterString += `blur(${blurValue}px) `;
                    }
                }
                if (filters.recolor) {
                    switch(filters.recolor) {
                        case 'sepia':
                            filterString += 'sepia(100%) ';
                            break;
                        case 'grayscale':
                            filterString += 'grayscale(100%) ';
                            break;
                        case 'invert':
                            filterString += 'invert(100%) ';
                            break;
                        case 'warm':
                            filterString += 'sepia(50%) saturate(150%) ';
                            break;
                        case 'cool':
                            filterString += 'sepia(20%) saturate(80%) hue-rotate(180deg) ';
                            break;
                    }
                }
                
                img.style.filter = filterString.trim() || 'none';
            },

            resetImageFilters() {
                // Reset all sliders
                document.getElementById('sharpenSlider').value = 0;
                document.getElementById('sharpenInput').value = 0;
                document.getElementById('brightnessSlider').value = 0;
                document.getElementById('brightnessInput').value = 0;
                document.getElementById('contrastSlider').value = 0;
                document.getElementById('contrastInput').value = 0;
                document.getElementById('saturationSlider').value = 0;
                document.getElementById('saturationInput').value = 0;
                document.getElementById('toneSlider').value = 0;
                document.getElementById('toneInput').value = 0;
                document.getElementById('recolorSelect').value = 'none';
                
                // Reset temp filters
                this.tempFilters = {};
                
                // Reset preview
                const previewImg = document.getElementById('adjustImagePreview');
                if (previewImg) {
                    previewImg.style.filter = 'none';
                }
            },

            addText() {
                // Ensure els array exists
                if (!this.data[this.curr].els) {
                    this.data[this.curr].els = [];
                }
                
                const id = Date.now();
                const el = {
                    id: id,
                    type: 'text',
                    content: 'Double-click to edit',
                    x: 100,
                    y: 100,
                    width: 300,
                    height: 50,
                    font: 'Arial',
                    size: 24,
                    color: '#000000',
                    bg: 'transparent',
                    weight: 'normal',
                    align: 'left',
                    animation: 'none'
                };
                this.data[this.curr].els.push(el);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Auto-select the new element
                setTimeout(() => {
                    const elementEl = document.querySelector(`[data-id="${id}"]`);
                    if (elementEl) this.selectElement(elementEl);
                }, 100);
            },

            addShape(shape) {
                // Ensure els array exists
                if (!this.data[this.curr].els) {
                    this.data[this.curr].els = [];
                }
                
                const id = Date.now();
                const el = {
                    id: id,
                    type: 'shape',
                    shape: shape,
                    x: 200,
                    y: 150,
                    width: 200,
                    height: 150,
                    bg: '#10b981',
                    border: '#047857',
                    thick: 2,
                    animation: 'none'
                };
                this.data[this.curr].els.push(el);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Auto-select the new element
                setTimeout(() => {
                    const elementEl = document.querySelector(`[data-id="${id}"]`);
                    if (elementEl) this.selectElement(elementEl);
                }, 100);
            },

            toggleShapesMenu() {
                // Deprecated - using category system now
            },

            addImage() {
                // Ensure els array exists
                if (!this.data[this.curr].els) {
                    this.data[this.curr].els = [];
                }
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            const id = Date.now();
                            
                            // Smart positioning: Check existing elements
                            const existingElements = this.data[this.curr].els || [];
                            const hasChart = existingElements.some(el => el.type === 'chart');
                            const hasImage = existingElements.some(el => el.type === 'image');
                            
                            // Professional layout: Image on LEFT, Chart on RIGHT
                            let x, y, width, height;
                            if (hasChart) {
                                // Chart exists, place image on LEFT
                                x = 30;
                                y = 100;
                                width = 320;
                                height = 340;
                            } else {
                                // No chart, place image on RIGHT
                                x = 580;
                                y = 100;
                                width = 340;
                                height = 340;
                            }
                            
                            const el = {
                                id: id,
                                type: 'image',
                                src: ev.target.result,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                animation: 'none'
                            };
                            this.data[this.curr].els.push(el);
                            this.saveState();
                            this.loadCanvas();
                            this.renderSlides();
                            
                            // Auto-select the new element
                            setTimeout(() => {
                                const elementEl = document.querySelector(`[data-id="${id}"]`);
                                if (elementEl) this.selectElement(elementEl);
                            }, 100);
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            },

            createEl(data, slideIndex) {
                const div = document.createElement('div');
                div.className = 'element ' + data.type + '-element';
                div.dataset.id = data.id;
                div.dataset.slideIndex = slideIndex;
                div.style.left = data.x + 'px';
                div.style.top = data.y + 'px';
                div.style.width = data.width + 'px';
                div.style.height = data.height + 'px';
                
                // Mark locked elements
                if (data.locked) {
                    div.dataset.locked = 'true';
                    div.style.pointerEvents = 'none';
                    div.style.userSelect = 'none';
                }

                if (data.shadow) {
                    div.style.boxShadow = data.shadow;
                }

                if (data.type === 'text') {
                    div.contentEditable = true;
                    div.innerText = data.content || '';
                    let fontFamily = data.font || 'Arial';
                    if (fontFamily === 'Kraft Mono') {
                        fontFamily = "'Kraft Mono', 'JetBrains Mono', monospace";
                    } else if (fontFamily === 'ID Grotesk') {
                        fontFamily = "'ID Grotesk', 'Work Sans', sans-serif";
                    }
                    div.style.fontFamily = fontFamily;
                    div.style.fontSize = (data.size || 24) + 'px';
                    div.style.color = data.color || '#000000';
                    div.style.backgroundColor = data.bg || 'transparent';
                    div.style.fontWeight = data.weight || 'normal';
                    div.style.textAlign = data.align || 'left';
                    div.style.padding = '8px';
                    div.style.whiteSpace = 'pre-wrap';
                    div.style.wordWrap = 'break-word';
                    div.style.overflowWrap = 'break-word';
                    
                    // Apply fontStyle and textDecoration if they exist
                    if (data.fontStyle) {
                        div.style.fontStyle = data.fontStyle;
                    }
                    if (data.textDecoration) {
                        div.style.textDecoration = data.textDecoration;
                    }
                    
                    // Apply border if exists
                    if (data.borderWidth && data.borderWidth > 0) {
                        div.style.border = `${data.borderWidth}px solid ${data.borderColor || '#000000'}`;
                    } else {
                        div.style.border = 'none';
                    }
                    
                    div.addEventListener('blur', () => {
                        const el = this.data[slideIndex].els.find(e => e.id == data.id);
                        if (el) {
                            el.content = div.innerText;
                            this.saveState();
                            this.renderSlides();
                        }
                    });

                    div.addEventListener('focus', () => {
                        // Switch to this slide when editing
                        if (this.curr !== slideIndex) {
                            this.switchSlide(slideIndex);
                        }
                    });
                }

                if (data.type === 'shape') {
                    const fillColor = data.bg || '#10b981';
                    const borderColor = data.border || '#047857';
                    const borderWidth = data.thick || 2;
                    
                    // Use SVG for complex shapes that need proper borders
                    const needsSVG = ['triangle', 'star', 'hexagon', 'diamond', 'arrow-right', 'arrow-left', 'pentagon'].includes(data.shape);
                    
                    if (needsSVG) {
                            div.style.backgroundColor = 'transparent';
                            div.style.border = 'none';
                        div.style.overflow = 'visible';
                        
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('viewBox', '0 0 100 100');
                        svg.style.position = 'absolute';
                        svg.style.top = '0';
                        svg.style.left = '0';
                        svg.style.pointerEvents = 'none';
                        
                        const shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let pathData = '';
                        
                        switch(data.shape) {
                            case 'triangle':
                                pathData = 'M 50,10 L 90,90 L 10,90 Z';
                            break;
                        case 'star':
                                pathData = 'M 50,5 L 61,35 L 98,35 L 68,57 L 79,91 L 50,70 L 21,91 L 32,57 L 2,35 L 39,35 Z';
                            break;
                        case 'hexagon':
                                pathData = 'M 50,5 L 85,25 L 85,75 L 50,95 L 15,75 L 15,25 Z';
                            break;
                        case 'diamond':
                                pathData = 'M 50,5 L 95,50 L 50,95 L 5,50 Z';
                            break;
                        case 'arrow-right':
                                pathData = 'M 5,25 L 60,25 L 60,5 L 95,50 L 60,95 L 60,75 L 5,75 Z';
                            break;
                        case 'arrow-left':
                                pathData = 'M 95,25 L 40,25 L 40,5 L 5,50 L 40,95 L 40,75 L 95,75 Z';
                                break;
                            case 'pentagon':
                                pathData = 'M 50,5 L 95,38 L 82,95 L 18,95 L 5,38 Z';
                                break;
                        }
                        
                        shape.setAttribute('d', pathData);
                        shape.setAttribute('fill', fillColor);
                        shape.setAttribute('stroke', borderColor);
                        // Calculate stroke width relative to viewBox (100x100)
                        // borderWidth is in pixels, convert to viewBox units
                        const avgSize = (data.width + data.height) / 2;
                        const strokeWidthInViewBox = (borderWidth / avgSize) * 100;
                        shape.setAttribute('stroke-width', Math.max(0.5, strokeWidthInViewBox).toString());
                        shape.setAttribute('stroke-linejoin', 'round');
                        shape.setAttribute('stroke-linecap', 'round');
                        
                        svg.appendChild(shape);
                        div.appendChild(svg);
                    } else {
                        // Simple shapes with CSS
                        div.style.backgroundColor = fillColor;
                        div.style.border = `${borderWidth}px solid ${borderColor}`;
                        
                        switch(data.shape) {
                            case 'circle':
                                div.style.borderRadius = '50%';
                                break;
                            case 'rectangle':
                                div.style.borderRadius = '4px';
                            break;
                        default:
                            div.style.borderRadius = '4px';
                        }
                    }
                }

                if (data.type === 'image') {
                    const img = document.createElement('img');
                    // Remove crossOrigin for Unsplash - it may cause CORS issues
                    // img.crossOrigin = 'anonymous';
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.imageRendering = 'high-quality';
                    img.style.display = 'block';
                    img.style.opacity = '0';
                    img.style.transition = 'opacity 0.3s ease-in-out';
                    img.loading = 'eager';
                    img.decoding = 'async';
                    
                    // Fix CORS for Azure Blob Storage URLs (DALL-E images)
                    let imageSrc = data.src;
                    if (imageSrc && imageSrc.includes('oaidalleapiprodscus.blob.core.windows.net')) {
                        // Use CORS proxy for Azure Blob Storage URLs
                        // Try multiple proxies for better reliability
                        if (imageSrc.includes('api.allorigins.win') || imageSrc.includes('corsproxy.io')) {
                            // Already using a proxy, use it directly
                            img.src = imageSrc;
                        } else {
                            // Use primary CORS proxy
                            try {
                                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageSrc)}`;
                                img.src = proxyUrl;
                                console.log(` Using CORS proxy for DALL-E image`);
                            } catch (e) {
                                // Fallback to alternative proxy
                                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(imageSrc)}`;
                                img.src = proxyUrl;
                                console.log(` Using alternative CORS proxy for DALL-E image`);
                            }
                        }
                    } else {
                        img.src = imageSrc;
                    }
                    
                    // Handle image loading - ensure it loads properly
                    img.onload = function() {
                        console.log(` Image loaded successfully: ${this.src.substring(0, 80)}...`);
                        this.style.opacity = '1';
                        this.style.backgroundColor = 'transparent';
                    };
                    
                    // Handle image loading errors with multiple fallback strategies
                    let retryCount = 0;
                    const maxRetries = 3;
                    
                    img.onerror = function() {
                        retryCount++;
                        console.warn(` Image failed to load (attempt ${retryCount}/${maxRetries}): ${this.src.substring(0, 80)}...`);
                        
                        // If it's a DALL-E image and failed, try CORS proxy
                        if (retryCount === 1 && data.src && data.src.includes('oaidalleapiprodscus.blob.core.windows.net')) {
                            // Try primary CORS proxy
                            try {
                                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(data.src)}`;
                                this.src = proxyUrl;
                                console.log(` Retrying DALL-E image with CORS proxy...`);
                                return;
                            } catch (e) {
                                // Try alternative proxy
                                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(data.src)}`;
                                this.src = proxyUrl;
                                console.log(` Retrying DALL-E image with alternative CORS proxy...`);
                                return;
                            }
                        }
                        
                        if (retryCount >= maxRetries) {
                            // Final fallback - use Picsum as reliable alternative
                            console.log(` Using Picsum as final fallback...`);
                            const picsumId = Math.floor(Math.random() * 1000);
                            this.onerror = null; // Remove error handler to prevent loop
                            this.src = `https://picsum.photos/960/540?random=${picsumId}`;
                            this.onload = function() {
                                console.log(` Picsum image loaded successfully`);
                                this.style.opacity = '1';
                            };
                            this.onerror = function() {
                                // Last resort - show gradient placeholder
                                console.warn(` All image sources failed. Showing gradient placeholder.`);
                                this.style.display = 'flex';
                                this.style.alignItems = 'center';
                                this.style.justifyContent = 'center';
                                this.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                                this.style.opacity = '1';
                                this.alt = 'Image placeholder';
                            };
                            return;
                        }
                        
                        // Try Picsum Photos as fallback (more reliable)
                        const originalSrc = this.src;
                        const picsumId = Math.floor(Math.random() * 1000) + 1;
                        const fallbackUrl = `https://picsum.photos/960/540?random=${picsumId}`;
                        this.onerror = null; // Remove to allow retry
                        setTimeout(() => {
                            this.src = fallbackUrl;
                        }, 100);
                    };
                    
                    // Set src AFTER setting up handlers
                    if (data.src && data.src.trim()) {
                        // Replace any Unsplash Source URLs with Picsum Photos (more reliable)
                        let imageSrc = data.src;
                        if (imageSrc.includes('source.unsplash.com')) {
                            console.log(` Replacing Unsplash Source URL with Picsum: ${imageSrc.substring(0, 80)}...`);
                            // Extract keyword from URL if possible, otherwise use random
                            const keywordMatch = imageSrc.match(/[?&]([^&]+)(?:&|$)/);
                            const keyword = keywordMatch ? keywordMatch[1] : 'business';
                            const keywordHash = keyword.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                            const picsumId = 1 + (keywordHash % 1000);
                            imageSrc = `https://picsum.photos/960/540?random=${picsumId}`;
                            console.log(` Replaced with Picsum: ${imageSrc}`);
                        }
                        img.src = imageSrc;
                    } else {
                        // No src provided, use Picsum Photos (more reliable)
                        const picsumId = Math.floor(Math.random() * 1000) + 1;
                        img.src = `https://picsum.photos/960/540?random=${picsumId}`;
                    }
                    
                    // Apply transparency
                    if (data.transparency !== undefined) {
                        const opacity = (100 - data.transparency) / 100;
                        img.style.opacity = opacity;
                    }
                    
                    // Apply filters
                    if (data.filters) {
                        this.applyFiltersToImage(img, data.filters);
                    }
                    
                    // Apply shape
                    if (data.shape) {
                        switch(data.shape) {
                            case 'circle':
                                img.style.borderRadius = '50%';
                                img.style.clipPath = 'none';
                                break;
                            case 'rounded':
                                img.style.borderRadius = '20px';
                                img.style.clipPath = 'none';
                                break;
                            case 'triangle':
                                img.style.borderRadius = '0';
                                img.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                                break;
                            case 'none':
                            default:
                                img.style.borderRadius = '0';
                                img.style.clipPath = 'none';
                                break;
                        }
                    }
                    
                    // Apply border
                    if (data.borderWidth && data.borderWidth > 0) {
                        div.style.border = `${data.borderWidth}px solid ${data.borderColor || '#000000'}`;
                    } else {
                        div.style.border = 'none';
                    }
                    
                    div.appendChild(img);
                }

                if (data.type === 'chart') {
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                    div.style.backgroundColor = '#ffffff';
                    div.style.border = '2px solid #e5e7eb';
                    div.style.borderRadius = '8px';
                    div.style.padding = '0';
                    div.style.overflow = 'visible';
                    
                    const chartCanvas = document.createElement('canvas');
                    const canvasWidth = Math.max(200, data.width || 400);
                    const canvasHeight = Math.max(200, data.height || 300);
                    chartCanvas.width = canvasWidth;
                    chartCanvas.height = canvasHeight;
                    chartCanvas.style.width = canvasWidth + 'px';
                    chartCanvas.style.height = canvasHeight + 'px';
                    chartCanvas.style.display = 'block';
                    chartCanvas.style.maxWidth = '100%';
                    chartCanvas.style.maxHeight = '100%';
                    
                    // Draw chart after a small delay to ensure canvas is ready
                    setTimeout(() => {
                        const ctx = chartCanvas.getContext('2d');
                        if (ctx) {
                            // Ensure data exists
                            if (!data.labels || data.labels.length === 0) {
                                const defaultData = this.getDefaultChartData(data.chartType || 'bar');
                                data.labels = defaultData.labels || [];
                                data.values = defaultData.values || [];
                                data.colors = defaultData.colors || [];
                            }
                            this.drawChart(ctx, data.chartType || 'bar', data, canvasWidth, canvasHeight);
                        }
                    }, 10);
                    
                    div.appendChild(chartCanvas);
                }

                if (data.type === 'table') {
                    div.style.backgroundColor = 'white';
                    div.style.border = '1px solid #e5e7eb';
                    div.style.borderRadius = '4px';
                    div.style.overflow = 'hidden';
                    
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.height = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.fontSize = '12px';
                    
                    for (let r = 0; r < data.rows; r++) {
                        const tr = document.createElement('tr');
                        for (let c = 0; c < data.cols; c++) {
                            const td = document.createElement(r === 0 ? 'th' : 'td');
                            td.textContent = data.data[r] ? data.data[r][c] : '';
                            td.style.border = '1px solid #e5e7eb';
                            td.style.padding = '8px';
                            td.style.textAlign = 'left';
                            if (r === 0) {
                                td.style.backgroundColor = '#f3f4f6';
                                td.style.fontWeight = '600';
                            }
                            tr.appendChild(td);
                        }
                        table.appendChild(tr);
                    }
                    div.appendChild(table);
                }

                if (data.type === 'symbol') {
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                    div.style.fontSize = (data.fontSize || 48) + 'px';
                    div.style.color = data.color || '#000000';
                    div.style.backgroundColor = 'transparent';
                    div.textContent = data.symbol || '';
                    div.style.userSelect = 'none';
                }

                // Only show resize handles on active slide
                if (slideIndex === this.curr) {
                    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
                        const handle = document.createElement('div');
                        handle.className = 'resize-handle ' + pos;
                        div.appendChild(handle);
                    });
                }

                // Add context menu on right click
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Select element if not already selected
                    if (slideIndex === this.curr) {
                        this.selectElement(div);
                        this.showContextMenu(e.clientX, e.clientY);
                    }
                });

                return div;
            },

            loadCanvas() {
                const wrapper = document.getElementById('canvasWrapper');
                wrapper.innerHTML = '';
                
                // Clean up old Unsplash Source URLs in stored data
                this.data.forEach((slide) => {
                    if (slide.els && Array.isArray(slide.els)) {
                        slide.els.forEach((el) => {
                            if (el.type === 'image' && el.src && el.src.includes('source.unsplash.com')) {
                                console.log(` Cleaning up old Unsplash Source URL: ${el.src.substring(0, 80)}...`);
                                // Extract keyword from URL if possible
                                const keywordMatch = el.src.match(/[?&]([^&]+)(?:&|$)/);
                                const keyword = keywordMatch ? keywordMatch[1] : 'business';
                                const keywordHash = keyword.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                                const picsumId = 1 + (keywordHash % 1000);
                                el.src = `https://picsum.photos/960/540?random=${picsumId}`;
                                console.log(` Replaced with Picsum: ${el.src}`);
                            }
                        });
                    }
                });
                
                // Organize elements in all slides to prevent overlaps
                this.data.forEach((slide, slideIndex) => {
                    if (slide.els && slide.els.length > 0) {
                        this.organizeSlideElements(slide);
                    }
                });
                
                this.data.forEach((slide, slideIndex) => {
                    const slideDiv = document.createElement('div');
                    slideDiv.className = 'canvas-slide' + (slideIndex === this.curr ? ' active' : '');
                    slideDiv.dataset.slideIndex = slideIndex;
                    
                    // Check if this is an AI slide with stageHtml
                    if (slide.variant === 'ai' && slide.stageHtml) {
                        // Use stageHtml directly for AI slides
                        slideDiv.style.position = 'relative';
                        slideDiv.style.width = '960px';
                        slideDiv.style.height = '540px';
                        slideDiv.style.margin = '0 auto';
                        slideDiv.style.background = 'transparent';
                        
                        // Create container for stageHtml with visible boundaries
                        const stageContainer = document.createElement('div');
                        stageContainer.style.position = 'relative';
                        stageContainer.style.width = '100%';
                        stageContainer.style.height = '100%';
                        stageContainer.style.overflow = 'hidden';
                        stageContainer.style.borderRadius = '8px';
                        stageContainer.style.border = '2px solid rgba(16, 185, 129, 0.3)';
                        stageContainer.style.boxShadow = 'inset 0 0 0 1px rgba(16, 185, 129, 0.1)';
                        // STRICT BOUNDARIES - Prevent elements from going outside
                        stageContainer.style.position = 'relative';
                        stageContainer.style.width = '960px';
                        stageContainer.style.height = '540px';
                        stageContainer.style.maxWidth = '960px';
                        stageContainer.style.maxHeight = '540px';
                        stageContainer.innerHTML = slide.stageHtml;
                        slideDiv.appendChild(stageContainer);
                        
                        // ENHANCED editing support with drag, resize, and flexibility
                        setTimeout(() => {
                            const editableElements = stageContainer.querySelectorAll('[contenteditable="true"]');
                            const draggableContainers = stageContainer.querySelectorAll('.draggable-container');
                            const images = stageContainer.querySelectorAll('img');
                            
                            // Make images draggable and resizable
                            images.forEach(img => {
                                // Make image draggable
                                let isDragging = false;
                                let isResizing = false;
                                let currentHandle = null;
                                let startX, startY, startLeft, startTop, startWidth, startHeight;
                                
                                // Ensure image has absolute positioning
                                if (!img.style.position || img.style.position === 'static') {
                                    img.style.position = 'absolute';
                                }
                                
                                // Wrap image in container for resize handles
                                if (!img.parentElement.classList.contains('image-wrapper')) {
                                    const wrapper = document.createElement('div');
                                    wrapper.className = 'image-wrapper';
                                    wrapper.style.cssText = 'position: relative; display: inline-block;';
                                    img.parentNode.insertBefore(wrapper, img);
                                    wrapper.appendChild(img);
                                }
                                const wrapper = img.parentElement;
                                
                                // Add resize handles
                                const resizeHandles = ['nw', 'ne', 'sw', 'se'];
                                resizeHandles.forEach(handle => {
                                    const resizeHandle = document.createElement('div');
                                    resizeHandle.className = `resize-handle ${handle}`;
                                    resizeHandle.style.cssText = `
                                        position: absolute;
                                        width: 12px;
                                        height: 12px;
                                        background: white;
                                        border: 2px solid rgba(16, 185, 129, 0.8);
                                        border-radius: 50%;
                                        display: none;
                                        z-index: 1000;
                                        cursor: ${handle}-resize;
                                    `;
                                    wrapper.appendChild(resizeHandle);
                                    
                                    resizeHandle.addEventListener('mousedown', (e) => {
                                    e.stopPropagation();
                                        isResizing = true;
                                        currentHandle = handle;
                                        const imgRect = img.getBoundingClientRect();
                                        const containerRect = stageContainer.getBoundingClientRect();
                                        startX = e.clientX;
                                        startY = e.clientY;
                                        startWidth = imgRect.width;
                                        startHeight = imgRect.height;
                                        startLeft = imgRect.left - containerRect.left;
                                        startTop = imgRect.top - containerRect.top;
                                        e.preventDefault();
                                    });
                                });
                                
                                // Show resize handles on hover
                                img.addEventListener('mouseenter', () => {
                                    wrapper.querySelectorAll('.resize-handle').forEach(h => h.style.display = 'block');
                                    img.style.cursor = 'move';
                                });
                                img.addEventListener('mouseleave', () => {
                                    if (!isResizing) {
                                        wrapper.querySelectorAll('.resize-handle').forEach(h => h.style.display = 'none');
                                    }
                                });
                                
                                // Make image draggable
                                img.addEventListener('mousedown', (e) => {
                                    if (e.target.classList.contains('resize-handle')) return;
                                    isDragging = true;
                                    const imgRect = img.getBoundingClientRect();
                                    const containerRect = stageContainer.getBoundingClientRect();
                                    startX = e.clientX;
                                    startY = e.clientY;
                                    startLeft = imgRect.left - containerRect.left;
                                    startTop = imgRect.top - containerRect.top;
                                    
                                    img.style.cursor = 'grabbing';
                                    img.style.transition = 'none';
                                    e.preventDefault();
                                });
                                
                                // Global mouse move handler
                                const handleMouseMove = (e) => {
                                    if (isResizing && currentHandle) {
                                        const dx = e.clientX - startX;
                                        const dy = e.clientY - startY;
                                        
                                        let newWidth = startWidth;
                                        let newHeight = startHeight;
                                        let newLeft = startLeft;
                                        let newTop = startTop;
                                        
                                        // Resize based on handle
                                        if (currentHandle.includes('e')) {
                                            newWidth = Math.max(50, startWidth + dx);
                                        }
                                        if (currentHandle.includes('w')) {
                                            newWidth = Math.max(50, startWidth - dx);
                                            newLeft = startLeft + dx;
                                        }
                                        if (currentHandle.includes('s')) {
                                            newHeight = Math.max(50, startHeight + dy);
                                        }
                                        if (currentHandle.includes('n')) {
                                            newHeight = Math.max(50, startHeight - dy);
                                            newTop = startTop + dy;
                                        }
                                        
                                        img.style.width = newWidth + 'px';
                                        img.style.height = newHeight + 'px';
                                        wrapper.style.left = newLeft + 'px';
                                        wrapper.style.top = newTop + 'px';
                                        wrapper.style.position = 'absolute';
                                    } else if (isDragging) {
                                        const dx = e.clientX - startX;
                                        const dy = e.clientY - startY;
                                        
                                        let newLeft = startLeft + dx;
                                        let newTop = startTop + dy;
                                        
                                        // STRICT CONSTRAINTS - Prevent images from going outside slide (960x540)
                                        const slideWidth = 960;
                                        const slideHeight = 540;
                                        const imgWidth = wrapper.offsetWidth || wrapper.scrollWidth;
                                        const imgHeight = wrapper.offsetHeight || wrapper.scrollHeight;
                                        
                                        // Keep within bounds - STRICT: never allow going below or outside
                                        newLeft = Math.max(0, Math.min(slideWidth - Math.max(imgWidth, 50), newLeft));
                                        newTop = Math.max(0, Math.min(slideHeight - Math.max(imgHeight, 50), newTop));
                                        
                                        // Also constrain resize to keep within bounds
                                        if (isResizing && currentHandle) {
                                            const maxWidth = slideWidth - newLeft;
                                            const maxHeight = slideHeight - newTop;
                                            if (newWidth > maxWidth) newWidth = maxWidth;
                                            if (newHeight > maxHeight) newHeight = maxHeight;
                                        }
                                        
                                        wrapper.style.left = newLeft + 'px';
                                        wrapper.style.top = newTop + 'px';
                                        wrapper.style.position = 'absolute';
                                    }
                                };
                                
                                const handleMouseUp = () => {
                                    if (isDragging || isResizing) {
                                        isDragging = false;
                                        isResizing = false;
                                        currentHandle = null;
                                        img.style.cursor = 'move';
                                        img.style.transition = '';
                                        wrapper.querySelectorAll('.resize-handle').forEach(h => h.style.display = 'none');
                                        if (typeof this !== 'undefined' && this.saveState) {
                                            this.saveState();
                                        }
                                    }
                                };
                                
                                document.addEventListener('mousemove', handleMouseMove);
                                document.addEventListener('mouseup', handleMouseUp);
                            });
                            
                            // Make containers draggable
                            draggableContainers.forEach(container => {
                                let isDragging = false;
                                let startX, startY, startLeft, startTop;
                                
                                container.addEventListener('mousedown', (e) => {
                                    // Only start dragging if clicking on container background or edges
                                    if (e.target === container || e.target.closest('.draggable-container') === container) {
                                        // Check if clicking on text content (don't drag if selecting text)
                                        if (e.target.contentEditable === 'true' || e.target.closest('[contenteditable="true"]')) {
                                            return; // Allow text selection
                                        }
                                        
                                        isDragging = true;
                                        const rect = container.getBoundingClientRect();
                                    const containerRect = stageContainer.getBoundingClientRect();
                                        startX = e.clientX;
                                        startY = e.clientY;
                                        
                                        // Get current position
                                        const computedStyle = window.getComputedStyle(container);
                                        startLeft = parseFloat(computedStyle.left) || 0;
                                        startTop = parseFloat(computedStyle.top) || 0;
                                        
                                        container.style.transition = 'none';
                                        container.style.cursor = 'grabbing';
                                        e.preventDefault();
                                    }
                                });
                                
                                document.addEventListener('mousemove', (e) => {
                                    if (!isDragging) return;
                                    
                                        const dx = (e.clientX - startX) / (this.zoom / 100);
                                        const dy = (e.clientY - startY) / (this.zoom / 100);
                                        
                                    let newLeft = startLeft + dx;
                                        let newTop = startTop + dy;
                                        
                                        // STRICT CONSTRAINTS - Prevent elements from going outside slide (960x540)
                                        const slideWidthBound = 960;
                                        const slideHeightBound = 540;
                                        const containerWidth = container.offsetWidth || container.scrollWidth;
                                        const containerHeight = container.offsetHeight || container.scrollHeight;
                                        
                                        // Keep within bounds - STRICT: never allow going below or outside
                                        newLeft = Math.max(0, Math.min(slideWidthBound - Math.max(containerWidth, 100), newLeft));
                                        newTop = Math.max(0, Math.min(slideHeightBound - Math.max(containerHeight, 50), newTop));
                                        
                                        // Also constrain container size if it's too large
                                        if (containerWidth > slideWidthBound) {
                                            container.style.maxWidth = slideWidthBound + 'px';
                                        }
                                        if (containerHeight > slideHeightBound) {
                                            container.style.maxHeight = slideHeightBound + 'px';
                                        }
                                        
                                    container.style.left = newLeft + 'px';
                                    container.style.top = newTop + 'px';
                                    container.style.right = 'auto';
                                    container.style.bottom = 'auto';
                                    container.style.transform = 'none';
                                });
                                
                                document.addEventListener('mouseup', () => {
                                    if (isDragging) {
                                        isDragging = false;
                                        container.style.transition = '';
                                        container.style.cursor = '';
                                        if (typeof this !== 'undefined' && this.saveState) {
                                            this.saveState();
                                        }
                                    }
                                });
                            });
                            
                            editableElements.forEach(element => {
                                // Make sure it's truly editable
                                element.contentEditable = 'true';
                                element.style.cursor = 'text';
                                element.style.userSelect = 'text';
                                element.style.webkitUserSelect = 'text';
                                element.style.pointerEvents = 'auto';
                                
                                // Simple save on blur
                                element.addEventListener('blur', () => {
                                    if (typeof this !== 'undefined' && this.saveState) {
                                        this.saveState();
                                    }
                                });
                                
                                // Simple save while typing (debounced)
                                element.addEventListener('input', () => {
                                    clearTimeout(element._saveTimeout);
                                    element._saveTimeout = setTimeout(() => {
                                        if (typeof this !== 'undefined' && this.saveState) {
                                            this.saveState();
                                        }
                                    }, 1000);
                                });
                                
                                // Don't interfere with normal text editing at all
                                // Let browser handle everything naturally
                            });
                        }, 100);
                        
                        // Add grid overlay for this slide
                        const gridOverlay = document.createElement('div');
                        gridOverlay.className = 'canvas-grid-overlay';
                        if (this.gridVisible) {
                            gridOverlay.classList.add('show');
                        }
                        slideDiv.appendChild(gridOverlay);
                        
                        // Add elements to AI slide (allow adding regular elements on top of AI content)
                        if (slide.els && slide.els.length > 0) {
                            slide.els.forEach(el => {
                                const element = this.createEl(el, slideIndex);
                                slideDiv.appendChild(element);
                            });
                        }
                    } else {
                        // Regular slide rendering
                    // Apply background with transparency
                    const bg = slide.bg || 'white';
                    const opacity = slide.bgOpacity !== undefined ? slide.bgOpacity : 1;
                    
                    if (bg.startsWith('url(')) {
                        slideDiv.style.backgroundImage = bg;
                        slideDiv.style.backgroundSize = 'cover';
                        slideDiv.style.backgroundPosition = 'center';
                        slideDiv.style.opacity = opacity;
                    } else if (bg.startsWith('linear-gradient')) {
                        slideDiv.style.background = bg;
                        slideDiv.style.opacity = opacity;
                    } else if (bg.startsWith('rgba')) {
                        slideDiv.style.background = bg;
                    } else {
                        // Convert hex to rgba with opacity
                        if (bg.startsWith('#')) {
                            const r = parseInt(bg.slice(1, 3), 16);
                            const g = parseInt(bg.slice(3, 5), 16);
                            const b = parseInt(bg.slice(5, 7), 16);
                            slideDiv.style.background = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        } else {
                            slideDiv.style.background = bg;
                            slideDiv.style.opacity = opacity;
                        }
                    }

                    // Add Aramco Digital template (logo and gradient line) - always show
                    // Logo at top
                    const logoContainer = document.createElement('div');
                    logoContainer.style.cssText = 'display: flex; align-items: center; padding: 32px 40px 0; position: absolute; top: 0; left: 0; right: 0; z-index: 2; pointer-events: none;';
                    const logo = document.createElement('img');
                    logo.src = 'assets/aramco-digital-logo.png';
                    logo.alt = 'Aramco Digital';
                    logo.style.cssText = 'height: 48px; width: auto;';
                    logoContainer.appendChild(logo);
                    slideDiv.appendChild(logoContainer);

                    // Content area (only show dashed box if slide is empty)
                    const isNewSlide = !slide.els || slide.els.length === 0;
                    if (isNewSlide) {
                        const contentArea = document.createElement('div');
                        contentArea.style.cssText = 'flex: 1; padding: 24px 40px; position: absolute; top: 80px; left: 0; right: 0; bottom: 10px; z-index: 1; pointer-events: none;';
                        const contentBox = document.createElement('div');
                        contentBox.style.cssText = 'height: 100%; width: 100%; border-radius: 24px; border: 2px dashed rgba(16, 185, 129, 0.3); background: rgba(255, 255, 255, 0.8);';
                        contentArea.appendChild(contentBox);
                        slideDiv.appendChild(contentArea);
                    }

                    // Gradient line at bottom - always show
                    const gradientLine = document.createElement('div');
                    gradientLine.style.cssText = 'height: 10px; width: 100%; background: linear-gradient(to right, #10b981, #14b8a6, #38bdf8); position: absolute; bottom: 0; left: 0; right: 0; z-index: 2; pointer-events: none;';
                    slideDiv.appendChild(gradientLine);

                    // Add grid overlay for this slide
                    const gridOverlay = document.createElement('div');
                    gridOverlay.className = 'canvas-grid-overlay';
                    if (this.gridVisible) {
                        gridOverlay.classList.add('show');
                    }
                    slideDiv.appendChild(gridOverlay);

                    // Add elements to this slide
                        if (slide.els && slide.els.length > 0) {
                    slide.els.forEach(el => {
                        const element = this.createEl(el, slideIndex);
                        slideDiv.appendChild(element);
                    });
                        }
                    }

                    // Click to select slide
                    slideDiv.addEventListener('click', (e) => {
                        const gridOverlay = slideDiv.querySelector('.canvas-grid-overlay');
                        if (e.target === slideDiv || e.target === gridOverlay || e.target.closest('.canvas-grid-overlay')) {
                            this.switchSlide(slideIndex);
                        }
                    });

                    wrapper.appendChild(slideDiv);
                });

                // Apply zoom to wrapper
                wrapper.style.transform = `scale(${this.zoom / 100})`;
            },

            renderSlides() {
                const container = document.getElementById('slides');
                container.innerHTML = '';
                
                this.data.forEach((slide, idx) => {
                    const div = document.createElement('div');
                    div.className = 'sidebar-slide' + (idx === this.curr ? ' active' : '');
                    
                    const preview = document.createElement('div');
                    preview.className = 'sidebar-slide-preview';
                    
                    // Check if this is an AI slide - regenerate preview with current data
                    if (slide.variant === 'ai') {
                        // Regenerate preview HTML with current slide data (els, design, etc.)
                        // This ensures thumbnails stay in sync with main slide
                        const context = {
                            subjectTitle: slide.title || '',
                            description: slide.description || slide.summary || '',
                            descriptionSentence: slide.description || slide.summary || ''
                        };
                        
                        // Create fresh preview with current slide state
                        const freshPreviewHtml = createAISlidePreview(slide, idx, context);
                        preview.innerHTML = freshPreviewHtml;
                        preview.style.position = 'relative';
                        preview.style.overflow = 'hidden';
                    } else {
                        // Regular slide preview
                    preview.style.background = slide.bg || 'white';
                    
                    if (slide.bg && slide.bg.startsWith('url(')) {
                        preview.style.backgroundImage = slide.bg;
                        preview.style.backgroundSize = 'cover';
                        preview.style.backgroundPosition = 'center';
                        }
                        
                        // Render elements in thumbnail (scaled down)
                        if (slide.els && slide.els.length > 0) {
                            slide.els.forEach(el => {
                                const element = this.createThumbnailElement(el);
                                preview.appendChild(element);
                            });
                        }
                    }
                    
                    // Add slide number
                    const number = document.createElement('div');
                    number.className = 'sidebar-slide-number';
                    number.textContent = idx + 1;
                    preview.appendChild(number);
                    
                    // Add delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'sidebar-slide-delete';
                    deleteBtn.textContent = '';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteSlide(idx);
                    };
                    preview.appendChild(deleteBtn);
                    
                    div.appendChild(preview);
                    div.onclick = () => this.switchSlide(idx);
                    container.appendChild(div);
                });
            },

            createThumbnailElement(data) {
                // Calculate scale factor dynamically: sidebar is 200px, padding is 20px total, so preview is ~180px wide
                // Main slide is 960px wide
                const sidebarWidth = 200;
                const sidebarPadding = 20; // 10px on each side
                const previewWidth = sidebarWidth - sidebarPadding;
                const slideWidth = 960;
                const scale = previewWidth / slideWidth;
                
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.left = (data.x * scale) + 'px';
                div.style.top = (data.y * scale) + 'px';
                div.style.width = (data.width * scale) + 'px';
                div.style.height = (data.height * scale) + 'px';
                div.style.pointerEvents = 'none';
                
                if (data.type === 'text') {
                    let fontFamily = data.font || 'Arial';
                    if (fontFamily === 'Kraft Mono') {
                        fontFamily = "'Kraft Mono', 'JetBrains Mono', monospace";
                    } else if (fontFamily === 'ID Grotesk') {
                        fontFamily = "'ID Grotesk', 'Work Sans', sans-serif";
                    }
                    div.style.fontFamily = fontFamily;
                    div.style.fontSize = ((data.size || 24) * scale) + 'px';
                    div.style.color = data.color || '#000000';
                    div.style.backgroundColor = data.bg || 'transparent';
                    div.style.fontWeight = data.weight || 'normal';
                    div.style.textAlign = data.align || 'left';
                    div.style.padding = (8 * scale) + 'px';
                    div.style.overflow = 'hidden';
                    div.style.textOverflow = 'ellipsis';
                    div.style.whiteSpace = 'nowrap';
                    div.textContent = data.content || '';
                    
                    // Apply fontStyle and textDecoration if they exist
                    if (data.fontStyle) {
                        div.style.fontStyle = data.fontStyle;
                    }
                    if (data.textDecoration) {
                        div.style.textDecoration = data.textDecoration;
                    }
                    
                    // Apply border if exists
                    if (data.borderWidth && data.borderWidth > 0) {
                        div.style.border = `${(data.borderWidth * scale)}px solid ${data.borderColor || '#000000'}`;
                    } else {
                        div.style.border = 'none';
                    }
                } else if (data.type === 'shape') {
                    const fillColor = data.bg || '#10b981';
                    const borderColor = data.border || '#047857';
                    const borderWidth = data.thick || 2;
                    
                    // Use SVG for complex shapes that need proper borders
                    const needsSVG = ['triangle', 'star', 'hexagon', 'diamond', 'arrow-right', 'arrow-left', 'pentagon'].includes(data.shape);
                    
                    if (needsSVG) {
                        div.style.backgroundColor = 'transparent';
                        div.style.border = 'none';
                        div.style.overflow = 'visible';
                        
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('viewBox', '0 0 100 100');
                        svg.style.position = 'absolute';
                        svg.style.top = '0';
                        svg.style.left = '0';
                        svg.style.pointerEvents = 'none';
                        
                        const shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let pathData = '';
                        
                        switch(data.shape) {
                            case 'triangle':
                                pathData = 'M 50,10 L 90,90 L 10,90 Z';
                                break;
                            case 'star':
                                pathData = 'M 50,5 L 61,35 L 98,35 L 68,57 L 79,91 L 50,70 L 21,91 L 32,57 L 2,35 L 39,35 Z';
                                break;
                            case 'hexagon':
                                pathData = 'M 50,5 L 85,25 L 85,75 L 50,95 L 15,75 L 15,25 Z';
                                break;
                            case 'diamond':
                                pathData = 'M 50,5 L 95,50 L 50,95 L 5,50 Z';
                                break;
                            case 'arrow-right':
                                pathData = 'M 5,25 L 60,25 L 60,5 L 95,50 L 60,95 L 60,75 L 5,75 Z';
                                break;
                            case 'arrow-left':
                                pathData = 'M 95,25 L 40,25 L 40,5 L 5,50 L 40,95 L 40,75 L 95,75 Z';
                                break;
                            case 'pentagon':
                                pathData = 'M 50,5 L 95,38 L 82,95 L 18,95 L 5,38 Z';
                                break;
                        }
                        
                        shape.setAttribute('d', pathData);
                        shape.setAttribute('fill', fillColor);
                        shape.setAttribute('stroke', borderColor);
                        // Calculate stroke width relative to viewBox (100x100) for thumbnail
                        const avgSize = (data.width + data.height) / 2;
                        const strokeWidthInViewBox = ((borderWidth / avgSize) * 100) * scale;
                        shape.setAttribute('stroke-width', Math.max(0.3, strokeWidthInViewBox).toString());
                        shape.setAttribute('stroke-linejoin', 'round');
                        shape.setAttribute('stroke-linecap', 'round');
                        
                        svg.appendChild(shape);
                        div.appendChild(svg);
                    } else {
                        // Simple shapes with CSS
                        div.style.backgroundColor = fillColor;
                        div.style.border = `${(borderWidth * scale)}px solid ${borderColor}`;
                        
                        switch(data.shape) {
                            case 'circle':
                                div.style.borderRadius = '50%';
                                break;
                            case 'rectangle':
                                div.style.borderRadius = (4 * scale) + 'px';
                                break;
                            default:
                                div.style.borderRadius = (4 * scale) + 'px';
                        }
                    }
                } else if (data.type === 'image') {
                    const img = document.createElement('img');
                    img.src = data.src;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    
                    // Apply transparency
                    if (data.transparency !== undefined) {
                        const opacity = (100 - data.transparency) / 100;
                        img.style.opacity = opacity;
                    }
                    
                    // Apply filters
                    if (data.filters) {
                        this.applyFiltersToImage(img, data.filters);
                    }
                    
                    // Apply shape
                    if (data.shape) {
                        switch(data.shape) {
                            case 'circle':
                                img.style.borderRadius = '50%';
                                img.style.clipPath = 'none';
                                break;
                            case 'rounded':
                                img.style.borderRadius = (20 * scale) + 'px';
                                img.style.clipPath = 'none';
                                break;
                            case 'triangle':
                                img.style.borderRadius = '0';
                                img.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                                break;
                            case 'none':
                            default:
                                img.style.borderRadius = '0';
                                img.style.clipPath = 'none';
                                break;
                        }
                    }
                    
                    // Apply border
                    if (data.borderWidth && data.borderWidth > 0) {
                        div.style.border = `${(data.borderWidth * scale)}px solid ${data.borderColor || '#000000'}`;
                    } else {
                        div.style.border = 'none';
                    }
                    
                    div.appendChild(img);
                } else if (data.type === 'chart') {
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                    div.style.backgroundColor = '#ffffff';
                    div.style.border = `${(2 * scale)}px solid #e5e7eb`;
                    div.style.borderRadius = (8 * scale) + 'px';
                    div.style.padding = '0';
                    div.style.overflow = 'visible';
                    
                    const chartCanvas = document.createElement('canvas');
                    const canvasWidth = Math.max(100, (data.width || 400) * scale);
                    const canvasHeight = Math.max(100, (data.height || 300) * scale);
                    chartCanvas.width = canvasWidth;
                    chartCanvas.height = canvasHeight;
                    chartCanvas.style.width = canvasWidth + 'px';
                    chartCanvas.style.height = canvasHeight + 'px';
                    chartCanvas.style.display = 'block';
                    chartCanvas.style.maxWidth = '100%';
                    chartCanvas.style.maxHeight = '100%';
                    
                    // Draw chart after a small delay to ensure canvas is ready
                    setTimeout(() => {
                        const ctx = chartCanvas.getContext('2d');
                        if (ctx) {
                            // Ensure data exists
                            if (!data.labels || data.labels.length === 0) {
                                const defaultData = this.getDefaultChartData(data.chartType || 'bar');
                                data.labels = defaultData.labels || [];
                                data.values = defaultData.values || [];
                                data.colors = defaultData.colors || [];
                            }
                            this.drawChart(ctx, data.chartType || 'bar', data, canvasWidth, canvasHeight);
                        }
                    }, 10);
                    
                    div.appendChild(chartCanvas);
                } else if (data.type === 'table') {
                    div.style.backgroundColor = 'white';
                    div.style.border = `${(1 * scale)}px solid #e5e7eb`;
                    div.style.borderRadius = (4 * scale) + 'px';
                    div.style.overflow = 'hidden';
                    
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.height = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.fontSize = (12 * scale) + 'px';
                    
                    for (let r = 0; r < data.rows; r++) {
                        const tr = document.createElement('tr');
                        for (let c = 0; c < data.cols; c++) {
                            const td = document.createElement(r === 0 ? 'th' : 'td');
                            td.textContent = data.data[r] ? data.data[r][c] : '';
                            td.style.border = `${(1 * scale)}px solid #e5e7eb`;
                            td.style.padding = (8 * scale) + 'px';
                            td.style.textAlign = 'left';
                            if (r === 0) {
                                td.style.backgroundColor = '#f3f4f6';
                                td.style.fontWeight = '600';
                            }
                            tr.appendChild(td);
                        }
                        table.appendChild(tr);
                    }
                    div.appendChild(table);
                } else if (data.type === 'symbol') {
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                    div.style.fontSize = ((data.fontSize || 48) * scale) + 'px';
                    div.style.color = data.color || '#000000';
                    div.style.backgroundColor = 'transparent';
                    div.textContent = data.symbol || '';
                    div.style.userSelect = 'none';
                }
                
                return div;
            },

            async addSlide() {
                // Get the main presentation subject/title for context
                const mainTitle = document.getElementById('title')?.value || '';
                const subject = mainTitle.trim() || 'Presentation';
                
                // Show loading
                this.showLoading();
                
                try {
                    // Generate AI content for the new slide
                    const slideNumber = this.data.length + 1;
                    const context = buildSubjectContext(subject, '');
                    
                    // Generate one slide about the subject with MORE DETAILED content
                    const aiSlides = await fetchFreeAIDeckPlan({
                        title: subject,
                        description: `Generate CONCISE and VALUABLE content for slide ${slideNumber} about ${subject}. Be brief but informative - maximum 60 words. Focus on key points only.`,
                        slideCount: 1
                    });
                    
                    let newSlideEntry = {
                        title: `Slide ${slideNumber}`,
                        description: `Content about ${subject}`,
                        summary: `Content about ${subject}`,
                        notes: '',
                        design: this.data[0]?.design || {
                            background: 'gradient-dark',
                            customColor: '#0f172a',
                            showTitle: true,
                            showDescription: true,
                            showBadge: true,
                            showSlideNumber: true,
                            layoutPosition: 'center',
                        }
                    };
                    
                    if (aiSlides && aiSlides.length > 0) {
                        // Use the first AI-generated slide
                        const aiSlide = aiSlides[0];
                        newSlideEntry.title = aiSlide.title || `Slide ${slideNumber}`;
                        newSlideEntry.description = aiSlide.description || aiSlide.summary || `Content about ${subject}`;
                        newSlideEntry.summary = aiSlide.summary || aiSlide.description || `Content about ${subject}`;
                        newSlideEntry.notes = aiSlide.notes || '';
                    }
                    
                    // Create slide with elements (image, text, chart if needed)
                    const slideWithElements = {
                        ...newSlideEntry,
                        els: [],
                        originalSubject: subject.toLowerCase().trim(),
                        subject: subject.toLowerCase().trim()
                    };
                    
                    // Generate image for the new slide
                    try {
                        const imageUrl = await getImageUrl(slideWithElements);
                        const hasChart = shouldAddChart(slideWithElements, slideNumber - 1);
                        
                        // Add image element
                        slideWithElements.els.push({
                            id: `image-${slideNumber}-${Date.now()}`,
                            type: 'image',
                            src: imageUrl,
                            x: 30,
                            y: 100,
                            width: hasChart ? 320 : 360,
                            height: 340,
                            animation: 'slideInLeft',
                            borderRadius: 12,
                            objectFit: 'cover'
                        });
                        
                        // Add chart if needed
                        if (hasChart) {
                            const chartData = extractChartData(slideWithElements);
                            if (chartData && chartData.values && chartData.values.length >= 3) {
                                slideWithElements.els.push({
                                    id: `chart-${slideNumber}-${Date.now()}`,
                                    type: 'chart',
                                    x: 640,
                                    y: 100,
                                    width: 280,
                                    height: 340,
                                    chartType: chartData.type,
                                    labels: chartData.labels,
                                    values: chartData.values,
                                    colors: ['#10b981', '#059669', '#047857', '#065f46', '#0891b2', '#0d9488', '#14b8a6'].slice(0, chartData.labels.length),
                                    animation: 'slideInRight',
                                    borderRadius: 12,
                                    backgroundColor: 'rgba(255, 255, 255, 0.05)',
                                    borderColor: 'rgba(255, 255, 255, 0.1)'
                                });
                            }
                        }
                    } catch (imageError) {
                        console.error('Error generating image for new slide:', imageError);
                    }
                    
                    // Organize elements
                    if (typeof organizeElements === 'function') {
                        organizeElements(slideWithElements.els);
                    }
                    
                    // Create AI slide object
                    const slideObj = createAISlideObject(slideWithElements, slideNumber - 1, this.data.length + 1, context);
                    
                    // Add to data
                    this.data.push({
                        els: slideWithElements.els,
                        bg: 'white',
                        transition: 'fade',
                        title: slideObj.title,
                        description: slideObj.description,
                        summary: slideObj.summary,
                        notes: slideObj.notes,
                        variant: 'ai',
                        design: slideObj.design,
                        stageHtml: slideObj.stageHtml,
                        previewHtml: slideObj.previewHtml
                    });
                    
                this.curr = this.data.length - 1;
                this.saveState();
                this.renderSlides();
                this.loadCanvas();
                    
                    this.showNotification('New slide added with AI-generated content!');
                
                // Auto-scroll to the new slide
                setTimeout(() => {
                    const sidebar = document.getElementById('sidebar');
                    const slides = sidebar.querySelectorAll('.sidebar-slide');
                    const lastSlide = slides[slides.length - 1];
                    if (lastSlide) {
                        lastSlide.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 100);
                } catch (error) {
                    console.error('Error adding AI slide:', error);
                    // Fallback: add empty slide
                    this.data.push({ els: [], bg: 'white', transition: 'fade' });
                    this.curr = this.data.length - 1;
                    this.saveState();
                    this.renderSlides();
                    this.loadCanvas();
                    this.showNotification('New slide added (AI generation failed)', 'warning');
                } finally {
                    this.hideLoading();
                }
            },

            deleteSlide(idx) {
                if (this.data.length === 1) {
                    this.showNotification('Cannot delete the last slide', 'warning');
                    return;
                }
                this.data.splice(idx, 1);
                if (this.curr >= this.data.length) {
                    this.curr = this.data.length - 1;
                }
                this.saveState();
                this.renderSlides();
                this.loadCanvas();
                this.showNotification('Slide deleted successfully');
            },

            switchSlide(idx) {
                this.curr = idx;
                this.renderSlides();
                this.loadCanvas();
                this.deselectAll();
                
                // Auto-scroll sidebar to the active slide
                setTimeout(() => {
                    const sidebar = document.getElementById('sidebar');
                    const activeSlide = sidebar.querySelector('.sidebar-slide.active');
                    if (activeSlide) {
                        activeSlide.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 50);

                // Auto-scroll main canvas to the active slide
                setTimeout(() => {
                    const mainCanvas = document.getElementById('mainCanvas');
                    const slides = document.querySelectorAll('.canvas-slide');
                    const activeCanvasSlide = slides[idx];
                    if (activeCanvasSlide) {
                        activeCanvasSlide.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            },

            deleteElement() {
                if (!this.sel) return;
                
                const id = this.sel.dataset.id;
                this.data[this.curr].els = this.data[this.curr].els.filter(e => e.id != id);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                this.sel = null;
            },

            duplicateElement() {
                if (!this.sel) return;
                
                const id = this.sel.dataset.id;
                const el = this.data[this.curr].els.find(e => e.id == id);
                if (el) {
                    const newEl = { ...el, id: Date.now(), x: el.x + 20, y: el.y + 20 };
                    this.data[this.curr].els.push(newEl);
                    this.saveState();
                    this.loadCanvas();
                    this.renderSlides();
                }
            },

            saveElementPosition() {
                if (!this.sel) return;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.x = parseInt(this.sel.style.left);
                    el.y = parseInt(this.sel.style.top);
                    el.width = parseInt(this.sel.style.width);
                    el.height = parseInt(this.sel.style.height);
                    
                    // Preserve text content when resizing
                    if (el.type === 'text') {
                        const currentContent = this.sel.innerText || this.sel.textContent || el.content || '';
                        el.content = currentContent;
                    }
                    
                    this.saveState();
                    
                    // Update properties panel
                    this.renderPropertiesPanel(el);
                    
                    // Debounce thumbnail update to avoid performance issues during dragging
                    if (this.thumbnailUpdateTimeout) {
                        clearTimeout(this.thumbnailUpdateTimeout);
                    }
                    this.thumbnailUpdateTimeout = setTimeout(() => {
                        this.renderSlides();
                    }, 200);
                }
            },

            changeFont() {
                if (!this.sel) return;
                
                const font = document.getElementById('fontFamily').value;
                let fontFamily = font;
                
                // Add fallback fonts
                if (font === 'Kraft Mono') {
                    fontFamily = "'Kraft Mono', 'JetBrains Mono', monospace";
                } else if (font === 'ID Grotesk') {
                    fontFamily = "'ID Grotesk', 'Work Sans', sans-serif";
                }
                
                this.sel.style.fontFamily = fontFamily;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.font = font;
                    this.saveState();
                    this.renderSlides();
                }
            },

            changeFontSize() {
                if (!this.sel) return;
                
                const size = document.getElementById('fontSize').value;
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el && el.type === 'text') {
                    // Preserve content when changing size
                    const currentContent = this.sel.innerText || this.sel.textContent || el.content || '';
                    el.content = currentContent;
                }
                
                this.sel.style.fontSize = size + 'px';
                
                if (el) {
                    el.size = parseInt(size);
                    this.saveState();
                    this.renderSlides();
                }
            },

            toggleBold() {
                if (!this.sel) return;
                
                const current = this.sel.style.fontWeight;
                const newWeight = current === 'bold' ? 'normal' : 'bold';
                this.sel.style.fontWeight = newWeight;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.weight = newWeight;
                    this.saveState();
                    this.renderSlides();
                }
            },

            toggleItalic() {
                if (!this.sel) return;
                
                const current = this.sel.style.fontStyle;
                const newStyle = current === 'italic' ? 'normal' : 'italic';
                this.sel.style.fontStyle = newStyle;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.fontStyle = newStyle;
                this.saveState();
                this.renderSlides();
                }
            },

            toggleUnderline() {
                if (!this.sel) return;
                
                const current = this.sel.style.textDecoration;
                const newDecoration = current === 'underline' ? 'none' : 'underline';
                this.sel.style.textDecoration = newDecoration;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.textDecoration = newDecoration;
                this.saveState();
                this.renderSlides();
                }
            },

            changeTextColor() {
                if (!this.sel) return;
                
                const color = document.getElementById('textColor').value;
                this.sel.style.color = color;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.color = color;
                    this.saveState();
                    this.renderSlides();
                }
            },

            changeBgColor() {
                if (!this.sel) return;
                
                const color = document.getElementById('bgColor').value;
                this.sel.style.backgroundColor = color;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.bg = color;
                    this.saveState();
                    this.renderSlides();
                }
            },

            alignText(align) {
                if (!this.sel) return;
                
                this.sel.style.textAlign = align;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.align = align;
                    this.saveState();
                    this.renderSlides();
                }
            },

            moveLayer(direction) {
                if (!this.sel) return;
                
                const id = this.sel.dataset.id;
                const els = this.data[this.curr].els;
                const idx = els.findIndex(e => e.id == id);
                
                if (direction === 'forward' && idx < els.length - 1) {
                    [els[idx], els[idx + 1]] = [els[idx + 1], els[idx]];
                } else if (direction === 'backward' && idx > 0) {
                    [els[idx], els[idx - 1]] = [els[idx - 1], els[idx]];
                }
                
                this.saveState();
                this.loadCanvas();
            },

            saveState() {
                const state = JSON.stringify(this.data);
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                this.history.push(state);
                this.historyIndex++;
                
                document.getElementById('undoBtn').disabled = this.historyIndex <= 0;
                document.getElementById('redoBtn').disabled = this.historyIndex >= this.history.length - 1;
            },

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.data = JSON.parse(this.history[this.historyIndex]);
                    this.loadCanvas();
                    this.renderSlides();
                    
                    document.getElementById('undoBtn').disabled = this.historyIndex <= 0;
                    document.getElementById('redoBtn').disabled = false;
                }
            },

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.data = JSON.parse(this.history[this.historyIndex]);
                    this.loadCanvas();
                    this.renderSlides();
                    
                    document.getElementById('undoBtn').disabled = false;
                    document.getElementById('redoBtn').disabled = this.historyIndex >= this.history.length - 1;
                }
            },

            newPresentation() {
                if (confirm('Start a new presentation? Unsaved changes will be lost.')) {
                    this.data = [{ els: [], bg: 'white', transition: 'fade' }];
                    this.curr = 0;
                    this.history = [];
                    this.historyIndex = -1;
                    document.getElementById('title').value = '';
                    this.saveState();
                    this.loadCanvas();
                    this.renderSlides();
                }
            },

            async saveToFirebase() {
                if (!window.firebaseDb || !window.currentUserId) {
                    this.showNotification('Please log in to save to cloud', 'error');
                    return;
                }

                try {
                    const { collection, addDoc, doc, setDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
                    const title = document.getElementById('title').value || 'Untitled presentation';
                    const presentationData = {
                        title: title,
                        slides: this.data,
                        editorType: 'editor-ai',
                        updatedAt: serverTimestamp(),
                        createdAt: serverTimestamp()
                    };

                    // Check if we're editing an existing presentation
                    const urlParams = new URLSearchParams(window.location.search);
                    let presentationId = urlParams.get('presentationId');
                    
                    // Also check if we have a stored presentationId (for cases where URL might not have it)
                    if (!presentationId && this.currentPresentationId) {
                        presentationId = this.currentPresentationId;
                    }
                    
                    if (presentationId) {
                        // Update existing presentation
                        const presentationRef = doc(window.firebaseDb, 'users', window.currentUserId, 'presentations', presentationId);
                        await setDoc(presentationRef, {
                            ...presentationData,
                            updatedAt: serverTimestamp()
                        }, { merge: true });
                        
                        // Store presentationId for future saves
                        this.currentPresentationId = presentationId;
                        
                        this.showNotification('Presentation updated successfully');
                    } else {
                        // Create new presentation
                        const presentationsRef = collection(window.firebaseDb, 'users', window.currentUserId, 'presentations');
                        const docRef = await addDoc(presentationsRef, {
                            ...presentationData,
                            createdAt: serverTimestamp()
                        });
                        
                        // Store presentationId for future saves
                        this.currentPresentationId = docRef.id;
                        
                        // Update URL with the new presentation ID
                        const newUrl = new URL(window.location);
                        newUrl.searchParams.set('presentationId', docRef.id);
                        window.history.replaceState({}, '', newUrl);
                        this.showNotification('Presentation saved to cloud successfully');
                    }
                } catch (error) {
                    console.error('Failed to save to Firebase:', error);
                    this.showNotification('Failed to save to cloud: ' + error.message, 'error');
                }
            },

            saveJSON() {
                // Save to Firebase only
                this.saveToFirebase();
            },

            loadJSON() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            try {
                                const data = JSON.parse(ev.target.result);
                                this.data = data.slides;
                                document.getElementById('title').value = data.title || '';
                                this.curr = 0;
                                this.saveState();
                                this.loadCanvas();
                                this.renderSlides();
                                this.showNotification('Presentation loaded successfully');
                            } catch (err) {
                                this.showNotification('Error loading file. Please check the file format.', 'error');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            },

            toggleExport() {
                document.getElementById('exportMenu').classList.toggle('show');
            },

            async exportPDF() {
                this.showLoading();
                try {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('landscape', 'px', [960, 540]);
                    
                    const slides = document.querySelectorAll('.canvas-slide');
                    
                    // Helper function to wait for all images to load
                    const waitForImages = (element) => {
                        return new Promise((resolve) => {
                            const images = element.querySelectorAll('img');
                            if (images.length === 0) {
                                resolve();
                                return;
                            }
                            
                            let loadedCount = 0;
                            const totalImages = images.length;
                            
                            const checkComplete = () => {
                                loadedCount++;
                                if (loadedCount === totalImages) {
                                    resolve();
                                }
                            };
                            
                            images.forEach((img) => {
                                if (img.complete && img.naturalHeight !== 0) {
                                    checkComplete();
                                } else {
                                    img.onload = checkComplete;
                                    img.onerror = checkComplete; // Continue even if image fails
                                    // Force reload if image has src
                                    if (img.src && !img.complete) {
                                        const src = img.src;
                                        img.src = '';
                                        img.src = src;
                                    }
                                }
                            });
                            
                            // Timeout after 5 seconds
                            setTimeout(() => {
                                if (loadedCount < totalImages) {
                                    console.warn(` Some images didn't load in time for slide ${i + 1}`);
                                    resolve(); // Continue anyway
                                }
                            }, 5000);
                        });
                    };
                    
                    for (let i = 0; i < slides.length; i++) {
                        if (i > 0) pdf.addPage([960, 540], 'landscape');
                        
                        // Wait for all images in this slide to load
                        await waitForImages(slides[i]);
                        
                        // Additional delay to ensure rendering is complete
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        const canvas = await html2canvas(slides[i], {
                            width: 960,
                            height: 540,
                            scale: 2,
                            useCORS: true, // Enable CORS for external images
                            allowTaint: true, // Allow cross-origin images
                            logging: false, // Disable logging for better performance
                            backgroundColor: '#ffffff', // White background
                            imageTimeout: 15000, // 15 second timeout for images
                            removeContainer: false, // Keep container for better rendering
                            onclone: (clonedDoc) => {
                                // Ensure all images in cloned document are loaded
                                const clonedImages = clonedDoc.querySelectorAll('img');
                                clonedImages.forEach((img) => {
                                    if (img.src && !img.complete) {
                                        // Force image to load
                                        const src = img.src;
                                        img.src = '';
                                        img.src = src;
                                    }
                                });
                            }
                        });
                        
                        const imgData = canvas.toDataURL('image/png', 1.0);
                        pdf.addImage(imgData, 'PNG', 0, 0, 960, 540);
                    }
                    
                    pdf.save((document.getElementById('title').value || 'presentation') + '.pdf');
                    this.showNotification('PDF exported successfully');
                } catch (error) {
                    console.error('PDF export error:', error);
                    this.showNotification('Failed to export PDF: ' + error.message, 'error');
                } finally {
                    this.hideLoading();
                    this.closeModal('exportMenu');
                }
            },

            async exportImages() {
                this.showLoading();
                try {
                    const slides = document.querySelectorAll('.canvas-slide');
                    
                    for (let i = 0; i < slides.length; i++) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        const canvas = await html2canvas(slides[i], {
                            width: 960,
                            height: 540,
                            scale: 2
                        });
                        
                        canvas.toBlob(blob => {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `slide-${i + 1}.png`;
                            a.click();
                        });
                    }
                    this.showNotification('Images exported successfully');
                } catch (error) {
                    this.showNotification('Failed to export images', 'error');
                } finally {
                    this.hideLoading();
                    this.closeModal('exportMenu');
                }
            },

            shareLink() {
                const data = btoa(JSON.stringify({
                    title: document.getElementById('title').value,
                    slides: this.data
                }));
                const url = window.location.origin + window.location.pathname + '?data=' + data;
                
                navigator.clipboard.writeText(url).then(() => {
                    this.showNotification('Share link copied to clipboard!');
                }).catch(() => {
                    this.showNotification('Failed to copy link', 'error');
                });
                this.closeModal('exportMenu');
            },

            copyStyle() {
                if (!this.sel) {
                    this.showNotification('Select an element first', 'warning');
                    return;
                }
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    this.copiedStyle = {
                        font: el.font,
                        size: el.size,
                        weight: el.weight,
                        color: el.color,
                        bg: el.bg,
                        align: el.align,
                        border: el.border,
                        thick: el.thick
                    };
                    this.showNotification('Style copied! Select another element and click Paste Style');
                }
            },

            pasteStyle() {
                if (!this.copiedStyle) {
                    this.showNotification('Copy a style first', 'warning');
                    return;
                }
                
                if (!this.sel) {
                    this.showNotification('Select target element', 'warning');
                    return;
                }
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    if (el.type === 'text' && this.copiedStyle.font) {
                        el.font = this.copiedStyle.font;
                        el.size = this.copiedStyle.size;
                        el.weight = this.copiedStyle.weight;
                        el.color = this.copiedStyle.color;
                        el.bg = this.copiedStyle.bg;
                        el.align = this.copiedStyle.align;
                    }
                    if (el.type === 'shape' && this.copiedStyle.border) {
                        el.border = this.copiedStyle.border;
                        el.thick = this.copiedStyle.thick;
                        el.bg = this.copiedStyle.bg;
                    }
                }
                
                this.saveState();
                this.loadCanvas();
                this.showNotification('Style applied successfully');
            },

            setBgColor() {
                document.getElementById('bgModal').classList.add('show');
            },

            applyBg(color) {
                const currentSlide = this.data[this.curr];
                
                // Store original color
                currentSlide.bg = color;
                currentSlide.originalBg = color;
                
                // Handle AI slides - update design.background and regenerate stageHtml
                if (currentSlide.variant === 'ai' && currentSlide.design) {
                    // Convert color/gradient to design background style
                    let bgStyle = 'gradient-dark';
                    let customColor = '#0f172a';
                    
                    if (color.startsWith('linear-gradient')) {
                        // Try to detect gradient type
                        if (color.includes('blue-50') || color.includes('indigo-50') || color.includes('emerald-50')) {
                            bgStyle = 'gradient-light';
                        } else {
                            bgStyle = 'gradient-dark';
                        }
                    } else if (color.startsWith('#') || color.startsWith('rgba')) {
                        // Detect if it's a dark or light color
                        let rgb;
                        if (color.startsWith('#')) {
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            rgb = [r, g, b];
                            customColor = color;
                        } else if (color.startsWith('rgba')) {
                            const matches = color.match(/\d+/g);
                            if (matches && matches.length >= 3) {
                                rgb = [parseInt(matches[0]), parseInt(matches[1]), parseInt(matches[2])];
                                customColor = `#${rgb.map(x => x.toString(16).padStart(2, '0')).join('')}`;
                            }
                        }
                        
                        if (rgb) {
                            const brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
                            if (color === 'white' || brightness > 200) {
                                bgStyle = 'white';
                            } else if (brightness > 128) {
                                bgStyle = 'solid-light';
                            } else if (brightness > 50) {
                                bgStyle = 'solid-dark';
                            } else {
                                bgStyle = 'custom';
                            }
                        } else {
                            bgStyle = 'custom';
                        }
                    } else if (color === 'white') {
                        bgStyle = 'white';
                    } else {
                        bgStyle = 'custom';
                        customColor = color.startsWith('#') ? color : '#0f172a';
                    }
                    
                    // Update design
                    currentSlide.design.background = bgStyle;
                    currentSlide.design.customColor = customColor;
                    
                    // Regenerate stageHtml with new background
                    const context = {
                        subjectTitle: currentSlide.title || '',
                        subjectLower: (currentSlide.title || '').toLowerCase(),
                        subjectKeyword: (currentSlide.title || '').split(' ')[0] || '',
                        descriptionSentence: currentSlide.description || ''
                    };
                    const slideData = {
                        ...currentSlide,
                        design: currentSlide.design
                    };
                    currentSlide.stageHtml = createAISlideStage(
                        slideData, 
                        this.curr, 
                        this.data.length, 
                        context,
                        currentSlide.id || `slide-${this.curr + 1}`
                    );
                }
                
                // Get current transparency and apply it
                const transparency = currentSlide.transparency || 0;
                if (transparency > 0) {
                    currentSlide.bgOpacity = (100 - transparency) / 100;
                    // If it's a hex color, convert to rgba
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        const alpha = (100 - transparency) / 100;
                        currentSlide.bg = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    } else if (color.startsWith('linear-gradient')) {
                        // Keep gradient as is, opacity will be applied via CSS
                        currentSlide.bg = color;
                    }
                } else {
                    currentSlide.bgOpacity = 1;
                }
                
                // Update transparency controls if dropdown is open
                const slider = document.getElementById('bgTransparencySlider');
                const input = document.getElementById('bgTransparencyInput');
                if (slider) slider.value = transparency;
                if (input) input.value = transparency;
                
                // Use setTimeout to prevent UI freezing
                setTimeout(() => {
                    this.loadCanvas();
                    this.saveState();
                    this.renderSlides();
                }, 10);
            },

            updateBgTransparency(value) {
                const transparency = parseInt(value) || 0;
                this.data[this.curr].transparency = transparency;
                
                // Update slider and input
                const slider = document.getElementById('bgTransparencySlider');
                const input = document.getElementById('bgTransparencyInput');
                if (slider) slider.value = transparency;
                if (input) input.value = transparency;
                
                // For AI slides, update stageHtml if needed (transparency affects rendering)
                const currentSlide = this.data[this.curr];
                if (currentSlide.variant === 'ai' && currentSlide.design) {
                    // Regenerate stageHtml with transparency applied
                    const context = {
                        subjectTitle: currentSlide.title || '',
                        subjectLower: (currentSlide.title || '').toLowerCase(),
                        subjectKeyword: (currentSlide.title || '').split(' ')[0] || '',
                        descriptionSentence: currentSlide.description || ''
                    };
                    const slideData = {
                        ...currentSlide,
                        design: currentSlide.design
                    };
                    currentSlide.stageHtml = createAISlideStage(
                        slideData, 
                        this.curr, 
                        this.data.length, 
                        context,
                        currentSlide.id || `slide-${this.curr + 1}`
                    );
                }
                
                // Apply transparency to current background
                const currentBg = currentSlide.originalBg || currentSlide.bg || 'white';
                currentSlide.bgOpacity = (100 - transparency) / 100;
                
                // If background is hex color and transparency > 0, convert to rgba
                // Otherwise, keep original and use opacity
                if (currentBg.startsWith('#') && transparency > 0) {
                    const r = parseInt(currentBg.slice(1, 3), 16);
                    const g = parseInt(currentBg.slice(3, 5), 16);
                    const b = parseInt(currentBg.slice(5, 7), 16);
                    const alpha = (100 - transparency) / 100;
                    // Store original hex for when transparency is reset
                    if (!currentSlide.originalBg) {
                        currentSlide.originalBg = currentBg;
                    }
                    currentSlide.bg = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                } else if (transparency === 0 && currentSlide.originalBg) {
                    // Restore original color when transparency is 0
                    currentSlide.bg = currentSlide.originalBg;
                    delete currentSlide.originalBg;
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
            },

            adjustTransparency(delta) {
                const input = document.getElementById('bgTransparencyInput');
                if (!input) return;
                
                let currentValue = parseInt(input.value) || 0;
                currentValue = Math.max(0, Math.min(100, currentValue + delta));
                
                this.updateBgTransparency(currentValue);
            },

            uploadBgImage() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            this.data[this.curr].bg = `url(${ev.target.result})`;
                            this.closeModal('bgModal');
                            
                            // Use setTimeout to prevent UI freezing
                            setTimeout(() => {
                                this.loadCanvas();
                                this.saveState();
                            }, 10);
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            },

            showAnimations() {
                if (!this.sel) {
                    this.showNotification('Select an element first', 'warning');
                    return;
                }
                document.getElementById('animModal').classList.add('show');
            },

            applyAnimation(animation) {
                if (!this.sel) return;
                
                const el = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (el) {
                    el.animation = animation;
                    this.saveState();
                    this.closeModal('animModal');
                    this.showNotification(`Animation "${animation}" applied! Preview in Presentation Mode`);
                }
            },

            presentMode() {
                this.presenting = true;
                this.presentSlide = 0;
                
                const presentDiv = document.createElement('div');
                presentDiv.className = 'present-mode active';
                presentDiv.innerHTML = `
                    <div class="present-slide">
                        <div class="present-canvas" id="presentCanvas"></div>
                    </div>
                    <div class="present-controls">
                        <button class="present-btn" onclick="app.prevPresentSlide()"></button>
                        <div class="present-counter"><span id="presentCounter">1 / ${this.data.length}</span></div>
                        <button class="present-btn" onclick="app.nextPresentSlide()"></button>
                        <button class="present-btn" onclick="app.exitPresent()"></button>
                    </div>
                `;
                document.body.appendChild(presentDiv);
                
                this.renderPresentSlide();
                
                document.addEventListener('keydown', this.presentKeyHandler = (e) => {
                    if (e.key === 'Escape') this.exitPresent();
                    if (e.key === 'ArrowRight' || e.key === ' ') this.nextPresentSlide();
                    if (e.key === 'ArrowLeft') this.prevPresentSlide();
                });
            },

            renderPresentSlide() {
                const canvas = document.getElementById('presentCanvas');
                if (!canvas) return;
                
                const slide = this.data[this.presentSlide];
                canvas.innerHTML = '';
                canvas.style.width = '960px';
                canvas.style.height = '540px';
                canvas.style.position = 'relative';
                
                // Check if this is an AI slide with stageHtml
                if (slide.variant === 'ai' && slide.stageHtml) {
                    // Use stageHtml directly for AI slides
                    canvas.style.background = 'transparent';
                    const stageContainer = document.createElement('div');
                    stageContainer.style.position = 'relative';
                    stageContainer.style.width = '100%';
                    stageContainer.style.height = '100%';
                    stageContainer.style.overflow = 'hidden';
                    stageContainer.innerHTML = slide.stageHtml;
                    canvas.appendChild(stageContainer);
                } else {
                    // Regular slide rendering
                    canvas.style.background = slide.bg || '#ffffff';
                
                if (slide.bg && slide.bg.startsWith('url(')) {
                    canvas.style.backgroundImage = slide.bg;
                    canvas.style.backgroundSize = 'cover';
                    canvas.style.backgroundPosition = 'center';
                }
                
                const transition = slide.transition || 'fade';
                canvas.className = 'present-canvas slide-transition-' + transition;
                
                    if (slide.els && slide.els.length > 0) {
                slide.els.forEach((el, index) => {
                    const div = document.createElement('div');
                    div.className = 'element ' + el.type + '-element';
                    div.style.left = el.x + 'px';
                    div.style.top = el.y + 'px';
                    div.style.width = el.width + 'px';
                    div.style.height = el.height + 'px';

                    if (el.shadow) {
                        div.style.boxShadow = el.shadow;
                    }

                    if (el.type === 'text') {
                        div.textContent = el.content;
                        div.style.fontFamily = el.font || 'Arial';
                        div.style.fontSize = (el.size || 24) + 'px';
                        div.style.color = el.color || '#000000';
                        div.style.backgroundColor = el.bg || 'transparent';
                        div.style.fontWeight = el.weight || 'normal';
                        div.style.textAlign = el.align || 'left';
                        div.style.padding = '8px';
                        
                        // Apply fontStyle and textDecoration if they exist
                        if (el.fontStyle) {
                            div.style.fontStyle = el.fontStyle;
                        }
                        if (el.textDecoration) {
                            div.style.textDecoration = el.textDecoration;
                        }
                    }

                    if (el.type === 'shape') {
                        div.style.backgroundColor = el.bg || '#3b82f6';
                        div.style.border = `${el.thick || 2}px solid ${el.border || '#1e40af'}`;
                        
                        // Apply shape styles for presentation
                        switch(el.shape) {
                            case 'circle':
                                div.style.borderRadius = '50%';
                                break;
                            case 'rectangle':
                                div.style.borderRadius = '4px';
                                break;
                            case 'triangle':
                                div.style.backgroundColor = 'transparent';
                                div.style.borderLeft = `${el.width / 2}px solid transparent`;
                                div.style.borderRight = `${el.width / 2}px solid transparent`;
                                div.style.borderBottom = `${el.height}px solid ${el.bg || '#3b82f6'}`;
                                div.style.width = '0';
                                div.style.height = '0';
                                div.style.border = 'none';
                                break;
                            case 'star':
                                div.style.borderRadius = '4px';
                                div.style.clipPath = 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
                                break;
                            case 'pentagon':
                                div.style.clipPath = 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)';
                                break;
                            case 'hexagon':
                                div.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                                break;
                            case 'diamond':
                                div.style.clipPath = 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
                                break;
                            case 'arrow-right':
                                div.style.clipPath = 'polygon(0% 25%, 60% 25%, 60% 0%, 100% 50%, 60% 100%, 60% 75%, 0% 75%)';
                                break;
                            case 'arrow-left':
                                div.style.clipPath = 'polygon(40% 25%, 100% 25%, 100% 75%, 40% 75%, 40% 100%, 0% 50%, 40% 0%)';
                                break;
                            default:
                                div.style.borderRadius = '4px';
                        }
                    }

                    if (el.type === 'image') {
                        const img = document.createElement('img');
                        img.src = el.src;
                        img.style.width = '100%';
                        img.style.height = '100%';
                        img.style.objectFit = 'cover';
                        div.appendChild(img);
                    }

                    if (el.animation && el.animation !== 'none') {
                        setTimeout(() => {
                            div.classList.add('animate-' + el.animation);
                        }, index * 200);
                    }
                    canvas.appendChild(div);
                });
                    }
                }
                
                document.getElementById('presentCounter').textContent = `${this.presentSlide + 1} / ${this.data.length}`;
            },

            nextPresentSlide() {
                if (this.presentSlide < this.data.length - 1) {
                    this.presentSlide++;
                    this.renderPresentSlide();
                }
            },

            prevPresentSlide() {
                if (this.presentSlide > 0) {
                    this.presentSlide--;
                    this.renderPresentSlide();
                }
            },

            exitPresent() {
                this.presenting = false;
                document.querySelector('.present-mode')?.remove();
                document.removeEventListener('keydown', this.presentKeyHandler);
            },

            // Design Functions
            showTemplates() {
                const modal = document.getElementById('templatesModal');
                const grid = document.getElementById('templatesGrid');
                
                // Define templates with actual content
                const templates = [
                    {
                        name: 'Title Slide',
                        bg: 'white',
                        elements: [
                            { type: 'text', content: 'Presentation Title', x: 480, y: 200, width: 400, height: 80, size: 48, color: '#1e293b', font: 'Arial', weight: 'bold', align: 'center' },
                            { type: 'text', content: 'Subtitle or Description', x: 480, y: 300, width: 400, height: 40, size: 24, color: '#64748b', font: 'Arial', align: 'center' }
                        ]
                    },
                    {
                        name: 'Bullet Points',
                        bg: 'white',
                        elements: [
                            { type: 'text', content: 'Main Topic', x: 100, y: 100, width: 600, height: 60, size: 36, color: '#1e293b', font: 'Arial', weight: 'bold' },
                            { type: 'text', content: ' First point', x: 120, y: 200, width: 700, height: 40, size: 24, color: '#475569', font: 'Arial' },
                            { type: 'text', content: ' Second point', x: 120, y: 260, width: 700, height: 40, size: 24, color: '#475569', font: 'Arial' },
                            { type: 'text', content: ' Third point', x: 120, y: 320, width: 700, height: 40, size: 24, color: '#475569', font: 'Arial' }
                        ]
                    },
                    {
                        name: 'Two Columns',
                        bg: 'white',
                        elements: [
                            { type: 'text', content: 'Column 1', x: 150, y: 100, width: 300, height: 50, size: 32, color: '#1e293b', font: 'Arial', weight: 'bold', align: 'center' },
                            { type: 'text', content: 'Content here...', x: 150, y: 180, width: 300, height: 200, size: 20, color: '#475569', font: 'Arial' },
                            { type: 'text', content: 'Column 2', x: 510, y: 100, width: 300, height: 50, size: 32, color: '#1e293b', font: 'Arial', weight: 'bold', align: 'center' },
                            { type: 'text', content: 'Content here...', x: 510, y: 180, width: 300, height: 200, size: 20, color: '#475569', font: 'Arial' }
                        ]
                    },
                    {
                        name: 'Image + Text',
                        bg: 'white',
                        elements: [
                            { type: 'text', content: 'Title', x: 480, y: 100, width: 400, height: 60, size: 40, color: '#1e293b', font: 'Arial', weight: 'bold', align: 'center' },
                            { type: 'text', content: 'Description text goes here', x: 480, y: 400, width: 600, height: 60, size: 20, color: '#64748b', font: 'Arial', align: 'center' }
                        ]
                    },
                    {
                        name: 'Quote',
                        bg: '#f8fafc',
                        elements: [
                            { type: 'text', content: '"', x: 100, y: 150, width: 100, height: 100, size: 80, color: '#10b981', font: 'Arial', weight: 'bold' },
                            { type: 'text', content: 'Inspirational quote text here', x: 200, y: 180, width: 600, height: 100, size: 28, color: '#1e293b', font: 'Arial', align: 'center', style: 'italic' },
                            { type: 'text', content: ' Author Name', x: 480, y: 320, width: 300, height: 40, size: 20, color: '#64748b', font: 'Arial', align: 'center' }
                        ]
                    },
                    {
                        name: 'Numbered List',
                        bg: 'white',
                        elements: [
                            { type: 'text', content: 'Topic Title', x: 100, y: 100, width: 600, height: 50, size: 36, color: '#1e293b', font: 'Arial', weight: 'bold' },
                            { type: 'text', content: '1. First item', x: 120, y: 200, width: 700, height: 40, size: 24, color: '#475569', font: 'Arial' },
                            { type: 'text', content: '2. Second item', x: 120, y: 260, width: 700, height: 40, size: 24, color: '#475569', font: 'Arial' },
                            { type: 'text', content: '3. Third item', x: 120, y: 320, width: 700, height: 40, size: 24, color: '#475569', font: 'Arial' }
                        ]
                    }
                ];
                
                grid.innerHTML = templates.map((t, idx) => `
                    <div class="bg-option" onclick="app.applyTemplate(${idx})" style="background: ${t.bg}; cursor: pointer; position: relative; border: 2px solid #e5e7eb;">
                        <div style="position: absolute; top: 8px; left: 8px; right: 8px; font-size: 12px; font-weight: 600; color: #1e293b; text-align: center; background: rgba(255,255,255,0.9); padding: 4px; border-radius: 4px;">${t.name}</div>
                    </div>
                `).join('');
                
                // Store templates for applyTemplate
                this.templatesList = templates;
                modal.classList.add('show');
            },

            applyTemplate(index) {
                if (!this.templatesList || !this.templatesList[index]) return;
                
                const template = this.templatesList[index];
                
                // Clear current slide
                this.data[this.curr].els = [];
                this.data[this.curr].bg = template.bg;
                
                // Add template elements
                template.elements.forEach(el => {
                    const id = Date.now() + Math.random();
                    const element = {
                        id: id,
                        type: el.type,
                        x: el.x,
                        y: el.y,
                        width: el.width,
                        height: el.height,
                        bg: el.bg || 'transparent',
                        color: el.color || '#000000',
                        font: el.font || 'Arial',
                        size: el.size || 24,
                        weight: el.weight || 'normal',
                        align: el.align || 'left',
                        content: el.content || '',
                        animation: 'none'
                    };
                    this.data[this.curr].els.push(element);
                });
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                this.closeModal('templatesModal');
                this.showNotification(`Template "${template.name}" applied!`, 'success');
            },

            showThemes() {
                const modal = document.getElementById('themesModal');
                const grid = document.getElementById('themesGrid');
                
                // Define themes (combinations of background and default colors)
                const themes = [
                    { name: 'Classic', bg: 'white', primary: '#1e293b', secondary: '#64748b' },
                    { name: 'Emerald', bg: '#f0fdf4', primary: '#10b981', secondary: '#059669' },
                    { name: 'Ocean', bg: '#f0f9ff', primary: '#0ea5e9', secondary: '#0284c7' },
                    { name: 'Sunset', bg: '#fff7ed', primary: '#f97316', secondary: '#ea580c' },
                    { name: 'Purple', bg: '#faf5ff', primary: '#a855f7', secondary: '#9333ea' },
                    { name: 'Rose', bg: '#fff1f2', primary: '#f43f5e', secondary: '#e11d48' },
                    { name: 'Dark', bg: '#1e293b', primary: '#f1f5f9', secondary: '#cbd5e1' },
                    { name: 'Nature', bg: '#f0fdf4', primary: '#22c55e', secondary: '#16a34a' },
                ];
                
                grid.innerHTML = themes.map(t => `
                    <div class="bg-option" onclick="app.applyTheme('${t.name}', '${t.bg}', '${t.primary}', '${t.secondary}')" style="background: ${t.bg}; cursor: pointer; position: relative; border: 2px solid ${t.primary};">
                        <div style="position: absolute; bottom: 8px; left: 8px; right: 8px; background: ${t.primary}; color: ${t.bg === '#1e293b' ? 'white' : 'white'}; padding: 6px; border-radius: 4px; font-size: 11px; text-align: center; font-weight: 600;">${t.name}</div>
                    </div>
                `).join('');
                
                modal.classList.add('show');
            },

            applyTheme(name, bg, primary, secondary) {
                // Apply background
                this.data[this.curr].bg = bg;
                
                // Apply theme colors to all elements
                this.data[this.curr].els.forEach(el => {
                    if (el.type === 'text') {
                        // Apply primary color to bold/large text, secondary to regular text
                        if (el.weight === 'bold' || (el.size && el.size > 30)) {
                            el.color = primary;
                        } else {
                            el.color = secondary;
                        }
                    } else if (el.type === 'shape') {
                        // Apply primary color to shapes
                        el.bg = primary;
                        el.border = secondary;
                    }
                });
                
                // Store theme colors for future use
                this.currentTheme = { name, bg, primary, secondary };
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                this.closeModal('themesModal');
                this.showNotification(`Theme "${name}" applied to all elements!`, 'success');
            },

            // Image Functions
            showStockPhotos() {
                this.showNotification('Stock Photos library coming soon!', 'warning');
            },

            removeBackground() {
                if (!this.sel) {
                    this.showNotification('Select an image first', 'warning');
                    return;
                }
                
                const data = this.data[this.curr].els.find(e => e.id == this.sel.dataset.id);
                if (!data || data.type !== 'image') {
                    this.showNotification('Selected element is not an image', 'warning');
                    return;
                }
                
                const img = this.sel.querySelector('img');
                if (!img) {
                    this.showNotification('Image not found', 'error');
                    return;
                }
                
                // Show loading notification
                this.showNotification('Removing background...', 'info');
                
                // Create a new image to load the source
                const sourceImg = new Image();
                sourceImg.crossOrigin = 'anonymous';
                sourceImg.onload = () => {
                    try {
                        // Create canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = sourceImg.width;
                        canvas.height = sourceImg.height;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw image on canvas
                        ctx.drawImage(sourceImg, 0, 0);
                        
                        // Get image data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const pixelData = imageData.data;
                        
                        // Remove background (white/light colors)
                        for (let i = 0; i < pixelData.length; i += 4) {
                            const r = pixelData[i];
                            const g = pixelData[i + 1];
                            const b = pixelData[i + 2];
                            const a = pixelData[i + 3];
                            
                            // Calculate brightness
                            const brightness = (r + g + b) / 3;
                            
                            // Remove white/light background (threshold: 240)
                            // Also check if it's near white (all RGB values are high)
                            if (brightness > 240 && r > 240 && g > 240 && b > 240) {
                                pixelData[i + 3] = 0; // Make transparent
                            }
                            // Remove very light colors (brightness > 250)
                            else if (brightness > 250) {
                                pixelData[i + 3] = 0;
                            }
                            // Remove pixels that are too similar to white
                            else if (Math.abs(r - g) < 10 && Math.abs(g - b) < 10 && Math.abs(r - b) < 10 && brightness > 200) {
                                pixelData[i + 3] = 0;
                            }
                        }
                        
                        // Put modified image data back
                        ctx.putImageData(imageData, 0, 0);
                        
                        // Convert canvas to data URL
                        const newSrc = canvas.toDataURL('image/png');
                        
                        // Update image source
                        img.src = newSrc;
                        data.src = newSrc;
                        
                        // Save state
                        this.saveState();
                        this.loadCanvas();
                        this.renderSlides();
                        
                        this.showNotification('Background removed successfully!', 'success');
                    } catch (error) {
                        console.error('Error removing background:', error);
                        this.showNotification('Failed to remove background', 'error');
                    }
                };
                
                sourceImg.onerror = () => {
                    this.showNotification('Failed to load image', 'error');
                };
                
                // Load the image
                sourceImg.src = data.src;
            },

            adjustImage() {
                if (!this.sel) {
                    this.showNotification('Select an image first', 'warning');
                    return;
                }
                this.showNotification('Image adjustment tools coming soon!', 'warning');
            },

            // Shape & Data Functions
            addChart(type) {
                const id = Date.now();
                const defaultData = this.getDefaultChartData(type || 'bar');
                
                // Smart positioning: Check existing elements
                const existingElements = this.data[this.curr].els || [];
                const hasChart = existingElements.some(el => el.type === 'chart');
                const hasImage = existingElements.some(el => el.type === 'image');
                
                // Professional layout: Chart always on RIGHT side
                let x, y, width, height;
                if (hasImage) {
                    // Image exists on left, place chart on RIGHT
                    x = 580;
                    y = 100;
                    width = 340;
                    height = 340;
                } else {
                    // No image, place chart on RIGHT
                    x = 580;
                    y = 100;
                    width = 340;
                    height = 340;
                }
                
                const chartData = {
                    id: id,
                    type: 'chart',
                    chartType: type || 'bar',
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    labels: defaultData.labels || [],
                    values: defaultData.values || [],
                    colors: defaultData.colors || []
                };
                
                this.data[this.curr].els.push(chartData);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Auto-select the new chart and ensure data is visible
                setTimeout(() => {
                    const elementEl = document.querySelector(`[data-id="${id}"]`);
                    if (elementEl) {
                        this.selectElement(elementEl);
                        // Force re-render properties panel to show data
                        setTimeout(() => {
                            const data = this.data[this.curr].els.find(e => e.id == id);
                            if (data) {
                                this.renderPropertiesPanel(data);
                            }
                        }, 50);
                    }
                }, 100);
            },

            getDefaultChartData(type) {
                switch(type) {
                    case 'bar':
                        return {
                            labels: ['Q1', 'Q2', 'Q3', 'Q4'],
                            values: [65, 59, 80, 81],
                            colors: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444']
                        };
                    case 'line':
                        return {
                            labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May'],
                            values: [12, 19, 15, 25, 22],
                            colors: ['#10b981']
                        };
                    case 'pie':
                        return {
                            labels: ['Red', 'Blue', 'Yellow', 'Green'],
                            values: [30, 25, 20, 25],
                            colors: ['#ef4444', '#3b82f6', '#f59e0b', '#10b981']
                        };
                    case 'flow':
                        return {
                            labels: ['Start', 'Process 1', 'Process 2', 'Decision', 'End'],
                            values: [1, 1, 1, 1, 1],
                            colors: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6']
                        };
                    default:
                        return { labels: [], values: [], colors: [] };
                }
            },

            // Organize elements in a slide to prevent overlaps
            organizeSlideElements(slide) {
                if (!slide || !slide.els || slide.els.length === 0) {
                    return;
                }
                
                const elements = slide.els;
                const images = elements.filter(el => el.type === 'image');
                const charts = elements.filter(el => el.type === 'chart');
                
                // Check if elements are overlapping or poorly positioned
                let needsReorganization = false;
                
                // Check for overlaps or elements outside bounds
                elements.forEach((el, idx) => {
                    if (el.x < 0 || el.x > 960 || el.y < 0 || el.y > 540) {
                        needsReorganization = true;
                    }
                    // Check overlap with other elements
                    for (let j = idx + 1; j < elements.length; j++) {
                        const other = elements[j];
                        if (el.x < other.x + (other.width || 0) && 
                            el.x + (el.width || 0) > other.x &&
                            el.y < other.y + (other.height || 0) && 
                            el.y + (el.height || 0) > other.y) {
                            needsReorganization = true;
                        }
                    }
                });
                
                if (!needsReorganization && images.length <= 1 && charts.length <= 1) {
                    // Already organized, just ensure proper positioning
                    images.forEach((img) => {
                        if (!img.x || img.x < 0 || img.x > 960) {
                            img.x = charts.length > 0 ? 30 : 580;
                            img.y = img.y || 100;
                            img.width = img.width || (charts.length > 0 ? 320 : 340);
                            img.height = img.height || 340;
                        }
                    });
                    
                    charts.forEach((chart) => {
                        if (!chart.x || chart.x < 0 || chart.x > 960) {
                            chart.x = 580;
                            chart.y = chart.y || 100;
                            chart.width = chart.width || 340;
                            chart.height = chart.height || 340;
                        }
                    });
                    return;
                }
                
                // Reorganize: Images on LEFT, Charts on RIGHT
                images.forEach((img, idx) => {
                    img.x = 30;
                    img.y = 100 + (idx * 360);
                    if (img.y + (img.height || 340) > 540) {
                        img.y = 100; // Reset if too low
                    }
                    img.width = charts.length > 0 ? 320 : 340;
                    if (!img.width || img.width < 100) img.width = charts.length > 0 ? 320 : 340;
                    img.height = img.height || 340;
                    if (!img.height || img.height < 100) img.height = 340;
                });
                
                charts.forEach((chart, idx) => {
                    chart.x = 580;
                    chart.y = 100 + (idx * 360);
                    if (chart.y + (chart.height || 340) > 540) {
                        chart.y = 100; // Reset if too low
                    }
                    chart.width = chart.width || 340;
                    if (!chart.width || chart.width < 100) chart.width = 340;
                    chart.height = chart.height || 340;
                    if (!chart.height || chart.height < 100) chart.height = 340;
                });
            },

            // Organize elements to prevent overlaps (manual trigger)
            organizeElements() {
                if (!this.data[this.curr] || !this.data[this.curr].els) {
                    return;
                }
                
                this.organizeSlideElements(this.data[this.curr]);
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                this.showNotification('Elements organized successfully');
            },

            addTable(rows, cols) {
                const id = Date.now();
                const tableData = {
                    id: id,
                    type: 'table',
                    rows: rows || 3,
                    cols: cols || 3,
                    x: 200,
                    y: 150,
                    width: 400,
                    height: 200,
                    data: this.createTableData(rows || 3, cols || 3)
                };
                
                this.data[this.curr].els.push(tableData);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Auto-select the new table
                setTimeout(() => {
                    const elementEl = document.querySelector(`[data-id="${id}"]`);
                    if (elementEl) this.selectElement(elementEl);
                }, 100);
            },

            createTableData(rows, cols) {
                const data = [];
                for (let r = 0; r < rows; r++) {
                    const row = [];
                    for (let c = 0; c < cols; c++) {
                        row.push(r === 0 ? `Header ${c + 1}` : `Cell ${r},${c}`);
                    }
                    data.push(row);
                }
                return data;
            },

            showSymbols(category) {
                // Create or show symbols modal
                let modal = document.getElementById('symbolsModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.className = 'modal';
                    modal.id = 'symbolsModal';
                    modal.innerHTML = `
                        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                            <span class="modal-close" onclick="app.closeModal('symbolsModal')"></span>
                            <div class="modal-header">Choose Symbol</div>
                            <div id="symbolsGrid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 12px; padding: 20px;">
                                <!-- Symbols will be loaded here -->
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }
                
                // Load symbols based on category
                const symbolsGrid = document.getElementById('symbolsGrid');
                const symbols = this.getSymbolsByCategory(category);
                
                symbolsGrid.innerHTML = '';
                symbols.forEach(symbol => {
                    const symbolDiv = document.createElement('div');
                    symbolDiv.className = 'bg-color-item';
                    symbolDiv.style.cssText = 'width: 100%; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 32px; cursor: pointer; border: 2px solid rgba(0, 0, 0, 0.1); border-radius: 8px; background: white; transition: all 0.2s;';
                    symbolDiv.textContent = symbol;
                    symbolDiv.onclick = () => {
                        this.addSymbol(symbol);
                        this.closeModal('symbolsModal');
                    };
                    symbolDiv.onmouseenter = () => {
                        symbolDiv.style.transform = 'scale(1.1)';
                        symbolDiv.style.borderColor = 'rgba(16, 185, 129, 0.5)';
                        symbolDiv.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
                    };
                    symbolDiv.onmouseleave = () => {
                        symbolDiv.style.transform = 'scale(1)';
                        symbolDiv.style.borderColor = 'rgba(0, 0, 0, 0.1)';
                        symbolDiv.style.boxShadow = 'none';
                    };
                    symbolsGrid.appendChild(symbolDiv);
                });
                
                modal.classList.add('show');
            },

            getSymbolsByCategory(category) {
                const symbolSets = {
                    arrows: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
                    shapes: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
                    symbols: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
                };
                return symbolSets[category] || symbolSets.symbols;
            },

            addSymbol(symbol) {
                const id = Date.now();
                const symbolData = {
                    id: id,
                    type: 'symbol',
                    symbol: symbol,
                    x: 200,
                    y: 150,
                    width: 100,
                    height: 100,
                    fontSize: 48,
                    color: '#000000'
                };
                
                this.data[this.curr].els.push(symbolData);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Auto-select the new symbol
                setTimeout(() => {
                    const elementEl = document.querySelector(`[data-id="${id}"]`);
                    if (elementEl) this.selectElement(elementEl);
                }, 100);
            },

            updateChartType(id, type) {
                const elementId = typeof id === 'string' ? parseInt(id) : id;
                const data = this.data[this.curr].els.find(e => e.id == elementId);
                if (!data || data.type !== 'chart') return;
                
                data.chartType = type;
                // Update data structure if needed
                if (!data.labels || data.labels.length === 0) {
                    const defaultData = this.getDefaultChartData(type);
                    data.labels = defaultData.labels;
                    data.values = defaultData.values;
                    data.colors = defaultData.colors;
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${elementId}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            updateChartData(id, field, index, value) {
                const elementId = typeof id === 'string' ? parseInt(id) : id;
                const data = this.data[this.curr].els.find(e => e.id == elementId);
                if (!data || data.type !== 'chart') return;
                
                if (field === 'label') {
                    if (!data.labels) data.labels = [];
                    data.labels[index] = value;
                } else if (field === 'value') {
                    if (!data.values) data.values = [];
                    data.values[index] = parseFloat(value) || 0;
                } else if (field === 'color') {
                    if (!data.colors) data.colors = [];
                    data.colors[index] = value;
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${elementId}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            addChartItem(id) {
                const elementId = typeof id === 'string' ? parseInt(id) : id;
                const data = this.data[this.curr].els.find(e => e.id == elementId);
                if (!data || data.type !== 'chart') return;
                
                if (!data.labels) data.labels = [];
                if (!data.values) data.values = [];
                if (!data.colors) data.colors = [];
                
                const defaultColors = ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
                const newIndex = data.labels.length;
                
                data.labels.push(`Item ${newIndex + 1}`);
                data.values.push(0);
                data.colors.push(defaultColors[newIndex % defaultColors.length]);
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${elementId}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            removeChartItem(id, index) {
                const elementId = typeof id === 'string' ? parseInt(id) : id;
                const data = this.data[this.curr].els.find(e => e.id == elementId);
                if (!data || data.type !== 'chart') return;
                
                if (data.labels && data.labels.length > index) {
                    data.labels.splice(index, 1);
                }
                if (data.values && data.values.length > index) {
                    data.values.splice(index, 1);
                }
                if (data.colors && data.colors.length > index) {
                    data.colors.splice(index, 1);
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${elementId}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            updateTableSize(id, dimension, value) {
                const elementId = typeof id === 'string' ? parseInt(id) : id;
                const data = this.data[this.curr].els.find(e => e.id == elementId);
                if (!data || data.type !== 'table') return;
                
                if (dimension === 'rows') {
                    data.rows = Math.max(1, Math.min(10, value));
                    // Adjust data array
                    while (data.data.length < data.rows) {
                        const newRow = [];
                        for (let c = 0; c < data.cols; c++) {
                            newRow.push(`Cell ${data.data.length + 1},${c + 1}`);
                        }
                        data.data.push(newRow);
                    }
                    while (data.data.length > data.rows) {
                        data.data.pop();
                    }
                } else if (dimension === 'cols') {
                    data.cols = Math.max(1, Math.min(10, value));
                    // Adjust data array
                    data.data.forEach((row, r) => {
                        while (row.length < data.cols) {
                            row.push(r === 0 ? `Header ${row.length + 1}` : `Cell ${r + 1},${row.length + 1}`);
                        }
                        while (row.length > data.cols) {
                            row.pop();
                        }
                    });
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${elementId}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            updateSymbolProperty(id, prop, value) {
                const elementId = typeof id === 'string' ? parseInt(id) : id;
                const data = this.data[this.curr].els.find(e => e.id == elementId);
                if (!data || data.type !== 'symbol') return;
                
                data[prop] = value;
                
                // Apply changes immediately
                if (this.sel && parseInt(this.sel.dataset.id) === elementId) {
                    if (prop === 'color') {
                        this.sel.style.color = value;
                    } else if (prop === 'fontSize') {
                        this.sel.style.fontSize = value + 'px';
                    }
                }
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                
                // Re-select to update properties panel
                setTimeout(() => {
                    const el = document.querySelector(`[data-id="${elementId}"]`);
                    if (el) this.selectElement(el);
                }, 50);
            },

            drawChart(ctx, type, chartData, width, height) {
                try {
                    ctx.clearRect(0, 0, width, height);
                    
                    // Convert old data format to new format if needed
                    if (chartData.data && chartData.data.datasets && !chartData.labels) {
                        const oldData = chartData.data;
                        chartData.labels = oldData.labels || [];
                        if (oldData.datasets && oldData.datasets[0]) {
                            chartData.values = oldData.datasets[0].data || [];
                            if (type === 'line') {
                                chartData.colors = [oldData.datasets[0].borderColor || '#10b981'];
                            } else {
                                chartData.colors = oldData.datasets[0].backgroundColor || [];
                            }
                        }
                    }
                    
                    // Ensure data arrays exist
                    if (!chartData.labels || chartData.labels.length === 0) {
                        const defaultData = this.getDefaultChartData(type || 'bar');
                        chartData.labels = defaultData.labels || [];
                        chartData.values = defaultData.values || [];
                        chartData.colors = defaultData.colors || [];
                    }
                    
                    const labels = chartData.labels || [];
                    const values = chartData.values || [];
                    const colors = chartData.colors || [];
                    
                    if (!labels || labels.length === 0 || !values || values.length === 0) {
                        ctx.fillStyle = '#9ca3af';
                        ctx.font = '14px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('No data', width / 2, height / 2);
                        return;
                    }
                    
                    const padding = 50;
                    const chartWidth = Math.max(100, width - (padding * 2));
                    const chartHeight = Math.max(100, height - (padding * 2));
                    
                    switch(type) {
                        case 'bar':
                            this.drawBarChart(ctx, labels, values, colors, padding, chartWidth, chartHeight, width, height);
                            break;
                        case 'line':
                            this.drawLineChart(ctx, labels, values, colors, padding, chartWidth, chartHeight, width, height);
                            break;
                        case 'pie':
                            this.drawPieChart(ctx, labels, values, colors, padding, chartWidth, chartHeight, width, height);
                            break;
                        case 'flow':
                            this.drawFlowChart(ctx, labels, values, colors, padding, chartWidth, chartHeight, width, height);
                            break;
                        default:
                            console.warn('Unknown chart type:', type);
                    }
                } catch (error) {
                    console.error('Error drawing chart:', error);
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '14px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Chart Error', width / 2, height / 2);
                }
            },

            drawBarChart(ctx, labels, values, colors, padding, width, height, canvasWidth, canvasHeight) {
                const maxValue = Math.max(...values, 1);
                const barWidth = Math.max(25, width / labels.length * 0.7);
                const spacing = width / labels.length;
                
                // Draw background grid - CLEAR and VISIBLE
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1.5;
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (height / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + width, y);
                    ctx.stroke();
                }
                
                // Draw Y-axis labels with values - CLEAR
                ctx.fillStyle = '#6b7280';
                ctx.font = 'bold 11px Inter, sans-serif';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (height / 4) * i;
                    const value = Math.round((maxValue / 4) * (4 - i));
                    ctx.fillText(value.toString(), padding - 8, y);
                }
                
                // Draw bars - CLEAR and BOLD
                labels.forEach((label, i) => {
                    if (i >= values.length) return;
                    
                    const value = values[i] || 0;
                    const barHeight = Math.max(3, (value / maxValue) * height);
                    const x = padding + (i * spacing) + (spacing - barWidth) / 2;
                    const y = padding + height - barHeight;
                    
                    // Draw bar with shadow for depth
                    const defaultColors = ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'];
                    const barColor = colors[i] || defaultColors[i % defaultColors.length];
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(x + 2, y + 2, barWidth, barHeight);
                    
                    // Bar
                    ctx.fillStyle = barColor;
                    ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // Border for clarity
                    ctx.strokeStyle = barColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, barWidth, barHeight);
                    
                    // Draw value on top - CLEAR and BOLD
                    if (barHeight > 25) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 13px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        // Add text shadow for readability
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.shadowBlur = 2;
                        ctx.shadowOffsetX = 1;
                        ctx.shadowOffsetY = 1;
                        ctx.fillText(value.toString(), x + barWidth / 2, y - 5);
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    // Draw label - CLEAR
                    ctx.fillStyle = '#1f2937';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    // Truncate long labels
                    const displayLabel = label.length > 10 ? label.substring(0, 8) + '..' : label;
                    ctx.fillText(displayLabel, padding + (i * spacing) + spacing / 2, padding + height + 12);
                });
            },

            drawLineChart(ctx, labels, values, colors, padding, width, height, canvasWidth, canvasHeight) {
                const maxValue = Math.max(...values, 1);
                const spacing = labels.length > 1 ? width / (labels.length - 1) : (width / 2);
                const color = colors[0] || '#10b981';
                const bgColor = color + '20';
                
                // Draw background grid - CLEAR and VISIBLE
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1.5;
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (height / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + width, y);
                    ctx.stroke();
                }
                
                // Draw Y-axis labels with values - CLEAR
                ctx.fillStyle = '#6b7280';
                ctx.font = 'bold 11px Inter, sans-serif';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (height / 4) * i;
                    const value = Math.round((maxValue / 4) * (4 - i));
                    ctx.fillText(value.toString(), padding - 8, y);
                }
                
                // Draw area under line
                ctx.fillStyle = bgColor;
                ctx.beginPath();
                ctx.moveTo(padding, padding + height);
                
                values.forEach((value, i) => {
                    const x = padding + (i * spacing);
                    const y = padding + height - (value / maxValue) * height;
                    ctx.lineTo(x, y);
                });
                
                ctx.lineTo(padding + width, padding + height);
                ctx.closePath();
                ctx.fill();
                
                // Draw line - CLEAR and BOLD
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.beginPath();
                
                values.forEach((value, i) => {
                    const x = padding + (i * spacing);
                    const y = padding + height - (value / maxValue) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw points - CLEAR and VISIBLE
                values.forEach((value, i) => {
                    const x = padding + (i * spacing);
                    const y = padding + height - (value / maxValue) * height;
                    
                    // Outer circle (shadow)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(x, y, 7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner circle (point)
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White border for clarity
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw value - CLEAR and BOLD
                    ctx.fillStyle = '#1f2937';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    // Add text shadow for readability
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 3;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.fillText(value.toString(), x, y - 10);
                    ctx.shadowBlur = 0;
                });
                
                // Draw labels - CLEAR
                labels.forEach((label, i) => {
                    const x = padding + (i * spacing);
                    ctx.fillStyle = '#1f2937';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    // Truncate long labels
                    const displayLabel = label.length > 10 ? label.substring(0, 8) + '..' : label;
                    ctx.fillText(displayLabel, x, padding + height + 12);
                });
            },

            drawPieChart(ctx, labels, values, colors, padding, width, height, canvasWidth, canvasHeight) {
                const centerX = padding + width / 2;
                const centerY = padding + height / 2;
                const radius = Math.min(width, height) / 2 - 25;
                const total = values.reduce((a, b) => a + b, 0);
                
                if (total === 0) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = 'bold 14px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data', canvasWidth / 2, canvasHeight / 2);
                    return;
                }
                
                let currentAngle = -Math.PI / 2;
                const defaultColors = ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'];
                
                // Draw pie slices - CLEAR with borders
                values.forEach((value, i) => {
                    if (value <= 0) return;
                    
                    const sliceAngle = (value / total) * Math.PI * 2;
                    const color = colors[i] || defaultColors[i % defaultColors.length];
                    
                    // Shadow for depth
                    ctx.save();
                    ctx.translate(2, 2);
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fill();
                    ctx.restore();
                    
                    // Main slice
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                    
                    // Draw border - CLEAR and VISIBLE
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    // Draw label and percentage - CLEAR
                    if (sliceAngle > 0.2) {
                        const labelAngle = currentAngle + sliceAngle / 2;
                        const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                        const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                        
                        const percentage = Math.round((value / total) * 100);
                        const labelText = (labels[i] || `Item ${i + 1}`).length > 12 
                            ? (labels[i] || `Item ${i + 1}`).substring(0, 10) + '..' 
                            : (labels[i] || `Item ${i + 1}`);
                        const percentText = `${percentage}%`;
                        
                        // Background for text
                        const textWidth = Math.max(
                            ctx.measureText(labelText).width,
                            ctx.measureText(percentText).width
                        ) + 10;
                        const textHeight = 32;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                        ctx.fillRect(labelX - textWidth / 2, labelY - textHeight / 2, textWidth, textHeight);
                        
                        // Label text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 11px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(labelText, labelX, labelY - 6);
                        
                        // Percentage text
                        ctx.font = 'bold 12px Inter, sans-serif';
                        ctx.fillText(percentText, labelX, labelY + 8);
                    }
                    
                    currentAngle += sliceAngle;
                });
            },

            drawFlowChart(ctx, labels, values, colors, padding, width, height, canvasWidth, canvasHeight) {
                if (!labels || labels.length === 0) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = 'bold 14px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data', canvasWidth / 2, canvasHeight / 2);
                    return;
                }

                // Professional flow chart layout - FITS WITHIN CANVAS
                // Determine layout: simple linear or multi-column based on node count
                const nodeCount = labels.length;
                const useMultiColumn = nodeCount > 5;
                
                // Node dimensions - optimized to fit within available space
                // Canvas size: width x height (typically 320x380 for Flow Chart)
                const maxNodeWidth = Math.min(140, (width - padding * 2 - (nodeCount > 1 ? (nodeCount - 1) * 30 : 0)) / nodeCount);
                const nodeWidth = Math.max(100, maxNodeWidth);
                const nodeHeight = 65;
                const nodeSpacing = 30;
                const rowSpacing = 90;
                const borderRadius = 12;
                
                // Professional color palette
                const solidColors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#14b8a6'];

                // Helper function to draw rounded rectangle
                const drawRoundedRect = (x, y, w, h, radius) => {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + w - radius, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
                    ctx.lineTo(x + w, y + h - radius);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                    ctx.lineTo(x + radius, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                };
                
                // Helper function to draw arrow
                const drawArrow = (x1, y1, x2, y2, color = '#6b7280', width = 3) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = width;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    // Arrow head
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const arrowLength = 15;
                    const arrowAngle = Math.PI / 6;
                    
                    ctx.beginPath();
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(
                        x2 - arrowLength * Math.cos(angle - arrowAngle),
                        y2 - arrowLength * Math.sin(angle - arrowAngle)
                    );
                    ctx.lineTo(
                        x2 - arrowLength * Math.cos(angle + arrowAngle),
                        y2 - arrowLength * Math.sin(angle + arrowAngle)
                    );
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                };
                
                // Calculate node positions - Smart layout that FITS
                const nodesPerRow = useMultiColumn ? Math.min(4, Math.ceil(Math.sqrt(nodeCount * 1.5))) : nodeCount;
                const rows = useMultiColumn ? Math.ceil(nodeCount / nodesPerRow) : 1;
                const availableWidth = width - (padding * 2);
                const availableHeight = height - (padding * 2);
                
                // Ensure everything fits
                const totalNodeWidth = nodesPerRow * nodeWidth + (nodesPerRow - 1) * nodeSpacing;
                const totalNodeHeight = rows * nodeHeight + (rows - 1) * rowSpacing;
                
                // Scale down if too large
                let scale = 1;
                if (totalNodeWidth > availableWidth) {
                    scale = Math.min(scale, availableWidth / totalNodeWidth);
                }
                if (totalNodeHeight > availableHeight) {
                    scale = Math.min(scale, availableHeight / totalNodeHeight);
                }
                
                const scaledNodeWidth = nodeWidth * scale;
                const scaledNodeHeight = nodeHeight * scale;
                const scaledNodeSpacing = nodeSpacing * scale;
                const scaledRowSpacing = rowSpacing * scale;
                
                const finalTotalWidth = nodesPerRow * scaledNodeWidth + (nodesPerRow - 1) * scaledNodeSpacing;
                const finalTotalHeight = rows * scaledNodeHeight + (rows - 1) * scaledRowSpacing;
                
                const startX = padding + (availableWidth - finalTotalWidth) / 2;
                const startY = padding + (availableHeight - finalTotalHeight) / 2;
                
                // Store node positions for arrow drawing
                const nodePositions = [];
                
                // Draw flow chart nodes
                labels.forEach((label, i) => {
                    const row = useMultiColumn ? Math.floor(i / nodesPerRow) : 0;
                    const col = useMultiColumn ? (i % nodesPerRow) : i;
                    const nodeX = startX + col * (scaledNodeWidth + scaledNodeSpacing);
                    const nodeY = startY + row * (scaledNodeHeight + scaledRowSpacing);
                    const color = solidColors[i % solidColors.length];
                    
                    nodePositions.push({ 
                        x: nodeX, 
                        y: nodeY, 
                        centerX: nodeX + scaledNodeWidth / 2, 
                        centerY: nodeY + scaledNodeHeight / 2,
                        rightX: nodeX + scaledNodeWidth,
                        bottomY: nodeY + scaledNodeHeight,
                        row: row,
                        col: col,
                        width: scaledNodeWidth,
                        height: scaledNodeHeight
                    });

                    // Draw node shadow first
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 4;

                    const currentNode = nodePositions[i];
                    const currentWidth = currentNode.width;
                    const currentHeight = currentNode.height;
                    
                    // Draw rounded rectangle node with gradient effect
                    drawRoundedRect(nodeX, nodeY, currentWidth, currentHeight, borderRadius);
                    
                    // Fill with solid color (gradient simulation)
                    ctx.fillStyle = color;
                    ctx.fill();

                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    // Node border with subtle highlight
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    drawRoundedRect(nodeX, nodeY, currentWidth, currentHeight, borderRadius);
                    ctx.stroke();

                    // Add inner highlight for depth
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    drawRoundedRect(nodeX + 1, nodeY + 1, currentWidth - 2, currentHeight - 2, borderRadius - 1);
                    ctx.stroke();

                    // Node label with better typography - SHORT and CLEAR
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Truncate label to fit - MAX 3-4 words or 40 characters
                    let displayLabel = label;
                    const words = label.split(' ');
                    if (words.length > 4) {
                        displayLabel = words.slice(0, 4).join(' ') + '...';
                    } else if (label.length > 40) {
                        displayLabel = label.substring(0, 37) + '...';
                    }
                    
                    // Word wrap for labels - MAX 2 lines
                    const maxWidth = currentWidth - 20;
                    const labelWords = displayLabel.split(' ');
                    let line1 = '';
                    let line2 = '';
                    let currentLine = '';
                    
                    labelWords.forEach((word, idx) => {
                        const testLine = currentLine + (currentLine ? ' ' : '') + word;
                        const metrics = ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth && currentLine) {
                            if (!line1) {
                                line1 = currentLine;
                                currentLine = word;
                            } else if (!line2) {
                                line2 = currentLine;
                                currentLine = '';
                            }
                        } else {
                            currentLine = testLine;
                        }
                    });
                    
                    if (!line1) line1 = currentLine;
                    else if (!line2 && currentLine) line2 = currentLine;
                    
                    // Draw text - center vertically
                    const textY = nodeY + currentHeight / 2;
                    if (line2) {
                        ctx.fillText(line1, nodeX + currentWidth / 2, textY - 9);
                        ctx.fillText(line2, nodeX + currentWidth / 2, textY + 9);
                    } else {
                        ctx.fillText(line1, nodeX + currentWidth / 2, textY);
                    }

                    // Add step number badge - scaled
                    const badgeSize = 12 * scale;
                    const badgeX = nodeX + 15 * scale;
                    const badgeY = nodeY + 15 * scale;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(badgeX, badgeY, badgeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Badge border for better visibility
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `bold ${Math.max(10, 11 * scale)}px Inter, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText((i + 1).toString(), badgeX, badgeY);
                });
                
                // Draw arrows between nodes - Smart connection logic
                nodePositions.forEach((node, i) => {
                    if (i === 0) return; // Skip first node
                    
                    const prevNode = nodePositions[i - 1];
                    let arrowStartX, arrowStartY, arrowEndX, arrowEndY;
                    
                    if (useMultiColumn) {
                        // Multi-column: connect based on row/column position
                        if (node.row === prevNode.row) {
                            // Same row: horizontal arrow
                            arrowStartX = prevNode.rightX;
                            arrowStartY = prevNode.centerY;
                            arrowEndX = node.x;
                            arrowEndY = node.centerY;
                            drawArrow(arrowStartX, arrowStartY, arrowEndX, arrowEndY, '#6b7280', 2.5);
                        } else {
                            // Different row: vertical then horizontal
                            // First go down from previous node
                            const midX = prevNode.centerX;
                            const midY = prevNode.bottomY + scaledRowSpacing / 2;
                            arrowStartX = prevNode.centerX;
                            arrowStartY = prevNode.bottomY;
                            arrowEndX = midX;
                            arrowEndY = midY;
                            drawArrow(arrowStartX, arrowStartY, arrowEndX, arrowEndY, '#6b7280', 2.5);
                            // Then horizontal to new node
                            arrowStartX = midX;
                            arrowStartY = midY;
                            arrowEndX = node.centerX;
                            arrowEndY = midY;
                            drawArrow(arrowStartX, arrowStartY, arrowEndX, arrowEndY, '#6b7280', 2.5);
                            // Then down to center
                            arrowStartX = node.centerX;
                            arrowStartY = midY;
                            arrowEndX = node.centerX;
                            arrowEndY = node.centerY;
                            drawArrow(arrowStartX, arrowStartY, arrowEndX, arrowEndY, '#6b7280', 2.5);
                        }
                    } else {
                        // Simple horizontal flow
                        arrowStartX = prevNode.rightX;
                        arrowStartY = prevNode.centerY;
                        arrowEndX = node.x;
                        arrowEndY = node.centerY;
                        drawArrow(arrowStartX, arrowStartY, arrowEndX, arrowEndY, '#6b7280', 2.5);
                    }
                });
            },

            // Arrange Functions
            groupElements() {
                if (!this.sel) {
                    this.showNotification('Select elements to group', 'warning');
                    return;
                }
                this.showNotification('Group feature coming soon!', 'warning');
            },

            ungroupElements() {
                if (!this.sel) {
                    this.showNotification('Select a group to ungroup', 'warning');
                    return;
                }
                this.showNotification('Ungroup feature coming soon!', 'warning');
            },

            alignElements(align) {
                if (!this.sel) {
                    this.showNotification('Select elements to align', 'warning');
                    return;
                }
                this.showNotification(`Align ${align} feature coming soon!`, 'warning');
            },

            // Effects Functions
            showTransitions() {
                const modal = document.getElementById('transModal');
                if (!modal) {
                    // Create transitions modal
                    const transModal = document.createElement('div');
                    transModal.className = 'modal';
                    transModal.id = 'transModal';
                    transModal.innerHTML = `
                        <div class="modal-content">
                            <span class="modal-close" onclick="app.closeModal('transModal')"></span>
                            <div class="modal-header">Choose Slide Transition</div>
                            <div class="animation-grid">
                                <div class="animation-option" onclick="app.applyTransition('fade')">Fade</div>
                                <div class="animation-option" onclick="app.applyTransition('slide')">Slide</div>
                                <div class="animation-option" onclick="app.applyTransition('zoom')">Zoom</div>
                                <div class="animation-option" onclick="app.applyTransition('none')">None</div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(transModal);
                }
                document.getElementById('transModal').classList.add('show');
            },

            applyTransition(transition) {
                this.data[this.curr].transition = transition;
                this.saveState();
                this.closeModal('transModal');
                this.showNotification(`Transition "${transition}" applied!`);
            },

            toggleDropdown(id) {
                const dropdown = document.getElementById(id);
                if (!dropdown) return;
                
                // Close all other dropdowns
                document.querySelectorAll('.category-dropdown').forEach(dd => {
                    if (dd.id !== id) {
                        dd.classList.remove('show');
                    }
                });
                
                // Toggle current dropdown
                dropdown.classList.toggle('show');
                
                // If opening bgColorDropdown, update transparency values
                if (id === 'bgColorDropdown' && dropdown.classList.contains('show')) {
                    const transparency = this.data[this.curr].transparency || 0;
                    const slider = document.getElementById('bgTransparencySlider');
                    const input = document.getElementById('bgTransparencyInput');
                    if (slider) slider.value = transparency;
                    if (input) input.value = transparency;
                }
            },

            closeDropdown(id) {
                const dropdown = document.getElementById(id);
                if (dropdown) {
                    dropdown.classList.remove('show');
                }
            },

            closeModal(id) {
                document.getElementById(id).classList.remove('show');
            },

            // Zoom Functions
            setZoom(value) {
                this.zoom = parseInt(value);
                document.getElementById('zoomValue').textContent = this.zoom + '%';
                document.getElementById('canvasWrapper').style.transform = `scale(${this.zoom / 100})`;
            },

            zoomIn() {
                const slider = document.getElementById('zoomSlider');
                const newValue = Math.min(200, this.zoom + 10);
                slider.value = newValue;
                this.setZoom(newValue);
            },

            zoomOut() {
                const slider = document.getElementById('zoomSlider');
                const newValue = Math.max(25, this.zoom - 10);
                slider.value = newValue;
                this.setZoom(newValue);
            },

            resetZoom() {
                document.getElementById('zoomSlider').value = 100;
                this.setZoom(100);
            },

            // AI Assistant Functions
            getOpenAIKey() {
                // Get API key from localStorage or use placeholder
                const newApiKey = localStorage.getItem('openai_api_key') || 'YOUR_OPENAI_API_KEY_HERE';
                
                // Always use the new API key and save it to localStorage
                localStorage.setItem('openai_api_key', newApiKey);
                
                return newApiKey;
            },
            aiLanguage: 'en', // Default to English
            aiPendingActions: null,
            aiPendingSlidesCount: null,
            aiConversationHistory: [], // Store conversation history for context

            toggleAIPanel() {
                const sidebar = document.getElementById('aiSidebar');
                const container = document.querySelector('.container');
                if (sidebar) {
                    sidebar.classList.toggle('visible');
                    if (container) {
                        container.classList.toggle('ai-sidebar-open');
                    }
                    if (sidebar.classList.contains('visible')) {
                        // Set default language to English
                        if (!this.aiLanguage) {
                            this.aiLanguage = 'en';
                            // Auto-select English button
                            const enBtn = document.querySelector('.ai-lang-btn[onclick*="en"]');
                            if (enBtn) {
                                enBtn.style.background = '#0369a1';
                                enBtn.style.color = 'white';
                                enBtn.style.borderColor = '#0369a1';
                            }
                        }
                        // Don't reset conversation history - keep it for context
                        // Only reset pending actions
                        this.aiPendingActions = null;
                        this.aiPendingSlidesCount = null;
                        setTimeout(() => {
                            const input = document.getElementById('aiChatInput');
                            if (input) input.focus();
                        }, 100);
                    }
                }
            },

            setAILanguage(lang) {
                this.aiLanguage = lang;
                const langButtons = document.querySelectorAll('.ai-lang-btn');
                langButtons.forEach(btn => {
                    btn.style.background = 'white';
                    btn.style.borderColor = '#bae6fd';
                    btn.style.color = '#0369a1';
                });
                if (event && event.target) {
                    event.target.style.background = '#0369a1';
                    event.target.style.color = 'white';
                    event.target.style.borderColor = '#0369a1';
                }
                
                if (lang === 'ar') {
                    this.addChatMessage('  .    ', 'assistant');
                    const input = document.getElementById('aiChatInput');
                    if (input) input.placeholder = '  ... (:  3    )';
                } else {
                    this.addChatMessage('English selected. How can I help you today?', 'assistant');
                    const input = document.getElementById('aiChatInput');
                    if (input) input.placeholder = 'Type your request here... (e.g., Add 3 slides about technology)';
                }
            },

            async sendAIMessage() {
                const input = document.getElementById('aiChatInput');
                const message = input.value.trim();
                if (!message) return;

                // Default to English if not set
                if (!this.aiLanguage) {
                    this.aiLanguage = 'en';
                }

                // Add user message to chat and conversation history
                this.addChatMessage(message, 'user');
                this.aiConversationHistory.push({ role: 'user', content: message });
                input.value = '';
                
                // Log user request for debugging
                const presentationTitle = document.getElementById('title')?.value || '';
                console.log(' User Request:', {
                    message,
                    presentationTitle,
                    currentSlides: this.data.length,
                    language: this.aiLanguage
                });

                // Show loading
                const loadingEl = document.getElementById('aiLoading');
                const loadingText = document.getElementById('aiLoadingText');
                if (loadingEl) loadingEl.style.display = 'block';
                if (loadingText) loadingText.textContent = this.aiLanguage === 'ar' ? ' ...' : 'Processing...';

                try {
                    // Get first slide style as reference
                    const firstSlide = this.data[0] || { els: [], bg: 'white', transition: 'fade' };
                    const firstSlideStyle = {
                        bg: firstSlide.bg || 'white',
                        elements: firstSlide.els || []
                    };
                    
                    // Extract style patterns from first slide
                    let titleStyle = { size: 42, color: '#0f172a', weight: 'bold', align: 'center', font: 'Arial' };
                    let contentStyle = { size: 24, color: '#374151', align: 'left', font: 'Arial' };
                    
                    // Find title and content elements in first slide
                    firstSlideStyle.elements.forEach(el => {
                        if (el.type === 'text') {
                            if (el.weight === 'bold' && el.size >= 36) {
                                titleStyle = { size: el.size, color: el.color, weight: el.weight, align: el.align, font: el.font || 'Arial' };
                            } else {
                                contentStyle = { size: el.size, color: el.color, align: el.align, font: el.font || 'Arial' };
                            }
                        }
                    });
                    
                    // Get current presentation state
                    const currentState = {
                        slides: this.data,
                        currentSlide: this.curr,
                        title: document.getElementById('title')?.value || 'Untitled Presentation',
                        totalSlides: this.data.length,
                        firstSlideStyle: firstSlideStyle,
                        titleStyle: titleStyle,
                        contentStyle: contentStyle
                    };

                    // Check if asking about number of slides
                    const slidesCountMatch = message.match(/(\d+)\s*(?:|slide|slides)/i);
                    if (slidesCountMatch && !this.aiPendingSlidesCount) {
                        this.aiPendingSlidesCount = parseInt(slidesCountMatch[1]);
                    }

                    // Prepare system message based on language (using the same comprehensive prompt from editor-ad.html)
                    const systemMessage = this.aiLanguage === 'ar' ? 
                        `     . :
1.    (      )
2.     
3.     -       "modify_slide"  slide: [ ]
4.   

     :
1.        
2.  preview   
3.   

 :    .    " "  " "  " "  ""                   .

    JSON  ( markdown  ).   {   }. JSON    :
{
  "actions": [
    {"type": "add_slide", "title": " ", "bg": "white", "elements": [{"type": "text", "content": "", "x": 100, "y": 100, "width": 300, "height": 50, "size": 24, "color": "#000000"}]},
    {"type": "add_chart", "slide": 0, "chartType": "bar", "labels": ["A", "B", "C"], "values": [10, 20, 30], "x": 200, "y": 200, "width": 400, "height": 300}
  ],
  "preview": "   ",
  "slidesCount": 3,
  "message": " 3   .   "
}

    .` :
                        `You are a PROFESSIONAL presentation design assistant. Create DETAILED, COMPREHENSIVE, and RICH content slides with VARIED content formats.

CRITICAL - READ THIS FIRST:
You MUST respond with VALID JSON ONLY. No markdown code blocks, no explanations, no text before or after.
Your ENTIRE response must be a valid JSON object that starts with { and ends with }.
Example of correct response:
{"actions":[...],"preview":"...","message":"..."}

DO NOT use markdown formatting like \`\`\`json\`\`\`.
DO NOT add any text before or after the JSON.
JUST return the raw JSON object.

CONTENT QUALITY REQUIREMENTS - CRITICAL:
- When user provides a title or topic, you MUST generate comprehensive, detailed, factual content about that topic
- Each slide MUST have substantial content: minimum 150-200 words of meaningful, relevant information
- Include real facts, statistics, examples, and practical information related to the topic
- Content must be SPECIFIC to the topic - generic content is NOT acceptable
- If user says "create slides about X" or provides a title "X", generate detailed slides about X with real information

SLIDE CANVAS: 960px  540px

IMPORTANT RULES:
1. USE VARIED CONTENT FORMATS - Mix different text styles:
   - Regular paragraphs (descriptive text, explanations) - Keep 2-3 sentences max
   - Bullet points ( for lists of items) - 3-5 points max, each point brief
   - Numbered lists (1. 2. 3. for steps or sequences) - 3-5 items max
   - Don't use only bullet points - vary the format!
2. KEEP CONTENT FITTING - Content must fit within slide boundaries (height max 300px, NOT 350px)
3. CONCISE CONTENT - CRITICAL: Maximum 400 characters per text element. Each sentence max 20 words. Each bullet max 12 words. Keep it VERY short and readable
4. MODIFY EXISTING SLIDES - You can modify ANY existing slide using "modify_slide" with slide: [index]. When user asks to modify/edit, check existing slides and modify them instead of creating new ones.
5. DO NOT duplicate the title - use EITHER action.title OR a title element in elements array, NOT both
6. ALWAYS use the SAME background color as the first slide (check firstSlideStyle.bg in currentState)
7. ALWAYS use the SAME text styles as the first slide:
   - Title: Use titleStyle from currentState (size, color, weight, align, font)
   - Content: Use contentStyle from currentState (size, color, align, font)
8. Use proper coordinates within canvas bounds (0-960 width, 0-540 height)
9. DON'T OVERLAP ELEMENTS - CRITICAL: If adding an image, ensure text doesn't overlap with it:
   - If image is on RIGHT side (x: 550-600): Text should be on LEFT (x: 120-150, width: 400-450 max)
   - If image is on LEFT side (x: 120-150): Text should be on RIGHT (x: 550-600, width: 400-450 max)
   - If image is at TOP (y: 180-220): Text should be BELOW image (y: 400+)
   - If image is at BOTTOM (y: 320+): Text should be ABOVE image (y: 180-250)
   - Always leave proper spacing between text and image (at least 20px gap)
10. Match the visual style and formatting of the existing first slide
11. CONTENT LENGTH: Maximum 3-5 bullet points OR 1-2 very short paragraphs per slide. Total text per element: MAX 400 characters. Each sentence: MAX 20 words. Each bullet: MAX 12 words.
12. IMAGE PLACEMENT: When adding images, use standard positions:
    - Right side: x: 550-600, y: 180-200, width: 280-320, height: 200-240
    - Left side: x: 120-150, y: 180-200, width: 280-320, height: 200-240
    - Adjust text position accordingly to avoid overlap

ELEMENT SPECIFICATIONS:

TITLE (REQUIRED - choose ONE method):
- Option A: Use action.title field (REQUIRED - always include this for every slide)
- Option B: Include in elements array with: type:"text", size:36-42, weight:"bold", align:"center", x:130, y:60, width:700, height:80

CRITICAL: Every slide MUST have a title. Always use action.title field for every add_slide action.

CONTENT TEXT - USE VARIED FORMATS (IMPORTANT!):
You MUST use different text formats, not only bullet points. Keep content FIT WITHIN the slide - don't make it too long!

SLIDE DIMENSIONS: 960px  540px
TEXT AREA: Typically 450-550px width, 300-350px height (y: 180-200)

CONTENT GUIDELINES - STRICT LENGTH LIMITS:
1. Regular paragraphs (2-3 sentences MAX, 150-200 characters total):
   - content: "Brief paragraph. Keep it very short. Maximum 2 sentences only."
   - Example: "AI transforms work. Machines learn and decide."
   - NEVER exceed 250 characters for a paragraph

2. Bullet points (3-5 points max, each point 8-12 words MAX):
   - content: " Short point\\n Another point\\n Final point"
   - Each point: Maximum 12 words, 60 characters
   - Total bullet content: Maximum 300 characters

3. Numbered lists (3-5 items max, each item 8-12 words):
   - content: "1. First step\\n2. Second step\\n3. Third step"
   - Each step: Maximum 12 words

4. Mixed content (keep VERY short):
   - content: "Brief intro (1 sentence).\\n\\n Point 1\\n Point 2\\n Point 3"
   - Total content: Maximum 400 characters including all text

CRITICAL RULES - ENFORCE STRICTLY:
- MAXIMUM content length: 400 characters per text element
- Keep content CONCISE - fit within slide boundaries
- Maximum 3-5 bullet points OR 1-2 very short paragraphs
- Don't exceed height: 300px for text elements (not 350px!)
- Each sentence: Maximum 20 words
- Each bullet point: Maximum 12 words
- Vary formats but keep content SHORT and readable
- x: 120-150
- y: 180-200
- width: 400-500 (reduce if image present)
- height: 200-300 (NEVER exceed 300px)
- size: 22-26
- color: "#374151"
- align: "left"

IMAGES:
- type: "image"
- imageUrl: Search term (e.g., "technology", "business", "team", "alexa")
- Standard positions:
  * RIGHT side: x: 550-600, y: 180-200, width: 280-320, height: 200-240
  * LEFT side: x: 120-150, y: 180-200, width: 280-320, height: 200-240
- CRITICAL: When adding image, adjust text position to avoid overlap:
  * If image on RIGHT: Text should be on LEFT (x: 120-150, width: 400-450 max)
  * If image on LEFT: Text should be on RIGHT (x: 550-600, width: 400-450 max)
  * Always leave 20px gap between text and image

CHARTS:
- type: "chart"
- chartType: "bar", "line", or "pie"
- labels: ["Label1", "Label2", "Label3"]
- values: [value1, value2, value3]
- colors: ["#10b981", "#3b82f6", "#f59e0b"]
- x: 250-300
- y: 250-280
- width: 400-450
- height: 220-250

RESPONSE FORMAT (JSON ONLY):
{
  "actions": [
    {
      "type": "modify_slide",
      "slide": 0,
      "elements": [
        {"type": "text", "content": "Main Presentation Title", "x": 130, "y": 60, "width": 700, "height": 80, "size": 42, "color": "#0f172a", "weight": "bold", "align": "center"}
      ]
    },
    {
      "type": "add_slide",
      "title": "Introduction to Topic",
      "bg": "white",
      "elements": [
        {"type": "text", "content": "Brief introduction explaining the topic. This provides essential context.\\n\\n Key feature one\\n Key feature two\\n Key feature three", "x": 120, "y": 180, "width": 500, "height": 300, "size": 24, "color": "#374151", "align": "left"},
        {"type": "image", "imageUrl": "topic", "x": 550, "y": 180, "width": 300, "height": 220}
      ]
    }
  ],
  "preview": "Creating slides",
  "slidesCount": 3,
  "message": "Creating slides..."
}

ACTION TYPES:
- "add_slide": Add a new slide
- "modify_slide": Modify existing slide (use slide: [index] for any slide - 0 for first, 1 for second, etc.)
- "add_text": Add text to specific slide
- "add_image": Add image to specific slide
- "add_chart": Add chart to specific slide

IMPORTANT: When user asks to "modify", "edit", "change", or "update", use "modify_slide" to edit existing slides instead of creating new ones. Check currentState.slides to see existing slides and their indices.

REMEMBER: Always use bg: "white" for all slides. Never use colored backgrounds.`;

                    // Build messages array with conversation history
                    const messages = [
                        {
                            role: 'system',
                            content: systemMessage
                        }
                    ];

                    // Add conversation history (last 5 messages only to avoid token limit)
                    const recentHistory = this.aiConversationHistory.slice(-5);
                    recentHistory.forEach(msg => {
                        if (msg.role === 'user' || (msg.role === 'assistant' && msg.content.length < 500)) {
                            messages.push(msg);
                        }
                    });

                    // Add current state and user request (simplified to save tokens)
                    const simplifiedState = {
                        totalSlides: currentState.totalSlides,
                        currentSlide: currentState.curr,
                        title: currentState.title,
                        firstSlideStyle: {
                            bg: currentState.firstSlideStyle?.bg || 'white',
                            titleStyle: currentState.titleStyle,
                            contentStyle: currentState.contentStyle
                        }
                    };
                    
                    // Enhanced user request with presentation title context
                    const presentationTitle = document.getElementById('title')?.value || '';
                    const userRequestContent = presentationTitle && presentationTitle.trim() 
                        ? `Presentation Title: "${presentationTitle}". Current slides: ${simplifiedState.totalSlides}. Style: ${JSON.stringify(simplifiedState.firstSlideStyle)}. User Request: ${message}${this.aiPendingSlidesCount ? ` (Create ${this.aiPendingSlidesCount} slides)` : ''}. IMPORTANT: Generate comprehensive, detailed content about "${presentationTitle}" - include real facts, statistics, examples, and practical information. Each slide must have substantial content (minimum 150-200 words of meaningful information).`
                        : `Presentation: ${simplifiedState.totalSlides} slides. Style: ${JSON.stringify(simplifiedState.firstSlideStyle)}. Request: ${message}${this.aiPendingSlidesCount ? ` (${this.aiPendingSlidesCount} slides)` : ''}`;
                    
                    const currentRequest = {
                        role: 'user',
                        content: userRequestContent
                    };
                    messages.push(currentRequest);
                    
                    console.log(' Sending request to OpenAI:', {
                        presentationTitle,
                        message,
                        slidesCount: this.aiPendingSlidesCount,
                        totalSlides: simplifiedState.totalSlides
                    });

                    // Call OpenAI API
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.getOpenAIKey()}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4',
                            messages: messages,
                            temperature: 0.7,
                            max_tokens: 2000
                        })
                    });

                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error.message || (this.aiLanguage === 'ar' ? '  API' : 'API Error'));
                    }

                    const aiResponse = data.choices[0].message.content;
                    console.log(' AI Response received (first 500 chars):', aiResponse.substring(0, 500));
                    
                    // Try to parse JSON from response
                    let actions = null;
                    let preview = null;
                    let slidesCount = null;
                    let responseMessage = aiResponse;
                    
                    try {
                        // First, try to parse the response directly as JSON (since we're using response_format: json_object)
                        try {
                            const directParsed = JSON.parse(aiResponse);
                            console.log(' Direct JSON parse successful');
                            if (directParsed.actions && Array.isArray(directParsed.actions)) {
                                actions = directParsed.actions;
                                preview = directParsed.preview;
                                slidesCount = directParsed.slidesCount;
                                responseMessage = directParsed.message || aiResponse;
                                console.log(' Extracted', actions.length, 'actions from direct parse');
                            }
                        } catch (directError) {
                            console.log(' Direct parse failed, trying other methods...');
                            
                            // Try multiple methods to extract JSON
                            const codeBlockMatch = aiResponse.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                            if (codeBlockMatch) {
                                console.log(' Found JSON in code block');
                                const parsed = JSON.parse(codeBlockMatch[1]);
                                console.log(' Parsed JSON:', parsed);
                                if (parsed.actions) {
                                    actions = parsed.actions;
                                    preview = parsed.preview;
                                    slidesCount = parsed.slidesCount;
                                    responseMessage = parsed.message || aiResponse;
                                    console.log(' Extracted', actions.length, 'actions');
                                }
                            } else {
                                // Try to find JSON object (more flexible matching - look for any JSON with "actions")
                                let jsonMatch = aiResponse.match(/\{[\s\S]*"actions"[\s\S]*\}/);
                                
                                // If not found, try to find any JSON object
                                if (!jsonMatch) {
                                    jsonMatch = aiResponse.match(/\{[\s\S]{10,}\}/);
                                }
                                
                                if (jsonMatch) {
                                    console.log(' Found JSON object in response');
                                    try {
                                        // Try to parse the matched JSON
                                        let jsonStr = jsonMatch[0];
                                        
                                        // Try to balance braces if needed
                                        const openBraces = (jsonStr.match(/\{/g) || []).length;
                                        const closeBraces = (jsonStr.match(/\}/g) || []).length;
                                        
                                        if (closeBraces < openBraces) {
                                            // Add missing closing braces
                                            jsonStr += '}'.repeat(openBraces - closeBraces);
                                        }
                                        
                                        const parsed = JSON.parse(jsonStr);
                                        console.log(' Parsed JSON:', parsed);
                                        
                                        if (parsed.actions && Array.isArray(parsed.actions)) {
                                            actions = parsed.actions;
                                            preview = parsed.preview;
                                            slidesCount = parsed.slidesCount;
                                            responseMessage = parsed.message || aiResponse;
                                            console.log(' Extracted', actions.length, 'actions');
                                        } else {
                                            console.warn(' No actions array found in parsed JSON');
                                            console.warn('Parsed object keys:', Object.keys(parsed));
                                        }
                                    } catch (parseError) {
                                        console.error(' JSON parse error:', parseError);
                                        console.error('Failed to parse:', jsonMatch[0].substring(0, 300));
                                        
                                        // Try to extract actions manually from text
                                        const actionsMatch = aiResponse.match(/"actions"\s*:\s*\[([\s\S]*?)\]/);
                                        if (actionsMatch) {
                                            console.log(' Trying to extract actions manually...');
                                            try {
                                                const actionsStr = '[' + actionsMatch[1] + ']';
                                                const extractedActions = JSON.parse(actionsStr);
                                                if (Array.isArray(extractedActions) && extractedActions.length > 0) {
                                                    actions = extractedActions;
                                                    console.log(' Manually extracted', actions.length, 'actions');
                                                }
                                            } catch (e) {
                                                console.error(' Failed to extract actions manually:', e);
                                            }
                                        }
                                    }
                                } else {
                                    console.warn(' No JSON found in AI response');
                                    console.log('Response preview:', aiResponse.substring(0, 300));
                                }
                            }
                        }
                    } catch (e) {
                        console.error(' Could not parse JSON:', e);
                        console.log('Response was:', aiResponse.substring(0, 300));
                    }
                    
                    console.log(' Final actions:', actions ? `${actions.length} actions` : 'null');
                    
                    if (!actions || !Array.isArray(actions) || actions.length === 0) {
                        console.error(' CRITICAL: No valid actions found!');
                        console.error('AI Response:', aiResponse);
                        console.error('Parsed actions:', actions);
                    }

                    // Add AI response to conversation history
                    this.aiConversationHistory.push({ role: 'assistant', content: aiResponse });

                    // If we have actions, execute them automatically (like editor-ad.html)
                    if (actions && Array.isArray(actions) && actions.length > 0) {
                        console.log(' Executing', actions.length, 'actions');
                        console.log('Actions details:', JSON.stringify(actions, null, 2));
                        
                        // Show message first
                        this.addChatMessage(responseMessage || (this.aiLanguage === 'ar' ? '  ...' : 'Creating slides...'), 'assistant');
                        
                        try {
                            // Execute actions automatically
                            await this.executeAIActions(actions);
                            
                            // Show success message
                            const slidesCount = actions.filter(a => a.type === 'add_slide').length;
                            const successMsg = this.aiLanguage === 'ar' ? 
                                `   ${slidesCount} ${slidesCount > 1 ? '' : ''} !` : 
                                ` Successfully created ${slidesCount} slide${slidesCount > 1 ? 's' : ''}!`;
                            this.addChatMessage(successMsg, 'assistant');
                        } catch (execError) {
                            console.error(' Error executing actions:', execError);
                            const errorMsg = this.aiLanguage === 'ar' ? 
                                `    : ${execError.message}` : 
                                ` Error during execution: ${execError.message}`;
                            this.addChatMessage(errorMsg, 'assistant');
                        }
                    } else {
                        console.warn(' No actions to execute. AI response:', responseMessage.substring(0, 200));
                        console.warn(' Full AI response:', aiResponse);
                        
                        // Try fallback: Use replaceSlidesWithAIGeneration if user provided a title/topic
                        const presentationTitle = document.getElementById('title')?.value || '';
                        const userMessageLower = message.toLowerCase();
                        const isCreatingSlides = /(create|make|generate|add|build).*(slide|presentation|deck)/i.test(message) || 
                                                 /(|||).*(||)/i.test(message);
                        
                        if ((presentationTitle && presentationTitle.trim()) || isCreatingSlides) {
                            console.log(' Attempting fallback: Using replaceSlidesWithAIGeneration');
                            try {
                                // Extract slide count from message if available
                                const slideCountMatch = message.match(/(\d+)\s*(?:|slide|slides)/i);
                                const slideCount = slideCountMatch ? parseInt(slideCountMatch[1]) : (this.aiPendingSlidesCount || 5);
                                
                                const titleToUse = presentationTitle || message.replace(/(create|make|generate|add|build||||).*(slide|presentation|deck|||)/i, '').trim() || 'AI Presentation';
                                
                                this.addChatMessage(this.aiLanguage === 'ar' ? 
                                    `   ${slideCount}   "${titleToUse}"...` : 
                                    ` Creating ${slideCount} slides about "${titleToUse}"...`, 'assistant');
                                
                                // Use the existing AI generation function
                                if (typeof replaceSlidesWithAIGeneration === 'function') {
                                    await replaceSlidesWithAIGeneration(
                                        { title: titleToUse, description: '', slideCount: slideCount },
                                        { silent: false }
                                    );
                                    
                                    this.addChatMessage(this.aiLanguage === 'ar' ? 
                                        `   ${slideCount}  !` : 
                                        ` Successfully created ${slideCount} slides!`, 'assistant');
                                } else {
                                    throw new Error('replaceSlidesWithAIGeneration function not found');
                                }
                            } catch (fallbackError) {
                                console.error(' Fallback generation failed:', fallbackError);
                                this.addChatMessage(this.aiLanguage === 'ar' ? 
                                    `  : ${fallbackError.message}` : 
                                    ` Error: ${fallbackError.message}`, 'assistant');
                                
                                // Add AI response to chat
                                this.addChatMessage(responseMessage || aiResponse.substring(0, 200), 'assistant');
                                
                                // Show helpful message
                                const helpMsg = this.aiLanguage === 'ar' ? 
                                    '      .       Console (F12)  .' : 
                                    ' No valid commands found. Please try again or open Console (F12) to see details.';
                                this.addChatMessage(helpMsg, 'assistant');
                            }
                        } else {
                            // Add AI response to chat
                            this.addChatMessage(responseMessage || aiResponse.substring(0, 200), 'assistant');
                            
                            // Show helpful message
                            const helpMsg = this.aiLanguage === 'ar' ? 
                                '      .       Console (F12)  .' : 
                                ' No valid commands found. Please try again or open Console (F12) to see details.';
                            this.addChatMessage(helpMsg, 'assistant');
                            
                            // If asking about slides count, wait for user response
                            if (responseMessage.includes('') || responseMessage.includes('how many') || responseMessage.includes('How many')) {
                                // User will respond with number
                            }
                        }
                    }

                } catch (error) {
                    console.error('AI Error:', error);
                    const errorMsg = this.aiLanguage === 'ar' ? 
                        `  : ${error.message}` : 
                        `Sorry, an error occurred: ${error.message}`;
                    this.addChatMessage(errorMsg, 'assistant');
                } finally {
                    if (loadingEl) loadingEl.style.display = 'none';
                }
            },

            showAIPreview(actions, previewText) {
                const previewContainer = document.getElementById('aiPreviewContainer');
                if (!previewContainer) return;
                previewContainer.style.display = 'block';
                
                const slidesToAdd = actions.filter(a => a.type === 'add_slide').length;
                const totalSlides = this.data.length + slidesToAdd;
                
                let elementsCount = 0;
                actions.forEach(action => {
                    if (action.elements) {
                        elementsCount += action.elements.length;
                    } else if (action.type !== 'add_slide' && action.type !== 'set_slide_bg' && action.type !== 'switch_slide' && action.type !== 'delete_slide') {
                        elementsCount++;
                    }
                });
                
                const previewHTML = `
                    <div class="ai-message ai-assistant">
                        <div class="ai-message-content" style="background: #fef3c7; border: 2px solid #f59e0b;">
                            <div style="font-weight: 600; margin-bottom: 8px; color: #92400e;"> ${this.aiLanguage === 'ar' ? ' ' : 'Content Preview'}</div>
                            <div style="color: #78350f; margin-bottom: 12px; line-height: 1.6;">${previewText}</div>
                            <div style="padding: 12px; background: white; border-radius: 8px; margin-top: 12px; border: 1px solid #fbbf24;">
                                <div style="font-weight: 600; margin-bottom: 8px; color: #78350f;">${this.aiLanguage === 'ar' ? ':' : 'Details:'}</div>
                                <div style="color: #92400e; font-size: 13px; line-height: 1.8;">
                                    ${this.aiLanguage === 'ar' ? 
                                        `   ${slidesToAdd} ${slidesToAdd > 1 ? '' : ''}<br>
                                            : ${totalSlides}<br>
                                             : ${elementsCount + slidesToAdd}` :
                                        ` Will add ${slidesToAdd} slide${slidesToAdd > 1 ? 's' : ''}<br>
                                         Total slides after addition: ${totalSlides}<br>
                                         Number of elements to be added: ${elementsCount + slidesToAdd}`}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; margin-top: 16px;">
                                <button onclick="app.confirmAIActions()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                    ${this.aiLanguage === 'ar' ? '  ' : ' Confirm & Execute'}
                                </button>
                                <button onclick="app.cancelAIPreview()" style="flex: 1; padding: 12px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; border-radius: 8px; font-weight: 600; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                    ${this.aiLanguage === 'ar' ? ' ' : ' Cancel'}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                previewContainer.innerHTML = previewHTML;
                
                setTimeout(() => {
                    previewContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            },

            async confirmAIActions() {
                if (this.aiPendingActions) {
                    // Show loading message
                    const loadingMsg = this.aiLanguage === 'ar' ? 
                        '   ...' : 
                        ' Executing commands...';
                    this.addChatMessage(loadingMsg, 'assistant');
                    
                    // Execute actions
                    await this.executeAIActions(this.aiPendingActions);
                    this.cancelAIPreview();
                    
                    // Show success message
                    const slidesCount = this.aiPendingActions.filter(a => a.type === 'add_slide').length;
                    const confirmMsg = this.aiLanguage === 'ar' ? 
                        `   ${slidesCount} ${slidesCount > 1 ? '' : ''} !` : 
                        ` Successfully created ${slidesCount} slide${slidesCount > 1 ? 's' : ''}!`;
                    this.addChatMessage(confirmMsg, 'assistant');
                    this.aiConversationHistory.push({ role: 'assistant', content: confirmMsg });
                    
                    // Clear pending actions
                    this.aiPendingActions = null;
                }
            },

            cancelAIPreview() {
                const previewContainer = document.getElementById('aiPreviewContainer');
                if (previewContainer) {
                    previewContainer.style.display = 'none';
                    previewContainer.innerHTML = '';
                }
                this.aiPendingActions = null;
                this.aiPendingSlidesCount = null;
            },

            addChatMessage(message, type) {
                const messagesContainer = document.getElementById('aiChatMessages');
                if (!messagesContainer) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${type === 'user' ? 'user' : 'ai-assistant'}`;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'ai-message-content';
                
                if (type === 'assistant') {
                    const header = document.createElement('div');
                    header.style.cssText = 'font-weight: 600; margin-bottom: 4px; color: #10b981;';
                    header.textContent = 'AI Assistant';
                    contentDiv.appendChild(header);
                }
                
                const textDiv = document.createElement('div');
                textDiv.textContent = message;
                contentDiv.appendChild(textDiv);
                
                messageDiv.appendChild(contentDiv);
                messagesContainer.appendChild(messageDiv);
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            },

            async executeAIActions(actions) {
                console.log(' Starting to execute AI actions:', actions.length, 'actions');
                
                for (const action of actions) {
                    try {
                        console.log(' Processing action:', action.type, action);
                        
                        switch (action.type) {
                            case 'add_slide':
                                console.log(' Adding new slide with AI format...');
                                
                                // Create AI-style slide using createAISlideObject
                                const slideTitle = action.title || `Slide ${this.data.length + 1}`;
                                
                                // Extract description from elements - CRITICAL: Ensure substantial content
                                let slideDescription = '';
                                if (action.elements && Array.isArray(action.elements)) {
                                    const textElements = action.elements.filter(el => el.type === 'text' && el.content);
                                    if (textElements.length > 0) {
                                        // Combine all text content, preserving structure
                                        slideDescription = textElements
                                            .map(el => el.content)
                                            .filter(content => content && content.trim() && content !== slideTitle) // Exclude title
                                            .join('\n\n');
                                    }
                                }
                                
                                // Get presentation title for better context (declare once at the start)
                                const presentationTitle = document.getElementById('title')?.value || 'Presentation';
                                
                                // If no description or too short, create comprehensive one from title and presentation context
                                if (!slideDescription || slideDescription.trim().length < 100) {
                                    const contextText = presentationTitle ? `about ${presentationTitle}` : '';
                                    slideDescription = `${slideTitle} ${contextText ? `is a crucial component of ${presentationTitle}` : 'represents a key aspect of this presentation'}. This slide provides comprehensive insights into ${slideTitle}, including its definition, core principles, practical applications, and strategic importance. Understanding ${slideTitle} is essential for making informed decisions and achieving desired outcomes. We will explore the fundamental concepts, real-world examples, industry best practices, and actionable strategies related to ${slideTitle}. This includes examining current trends, challenges, opportunities, and future prospects in this domain.`;
                                    console.log(` Slide "${slideTitle}" had insufficient content. Generated comprehensive fallback (${slideDescription.length} chars).`);
                                }
                                
                                console.log(` Slide "${slideTitle}": Description length = ${slideDescription.length} characters`);
                                
                                // Create context for the slide (same format as buildSubjectContext)
                                const slideContext = {
                                    subjectTitle: presentationTitle,
                                    subjectKeyword: slideTitle.toLowerCase().replace(/\s+/g, '-'),
                                    subjectLower: slideTitle.toLowerCase(),
                                    description: slideDescription,
                                    descriptionSentence: slideDescription.substring(0, 200),
                                    raw: presentationTitle
                                };
                                
                                // Get design from first slide if it's an AI slide, otherwise use default
                                let slideDesign = {
                                    background: 'gradient-dark',
                                    showTitle: true,
                                    showDescription: true,
                                    showBadge: true,
                                    showSlideNumber: true,
                                    layoutPosition: 'center'
                                };
                                
                                if (this.data[0] && this.data[0].variant === 'ai' && this.data[0].design) {
                                    slideDesign = { ...this.data[0].design };
                                }
                                
                                // Create AI slide data
                                const aiSlideData = {
                                    title: slideTitle,
                                    description: slideDescription,
                                    summary: slideDescription,
                                    notes: '',
                                    design: slideDesign
                                };
                                
                                const totalSlides = this.data.length + 1;
                                const newSlideIndex = this.data.length;
                                
                                // Create AI slide object with proper context
                                const aiSlideObject = createAISlideObject(aiSlideData, newSlideIndex, totalSlides, slideContext);
                                
                                // Add elements (images, charts) to the slide
                                const slideElements = [];
                                if (action.elements && Array.isArray(action.elements)) {
                                    console.log(' Processing', action.elements.length, 'elements');
                                    for (let idx = 0; idx < action.elements.length; idx++) {
                                        const element = action.elements[idx];
                                        console.log('   Element', idx + 1, ':', element.type);
                                        
                                        if (element.type === 'image') {
                                            let imageUrl = element.imageUrl || element.src;
                                            
                                            if (typeof imageUrl === 'string' && !imageUrl.startsWith('http')) {
                                                imageUrl = await this.getImageFromUnsplash(imageUrl);
                                            }
                                            
                                            if (imageUrl) {
                                                slideElements.push({
                                                    id: `image-${Date.now()}-${idx}`,
                                                    type: 'image',
                                                    src: imageUrl,
                                                    x: element.x || 30,
                                                    y: element.y || 100,
                                                    width: element.width || 320,
                                                    height: element.height || 340
                                                });
                                            }
                                        } else if (element.type === 'chart') {
                                            slideElements.push({
                                                id: `chart-${Date.now()}-${idx}`,
                                                type: 'chart',
                                                chartType: element.chartType || 'bar',
                                                labels: element.labels || [],
                                                values: element.values || [],
                                                colors: element.colors || ['#10b981', '#3b82f6', '#f59e0b'],
                                                x: element.x || 580,
                                                y: element.y || 100,
                                                width: element.width || 340,
                                                height: element.height || 340
                                            });
                                        }
                                    }
                                }
                                
                                // Create the slide with AI format
                                const newSlide = {
                                    els: slideElements,
                                    bg: 'white',
                                    transition: 'fade',
                                    variant: 'ai',
                                    title: aiSlideObject.title,
                                    description: aiSlideObject.description,
                                    summary: aiSlideObject.summary,
                                    notes: aiSlideObject.notes,
                                    design: aiSlideObject.design,
                                    stageHtml: aiSlideObject.stageHtml,
                                    previewHtml: aiSlideObject.previewHtml
                                };
                                
                                this.data.push(newSlide);
                                console.log(' AI slide created at index:', newSlideIndex);
                                break;

                            case 'modify_slide':
                                const modifySlideIndex = action.slide !== undefined ? action.slide : 0;
                                if (this.data[modifySlideIndex]) {
                                    if (action.elements && Array.isArray(action.elements)) {
                                        for (let idx = 0; idx < action.elements.length; idx++) {
                                            const element = action.elements[idx];
                                            await new Promise(resolve => setTimeout(resolve, 100 * (idx + 1)));
                                            
                                            if (element.type === 'text') {
                                                const firstSlide = this.data[0] || { els: [] };
                                                let defaultStyle = { size: 24, color: '#374151', weight: 'normal', align: 'left', font: 'Arial' };
                                                
                                                firstSlide.els.forEach(el => {
                                                    if (el.type === 'text') {
                                                        defaultStyle = {
                                                            size: el.size || 24,
                                                            color: el.color || '#374151',
                                                            weight: el.weight || 'normal',
                                                            align: el.align || 'left',
                                                            font: el.font || 'Arial'
                                                        };
                                                    }
                                                });
                                                
                                                this.addTextElement(modifySlideIndex, {
                                                    content: element.content || 'New text',
                                                    x: element.x || 130,
                                                    y: element.y || 60,
                                                    width: element.width || 700,
                                                    height: element.height || 80,
                                                    size: element.size || defaultStyle.size,
                                                    color: element.color || defaultStyle.color,
                                                    weight: element.weight || defaultStyle.weight || 'normal',
                                                    align: element.align || defaultStyle.align,
                                                    font: element.font || defaultStyle.font
                                                });
                                            } else if (element.type === 'image') {
                                                let imageUrl = element.imageUrl || element.src;
                                                if (typeof imageUrl === 'string' && !imageUrl.startsWith('http')) {
                                                    imageUrl = await this.getImageFromUnsplash(imageUrl);
                                                }
                                                
                                                const imageX = element.x || 550;
                                                const imageY = element.y || 180;
                                                const imageWidth = element.width || 300;
                                                const imageHeight = element.height || 220;
                                                
                                                const slideElements = this.data[modifySlideIndex].els || [];
                                                slideElements.forEach(existingEl => {
                                                    if (existingEl.type === 'text' && !existingEl.weight) {
                                                        const textRight = existingEl.x + existingEl.width;
                                                        const textBottom = existingEl.y + existingEl.height;
                                                        const imageRight = imageX + imageWidth;
                                                        const imageBottom = imageY + imageHeight;
                                                        
                                                        const horizontalOverlap = (existingEl.x < imageRight && textRight > imageX);
                                                        const verticalOverlap = (existingEl.y < imageBottom && textBottom > imageY);
                                                        
                                                        if (horizontalOverlap && verticalOverlap) {
                                                            if (imageX >= 500) {
                                                                const newWidth = Math.max(200, imageX - existingEl.x - 20);
                                                                existingEl.width = newWidth;
                                                                this.saveState();
                                                            } else if (imageX <= 200) {
                                                                existingEl.x = imageRight + 20;
                                                                existingEl.width = Math.min(existingEl.width, 960 - existingEl.x - 20);
                                                                this.saveState();
                                                            }
                                                        }
                                                    }
                                                });
                                                
                                                if (imageUrl) {
                                                    this.addImageElement(modifySlideIndex, {
                                                        src: imageUrl,
                                                        x: imageX,
                                                        y: imageY,
                                                        width: imageWidth,
                                                        height: imageHeight
                                                    });
                                                }
                                            } else if (element.type === 'chart') {
                                                this.addChartElement(modifySlideIndex, {
                                                    chartType: element.chartType || 'bar',
                                                    labels: element.labels || [],
                                                    values: element.values || [],
                                                    colors: element.colors || ['#10b981', '#3b82f6', '#f59e0b'],
                                                    x: element.x || 250,
                                                    y: element.y || 250,
                                                    width: element.width || 450,
                                                    height: element.height || 250
                                                });
                                            }
                                        }
                                    }
                                }
                                break;

                            case 'add_text':
                                const slideIndex = action.slide !== undefined ? action.slide : this.curr;
                                this.addTextElement(slideIndex, {
                                    content: action.content || 'New text',
                                    x: action.x || 100,
                                    y: action.y || 100,
                                    width: action.width || 300,
                                    height: action.height || 50,
                                    size: action.size || 24,
                                    color: action.color || '#000000',
                                    weight: action.weight || 'normal',
                                    align: action.align || 'left',
                                    font: action.font || 'Arial'
                                });
                                break;

                            case 'add_chart':
                                const chartSlideIndex = action.slide !== undefined ? action.slide : this.curr;
                                this.addChartElement(chartSlideIndex, {
                                    chartType: action.chartType || 'bar',
                                    labels: action.labels || ['A', 'B', 'C'],
                                    values: action.values || [10, 20, 30],
                                    colors: action.colors || ['#10b981', '#3b82f6', '#f59e0b'],
                                    x: action.x || 200,
                                    y: action.y || 200,
                                    width: action.width || 400,
                                    height: action.height || 300
                                });
                                break;

                            case 'set_slide_bg':
                                const bgSlideIndex = action.slide !== undefined ? action.slide : this.curr;
                                if (this.data[bgSlideIndex]) {
                                    this.data[bgSlideIndex].bg = action.bg || 'white';
                                    this.saveState();
                                    this.loadCanvas();
                                }
                                break;

                            case 'switch_slide':
                                if (action.slide !== undefined && this.data[action.slide]) {
                                    this.switchSlide(action.slide);
                                }
                                break;

                            case 'delete_slide':
                                if (action.slide !== undefined && this.data[action.slide]) {
                                    this.deleteSlide(action.slide);
                                }
                                break;
                        }
                    } catch (error) {
                        console.error(' Error executing action:', action, error);
                        console.error('Error stack:', error.stack);
                    }
                }
                
                console.log(' All actions executed. Saving state and rendering...');
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
                console.log(' Execution complete!');
            },

            async getImageFromUnsplash(searchTerm) {
                try {
                    console.log(' Getting image for:', searchTerm);
                    
                    // Try DALL-E first (if available)
                    try {
                        const imageUrl = await this.generateImageWithDALLE(searchTerm);
                        if (imageUrl) {
                            console.log(' DALL-E image generated successfully');
                            return imageUrl;
                        }
                    } catch (dalleError) {
                        console.warn(' DALL-E generation failed, using Picsum:', dalleError);
                    }
                    
                    // Use Picsum Photos as reliable fallback (always works)
                    const picsumId = Math.floor(Math.random() * 1000) + 1;
                    const picsumUrl = `https://picsum.photos/960/540?random=${picsumId}`;
                    console.log(' Using Picsum Photos:', picsumUrl);
                    return picsumUrl;
                } catch (error) {
                    console.error(' Error fetching image:', error);
                    // Final fallback - gradient placeholder
                    const colors = ['10b981', '14b8a6', '38bdf8', '0ea5e9', '3b82f6', '059669', '0284c7', '0891b2'];
                    const seed = searchTerm ? searchTerm.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) : 0;
                    const colorIndex = seed % colors.length;
                    const color = colors[colorIndex];
                    return `https://via.placeholder.com/960/540/${color}/ffffff?text=${encodeURIComponent((searchTerm || 'Image').substring(0, 20))}`;
                }
            },

            async generateImageWithDALLE(prompt) {
                try {
                    const imagePrompt = `Professional, clean, modern presentation image about: ${prompt}. Suitable for business presentation, high quality, no text.`;
                    
                    const response = await fetch('https://api.openai.com/v1/images/generations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.getOpenAIKey()}`
                        },
                        body: JSON.stringify({
                            model: 'dall-e-3',
                            prompt: imagePrompt,
                            n: 1,
                            size: '1024x1024',
                            quality: 'standard'
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('DALL-E API error:', errorData);
                        return null;
                    }

                    const data = await response.json();
                    if (data.data && data.data[0] && data.data[0].url) {
                        const imageUrl = data.data[0].url;
                        
                        // Fix CORS issue: Use CORS proxy for Azure Blob Storage URLs
                        // This allows images to load even from file:// origin
                        try {
                            // Use a reliable CORS proxy
                            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;
                            console.log(` Using CORS proxy for DALL-E image: ${proxyUrl.substring(0, 80)}...`);
                            return proxyUrl;
                        } catch (fetchError) {
                            console.warn(` CORS proxy setup failed, trying alternative:`, fetchError);
                            // Try alternative proxy
                            try {
                                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(imageUrl)}`;
                                return proxyUrl;
                            } catch (e) {
                                // Final fallback - return original URL
                                console.warn(` All CORS proxies failed, returning original URL`);
                                return imageUrl;
                            }
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.error('Error generating image with DALL-E:', error);
                    return null;
                }
            },

            addTextElement(slideIndex, options) {
                if (!this.data[slideIndex]) {
                    console.error('Slide index does not exist:', slideIndex);
                    return;
                }
                
                let content = options.content || 'New text';
                
                // Convert escaped newlines to actual newlines
                if (typeof content === 'string') {
                    content = content.replace(/\\n/g, '\n');
                }
                
                const fontSize = options.size || 24;
                const width = options.width || 300;
                const maxHeight = 300;
                
                const charsPerLine = Math.floor(width / (fontSize * 0.6));
                const lineHeight = fontSize * 1.4;
                const maxLines = Math.floor(maxHeight / lineHeight);
                const maxChars = charsPerLine * maxLines;
                
                if (content.length > maxChars) {
                    const truncated = content.substring(0, maxChars - 10);
                    const lastSpace = truncated.lastIndexOf(' ');
                    if (lastSpace > maxChars * 0.7) {
                        content = truncated.substring(0, lastSpace) + '...';
                    } else {
                        content = truncated + '...';
                    }
                }
                
                let calculatedHeight = options.height || 50;
                if (content) {
                    // Count actual newlines (both \n and escaped \n)
                    const actualLines = content.split('\n').length;
                    const estimatedLines = Math.ceil(content.length / charsPerLine);
                    const totalLines = Math.max(actualLines, estimatedLines);
                    const minHeight = Math.max(50, totalLines * lineHeight + 20);
                    calculatedHeight = Math.min(minHeight, maxHeight);
                }
                
                const textEl = {
                    id: 'text-' + Date.now() + '-' + Math.random(),
                    type: 'text',
                    content: content,
                    x: options.x || 100,
                    y: options.y || 100,
                    width: width,
                    height: calculatedHeight,
                    size: fontSize,
                    color: options.color || '#000000',
                    weight: options.weight || 'normal',
                    align: options.align || 'left',
                    font: options.font || 'Arial'
                };
                
                if (!this.data[slideIndex].els) {
                    this.data[slideIndex].els = [];
                }
                this.data[slideIndex].els.push(textEl);
                
                console.log(' Added text element to slide', slideIndex, ':', {
                    content: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                    x: textEl.x,
                    y: textEl.y,
                    width: textEl.width,
                    height: textEl.height
                });
                
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
            },

            addChartElement(slideIndex, options) {
                if (!this.data[slideIndex]) return;
                
                const chartEl = {
                    id: 'chart-' + Date.now() + '-' + Math.random(),
                    type: 'chart',
                    chartType: options.chartType || 'bar',
                    labels: options.labels || ['A', 'B', 'C'],
                    values: options.values || [10, 20, 30],
                    colors: options.colors || ['#10b981', '#3b82f6', '#f59e0b'],
                    x: options.x || 200,
                    y: options.y || 200,
                    width: options.width || 400,
                    height: options.height || 300
                };
                
                if (!this.data[slideIndex].els) {
                    this.data[slideIndex].els = [];
                }
                this.data[slideIndex].els.push(chartEl);
                this.saveState();
                this.loadCanvas();
                this.renderSlides();
            },

            addImageElement(slideIndex, options) {
                if (!this.data[slideIndex]) {
                    console.error('Slide index does not exist:', slideIndex);
                    return;
                }
                
                if (!options.src || options.src.trim() === '') {
                    console.warn('No image src provided, using placeholder');
                    options.src = `https://via.placeholder.com/${options.width || 300}x${options.height || 200}/10b981/ffffff?text=Image`;
                }
                
                console.log('Adding image element to slide', slideIndex, 'with src:', options.src);
                
                const imageX = options.x || 150;
                const imageY = options.y || 100;
                const imageWidth = options.width || 300;
                const imageHeight = options.height || 200;
                const imageRight = imageX + imageWidth;
                const imageBottom = imageY + imageHeight;
                
                const slideElements = this.data[slideIndex].els || [];
                let needsSave = false;
                
                slideElements.forEach(existingEl => {
                    if (existingEl.type === 'text' && !existingEl.weight) {
                        const textRight = existingEl.x + existingEl.width;
                        const textBottom = existingEl.y + existingEl.height;
                        
                        const horizontalOverlap = (existingEl.x < imageRight && textRight > imageX);
                        const verticalOverlap = (existingEl.y < imageBottom && textBottom > imageY);
                        
                        if (horizontalOverlap && verticalOverlap) {
                            if (imageX >= 500) {
                                const newWidth = Math.max(200, imageX - existingEl.x - 20);
                                existingEl.width = newWidth;
                                needsSave = true;
                            } else if (imageX <= 200) {
                                existingEl.x = imageRight + 20;
                                existingEl.width = Math.min(existingEl.width, 960 - existingEl.x - 20);
                                needsSave = true;
                            }
                        }
                    }
                });
                
                const imageEl = {
                    id: 'image-' + Date.now() + '-' + Math.random(),
                    type: 'image',
                    src: options.src,
                    x: imageX,
                    y: imageY,
                    width: imageWidth,
                    height: imageHeight
                };
                
                if (!this.data[slideIndex].els) {
                    this.data[slideIndex].els = [];
                }
                this.data[slideIndex].els.push(imageEl);
                
                if (needsSave) {
                    this.saveState();
                }
                this.loadCanvas();
                this.renderSlides();
            }
        };

        // ============ AI Functions from editor-ai1.html ============
        const MIN_AI_SLIDES = 3
        const MAX_AI_SLIDES = 12
        const DEFAULT_AI_SLIDE_COUNT = 6

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value))
        }

        function toTitleCase(input = '') {
            return input
                .toLowerCase()
                .split(/\s+/)
                .filter(Boolean)
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ')
        }

        function buildSubjectContext(subject = '', description = '') {
            const cleanedSubject = subject.trim().replace(/\s{2,}/g, ' ')
            const fallback = cleanedSubject.length ? cleanedSubject : 'AI Innovation'
            const subjectTitle = toTitleCase(fallback)

            const cleanedDescription = description.trim().replace(/\s{2,}/g, ' ')
            const hasDescription = cleanedDescription.length > 0
            const descriptionSentence = hasDescription ? cleanedDescription : ''
            const descriptionFragment = hasDescription ? ` focusing on ${cleanedDescription}` : ''
            const descriptionBullet = hasDescription ? `Key focus: ${cleanedDescription}.` : ''
            const descriptionNote = hasDescription ? `Emphasize ${cleanedDescription}.` : ''

            return {
                raw: fallback,
                subjectTitle,
                subjectLower: fallback.toLowerCase(),
                subjectKeyword: subjectTitle.split(' ')[0] || subjectTitle,
                hasDescription,
                descriptionSentence,
                descriptionFragment,
                descriptionBullet,
                descriptionNote,
            }
        }

        function applyContext(template = '', context) {
            if (!template) return ''
            return template
                .replace(/\{subject\}/g, context.subjectTitle)
                .replace(/\{subjectLower\}/g, context.subjectLower)
                .replace(/\{subjectKeyword\}/g, context.subjectKeyword)
                .replace(/\{descriptionSentence\}/g, context.descriptionSentence || '')
                .replace(/\{descriptionFragment\}/g, context.descriptionFragment || '')
                .replace(/\{descriptionBullet\}/g, context.descriptionBullet || '')
                .replace(/\{descriptionNote\}/g, context.descriptionNote || '')
                .replace(/\s{2,}/g, ' ')
                .replace(/\s+\./g, '.')
                .replace(/\s+,/g, ',')
                .trim()
        }

        function createSection(template, context) {
            return {
                title: applyContext(template.title, context),
                description: applyContext(template.description, context),
                notes: applyContext(template.notes || '', context),
            }
        }

        function generateAISlides(context, requestedCount) {
            const slideTotal = clamp(
                Number.isFinite(requestedCount) ? Math.round(requestedCount) : 0,
                MIN_AI_SLIDES,
                MAX_AI_SLIDES
            )

            const baseBlueprint = [
                {
                    title: '{subject} Vision & Why Now',
                    description:
                        'Position the urgency for {subjectLower}, the business problem we solve, and the strategic outcome we pursue{descriptionFragment}.',
                    notes:
                        'Set the tone with the market trigger, executive mandate, and the ambition level. {descriptionNote}',
                },
                {
                    title: 'Opportunity Landscape',
                    description:
                        'Size the upside, critical use cases, and stakeholder pain points that {subjectLower} addresses.',
                    notes: 'Quantify value pools and highlight the proof points that build credibility.',
                },
                {
                    title: 'Solution Architecture',
                    description:
                        'Break down how {subjectLower} works end-to-enddata, models, experience, and enabling tech.',
                    notes: 'Keep the narrative board-ready. Avoid jargon and spotlight differentiators.',
                },
                {
                    title: 'Value Realization Plan',
                    description:
                        'Connect roadmap moments to KPIs, leading indicators, and measurable business value from {subjectLower}.',
                    notes: 'Surface momentum metrics, early wins, and the executive asks to unlock value.',
                },
                {
                    title: 'Roadmap & Next 90 Days',
                    description:
                        'Detail phases, funding checkpoints, and the next tangible actions to accelerate {subjectLower}.',
                    notes: 'Highlight owners, decision gates, and cross-functional dependencies.',
                },
            ]

            const supplementalPool = [
                {
                    title: 'Data & Platform Readiness',
                    description:
                        'Assess data quality, integration work, and platform choices powering {subjectLower}.',
                    notes: 'Clarify maturity, gaps, and the mitigation path to stay on track.',
                },
                {
                    title: 'People, Skills, & Change',
                    description:
                        'Outline talent, partners, and enablement required to embed {subjectLower} into operations.',
                    notes: 'Call out champions, capability uplift, and cultural signals.',
                },
                {
                    title: 'Responsible AI & Governance',
                    description:
                        'Define guardrails, ethical considerations, and compliance checkpoints guiding {subjectLower}.',
                    notes: 'Address transparency, bias mitigation, and human-in-the-loop controls.',
                },
                {
                    title: 'Pilot Spotlight',
                    description:
                        'Showcase an early use case proving the value of {subjectLower} with qualitative and quantitative results.',
                    notes: 'Share narrative, partner teams, and lessons learned.',
                },
                {
                    title: 'Investment & Resourcing',
                    description:
                        'Frame the financial view, funding scenario, and resource allocation enabling {subjectLower}.',
                    notes: 'Tie spend to value narrative and risk posture to secure buy-in.',
                },
                {
                    title: 'Adoption & Communications Plan',
                    description:
                        'Explain how we will socialize, train, and reinforce behaviors to scale {subjectLower}.',
                    notes: 'Outline messaging pillars, enablement cadence, and feedback loops.',
                },
                {
                    title: 'Measurement & Feedback Loops',
                    description:
                        'Describe how performance, user insight, and model health inform continuous improvement for {subjectLower}.',
                    notes: 'Mention dashboards, cadences, and escalation paths.',
                },
            ]

            const dynamicTemplate = {
                title: 'Deep Dive: {subjectKeyword} Workstream',
                description:
                    'Highlight a priority initiative, capability, or partnership that makes {subjectLower} defensible.',
                notes: 'Frame owner, timeline, dependencies, and success signals.',
            }

            const slides = []

            baseBlueprint.forEach((template) => {
                if (slides.length < slideTotal) {
                    slides.push(createSection(template, context))
                }
            })

            let poolIndex = 0
            while (slides.length < slideTotal && poolIndex < supplementalPool.length) {
                slides.push(createSection(supplementalPool[poolIndex], context))
                poolIndex += 1
            }

            let dynamicIndex = 1
            while (slides.length < slideTotal) {
                const dynamicSection = { ...dynamicTemplate }
                dynamicSection.title = dynamicSection.title.replace('Workstream', `Workstream ${dynamicIndex}`)
                slides.push(createSection(dynamicSection, context))
                dynamicIndex += 1
            }

            return slides
        }

        // OpenAI API Configuration - Optimized
        // OpenAI API Configuration - Used exclusively for slide generation
        const OPENAI_API_KEY = localStorage.getItem('openai_api_key') || 'YOUR_OPENAI_API_KEY_HERE'
        const OPENAI_API_ENDPOINT = 'https://api.openai.com/v1/chat/completions'
        const AI_REQUEST_TIMEOUT_MS = 90000 // 90 seconds - enough time for complex requests
        const OPENAI_MODEL = 'gpt-4o' // Using GPT-4o for better quality and detailed content
        
        // Enhanced web search using multiple sources
        async function searchWebComprehensive(query) {
            if (!query || !query.trim()) return null
            
            let allResults = []
            
            // Search 1: DuckDuckGo
            try {
                const ddgUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1`
                const ddgResponse = await fetch(ddgUrl)
                if (ddgResponse.ok) {
                    const ddgData = await ddgResponse.json()
                    if (ddgData.AbstractText) allResults.push(ddgData.AbstractText)
                    if (ddgData.Answer) allResults.push(ddgData.Answer)
                }
            } catch (e) {
                console.warn('DuckDuckGo search failed:', e)
            }
            
            // Search 2: Wikipedia API (for factual information)
            try {
                const wikiUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`
                const wikiResponse = await fetch(wikiUrl)
                if (wikiResponse.ok) {
                    const wikiData = await wikiResponse.json()
                    if (wikiData.extract) allResults.push(wikiData.extract)
                        }
                    } catch (e) {
                console.warn('Wikipedia search failed:', e)
            }
            
            return allResults.length > 0 ? allResults.join('. ') : null
        }

        function extractJsonPayload(raw = '') {
            if (!raw || typeof raw !== 'string') return null
            let trimmed = raw.trim()
            if (!trimmed) return null
            
            // Remove any markdown formatting or extra text before/after JSON
            trimmed = trimmed
                .replace(/^[^{]*/, '') // Remove text before first {
                .trim()
            
            // Try to extract JSON from markdown code blocks first
            const codeBlockMatch = trimmed.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/)
            if (codeBlockMatch) {
                try {
                    const parsed = JSON.parse(codeBlockMatch[1])
                    if (parsed && typeof parsed === 'object' && Array.isArray(parsed.slides)) {
                        return parsed
                    }
                } catch (error) {
                    console.warn('Failed to parse JSON from code block:', error)
                }
            }
            
            // Try to find JSON object in the text (improved regex to handle nested objects)
            let jsonMatch = trimmed.match(/\{[\s\S]*"slides"[\s\S]*\}/)
            if (!jsonMatch) {
                // If no match, try to find any JSON object
                jsonMatch = trimmed.match(/\{[\s\S]{10,}\}/)
            }
            
            if (jsonMatch) {
                let jsonStr = jsonMatch[0]
                
                // Fix truncated JSON by balancing braces and brackets
                const openBraces = (jsonStr.match(/\{/g) || []).length
                const closeBraces = (jsonStr.match(/\}/g) || []).length
                const openBrackets = (jsonStr.match(/\[/g) || []).length
                const closeBrackets = (jsonStr.match(/\]/g) || []).length
                
                // Add missing closing brackets first (for arrays)
                if (closeBrackets < openBrackets) {
                    jsonStr += ']'.repeat(openBrackets - closeBrackets)
                }
                
                // Add missing closing braces
                if (closeBraces < openBraces) {
                    jsonStr += '}'.repeat(openBraces - closeBraces)
                }
                
                // Try to fix incomplete strings (if JSON was cut off mid-string)
                // Remove incomplete string at the end
                jsonStr = jsonStr.replace(/"[^"]*$/, '"') // Fix incomplete string
                jsonStr = jsonStr.replace(/,\s*$/, '') // Remove trailing comma
                
                try {
                    const parsed = JSON.parse(jsonStr)
                // Validate structure
                if (parsed && typeof parsed === 'object' && Array.isArray(parsed.slides)) {
                        // Filter out incomplete slides (missing required fields)
                        parsed.slides = parsed.slides.filter(slide => {
                            return slide && slide.title && slide.title.trim().length > 0
                        })
                        if (parsed.slides.length > 0) {
                            console.log(` Successfully parsed ${parsed.slides.length} slides (some may have been filtered)`)
                    return parsed
                }
                    }
                } catch (error) {
                    console.warn(' Failed to parse matched JSON:', error.message)
                    console.warn('   JSON string length:', jsonStr.length)
                    console.warn('   JSON preview (last 500 chars):', jsonStr.substring(Math.max(0, jsonStr.length - 500)))
                    
                    // IMPROVED: Extract complete slides from truncated JSON
                    try {
                        // Find the slides array
                        const slidesArrayMatch = jsonStr.match(/"slides"\s*:\s*\[([\s\S]*)/)
                        if (slidesArrayMatch) {
                            const slidesText = slidesArrayMatch[1]
                            const validSlides = []
                            
                            // Split by slide object boundaries more intelligently
                            // Look for complete slide objects: { "title": "...", "summary": "...", "notes": "..." }
                            let currentPos = 0
                            let braceCount = 0
                            let inString = false
                            let escapeNext = false
                            let slideStart = -1
                            
                            for (let i = 0; i < slidesText.length; i++) {
                                const char = slidesText[i]
                                
                                if (escapeNext) {
                                    escapeNext = false
                                    continue
                                }
                                
                                if (char === '\\') {
                                    escapeNext = true
                                    continue
                                }
                                
                                if (char === '"' && !escapeNext) {
                                    inString = !inString
                                    continue
                                }
                                
                                if (!inString) {
                                    if (char === '{') {
                                        if (braceCount === 0) {
                                            slideStart = i
                                        }
                                        braceCount++
                                    } else if (char === '}') {
                                        braceCount--
                                        if (braceCount === 0 && slideStart >= 0) {
                                            // Found a complete slide object
                                            const slideStr = slidesText.substring(slideStart, i + 1)
                                            try {
                                                const slide = JSON.parse(slideStr)
                                                if (slide && slide.title && slide.title.trim().length > 0) {
                                                    validSlides.push({
                                                        title: slide.title || '',
                                                        summary: slide.summary || slide.description || '',
                                                        notes: slide.notes || ''
                                                    })
                                                    console.log(` Extracted slide: "${slide.title.substring(0, 50)}"`)
                                                }
                                            } catch (parseError) {
                                                // Try to extract at least title and summary manually
                                                const titleMatch = slideStr.match(/"title"\s*:\s*"([^"]*)"/)
                                                const summaryMatch = slideStr.match(/"summary"\s*:\s*"([^"]*)"/) || slideStr.match(/"description"\s*:\s*"([^"]*)"/)
                                                if (titleMatch && titleMatch[1]) {
                                                    validSlides.push({
                                                        title: titleMatch[1],
                                                        summary: summaryMatch ? summaryMatch[1] : '',
                                                        notes: ''
                                                    })
                                                    console.log(` Manually extracted slide: "${titleMatch[1].substring(0, 50)}"`)
                                                }
                                            }
                                            slideStart = -1
                                        }
                                    }
                                }
                            }
                            
                            if (validSlides.length > 0) {
                                console.log(` Successfully extracted ${validSlides.length} complete slides from truncated JSON`)
                                return { slides: validSlides }
                            }
                        }
                    } catch (manualError) {
                        console.warn(' Manual extraction also failed:', manualError)
                    }
                }
            }
            
            // Last attempt: try to parse the entire trimmed string
            try {
                const parsed = JSON.parse(trimmed)
                if (parsed && typeof parsed === 'object' && Array.isArray(parsed.slides)) {
                    return parsed
                }
            } catch (error) {
                console.warn('Unable to parse AI response as JSON:', error)
            }
            
                return null
        }

        function cleanTextValue(value = '') {
            if (typeof value !== 'string') {
                if (value && typeof value.toString === 'function') {
                    value = value.toString()
                } else {
                    return ''
                }
            }
            // Remove markdown formatting, extra whitespace, and clean up text
            return value
                .replace(/```json\n?/g, '') // Remove JSON code blocks
                .replace(/```\n?/g, '') // Remove code blocks
                .replace(/^\s*\{[\s\S]*?"slides"\s*:\s*\[/i, '') // Remove JSON wrapper start
                .replace(/\]\s*\}\s*$/i, '') // Remove JSON wrapper end
                .replace(/\\n/g, ' ') // Replace escaped newlines
                .replace(/\n+/g, ' ') // Replace actual newlines
                .replace(/\s+/g, ' ') // Replace multiple spaces
                .replace(/\s+\./g, '.') // Fix spacing before periods
                .replace(/\s+,/g, ',') // Fix spacing before commas
                .replace(/\s+:/g, ':') // Fix spacing before colons
                .replace(/\s+;/g, ';') // Fix spacing before semicolons
                .trim()
        }

        function joinTextArray(value) {
            if (!Array.isArray(value)) return ''
            return value
                .map((item) => {
                    if (typeof item === 'string') return cleanTextValue(item)
                    if (item && typeof item.text === 'string') return cleanTextValue(item.text)
                    return ''
                })
                .filter(Boolean)
                .join(' ')
        }

        function normalizeBlueprintEntry(entry = {}, index = 0) {
            if (!entry || typeof entry !== 'object') return null
            const preferredTitle = cleanTextValue(entry.title || entry.heading || '')
            
            // Collect all description candidates and combine them for richer content
            const descriptionCandidates = [
                cleanTextValue(entry.summary || ''),
                cleanTextValue(entry.description || ''),
                cleanTextValue(entry.content || ''),
                cleanTextValue(entry.body || ''),
                joinTextArray(entry.points),
                joinTextArray(entry.bullets),
                joinTextArray(entry.highlights),
                joinTextArray(entry.details),
                joinTextArray(entry.keyPoints),
            ].filter(Boolean)

            // Combine multiple description sources for more complete content
            const combinedDescription = descriptionCandidates.length > 1 
                ? descriptionCandidates.join(' ') 
                : (descriptionCandidates[0] || '')

            // Collect all notes candidates and combine for comprehensive presenter notes
            const notesCandidates = [
                cleanTextValue(entry.notes || ''),
                cleanTextValue(entry.speakerNotes || ''),
                cleanTextValue(entry.talkingPoints || ''),
                cleanTextValue(entry.presenterNotes || ''),
                joinTextArray(entry.discussionPoints),
            ].filter(Boolean)

            const combinedNotes = notesCandidates.length > 1
                ? notesCandidates.join(' ')
                : (notesCandidates[0] || '')

            const normalized = {
                title: preferredTitle.length ? preferredTitle : `Slide ${index + 1}`,
                description: combinedDescription.trim() || '',
                summary: combinedDescription.trim() || '', // Keep summary same as description
                notes: combinedNotes.trim() || '',
            }

            return normalized
        }

        function overlaySlidesWithBlueprint(baseSlides = [], blueprint = []) {
            if (!Array.isArray(baseSlides) || !baseSlides.length) return baseSlides
            if (!Array.isArray(blueprint) || !blueprint.length) return baseSlides
            return baseSlides.map((slide, index) => {
                const override = normalizeBlueprintEntry(blueprint[index], index)
                if (!override) return slide
                return {
                    ...slide,
                    title: override.title || slide.title,
                    description: override.description || slide.description,
                    summary: override.summary || override.description || slide.summary || slide.description, // Preserve summary
                    notes: override.notes !== undefined ? override.notes : slide.notes,
                }
            })
        }

        async function fetchFreeAIDeckPlan({ title, description, slideCount }) {
            const subject = cleanTextValue(title)
            const context = cleanTextValue(description)
            const targetSlides = clamp(
                Number.isFinite(slideCount) ? Math.round(slideCount) : DEFAULT_AI_SLIDE_COUNT,
                MIN_AI_SLIDES,
                MAX_AI_SLIDES
            )

            // Interactive Presentation Builder AI - Step-by-step logic
            // Step 1: Understand the user request - analyze subject, purpose, audience, tone
            // Step 2: Generate internal slide content (not shown to user yet)
            // Step 3: Decide best visual representation for each slide
            // Step 4: Produce final slides for the user
            
            // Gamma-style AI prompt - Smart, engaging, professional
            const instruction = `You are an Interactive Presentation Builder AI. Follow this logic:

STEP 1 - UNDERSTAND THE USER REQUEST:
- Analyze the subject: "${subject || 'Executive Briefing'}"
- Determine purpose, audience, and tone
- Create a full slide plan internally (not displayed to user yet)

STEP 2 - GENERATE INTERNAL SLIDE CONTENT:
- Create slide titles
- Generate short bullet points
- Include key messages
- This content will be used only for the next step
- Do NOT format or design anything yet

STEP 3 - DECIDE BEST VISUAL REPRESENTATION:
For each slide, choose the optimal format:
- Bullet list (for lists, features, benefits)
- Two-column comparison (for comparisons, pros/cons)
- Diagram (for concepts, relationships)
- Timeline (for chronological information)
- Flowchart (for processes, workflows)
- Chart (pie, bar, line, donut for data)
- Infographic layout (for complex information)
- Quote style (for testimonials, key statements)
- Image + text (for visual explanations)
- Step-by-step layout (for procedures)

Always choose the layout that makes the content most clear.

STEP 4 - PRODUCE FINAL SLIDES:
Generate final output that is:
- Clear and smart
- Visually optimized
- Professional
- Editable
- Matching exactly what the user asked for

You are an expert presentation designer creating a beautiful, engaging presentation like Gamma. 

PRESENTATION TOPIC: "${subject || 'Executive Briefing'}"

CRITICAL - READ CAREFULLY:
The user wants a presentation about "${subject}". EVERY slide must be about "${subject}" and ONLY "${subject}".
Do NOT create generic business slides. Do NOT use template content.
Write as if you are an expert on "${subject}" explaining it to someone.

VERY IMPORTANT - CONTENT REQUIREMENTS:
- EVERY sentence must mention or relate to "${subject}" directly
- If the subject is "Robotics", write about robots, robotic systems, automation, etc.
- If the subject is "AI", write about artificial intelligence, machine learning, neural networks, etc.
- Do NOT write generic business content that could apply to any topic
- Be SPECIFIC and DETAILED about "${subject}"
- Include real examples, use cases, and technical details about "${subject}"

YOUR MISSION:
Create exactly ${targetSlides} compelling, informative slides about "${subject}" that are:
- Clear and easy to understand
- Visually engaging (we'll add images automatically)
- Professional yet approachable
- Focused ENTIRELY on "${subject}" - nothing else

SLIDE STRUCTURE - Each slide about "${subject}":
- Slide 1: Introduction - What is "${subject}"? Why does it matter? Explain "${subject}" clearly.
- Slide 2-${targetSlides - 1}: Deep dive - Explore different aspects of "${subject}". Each slide should cover a specific aspect of "${subject}".
- Last slide: Conclusion - Key takeaways about "${subject}". Summarize what we learned about "${subject}".

CONTENT GUIDELINES - Write about "${subject}":
- Be CONCISE and VALUABLE - every word must add value
- Maximum 60 words per slide summary - NO exceptions
- Focus on KEY points only - what it is, why it matters, one example
- NO long explanations, NO excessive details, NO filler words
- Write like a professional summary - clear, brief, impactful
- Each bullet point: Maximum 12-15 words
- If using paragraphs: Maximum 2-3 short sentences
- Make it fit on the slide without scrolling - content must be visible

${context ? `ADDITIONAL CONTEXT: "${context}". Use this to add more depth and specificity about "${subject}".` : `Focus on "${subject}" itself - explain it clearly and comprehensively.`}

OUTPUT FORMAT - CRITICAL:
- Respond ONLY with valid, COMPLETE JSON (no markdown, no code blocks, no truncation)
- The JSON MUST be complete and properly closed - ensure all braces and brackets are closed
- Provide exactly ${targetSlides} slides about "${subject}"
- Each slide MUST include:
  * title: Engaging headline (6-10 words) about "${subject}". Make it interesting and clear. Example: If subject is "AI Vision", use "AI Vision: The Future of Business" or "How AI Vision Works"
  * summary: Concise, valuable explanation (40-60 words MAX) about "${subject}". Be brief but informative. Include:
    - What "${subject}" is (1-2 sentences)
    - Why it matters or key benefit (1 sentence)
    - One practical example or use case (1 sentence)
    - Keep it SHORT and VALUABLE - no unnecessary details
  * notes: Brief presenter notes (30-50 words MAX) with:
    - Key points to emphasize about "${subject}"
    - Additional context or details about "${subject}"
    - Questions or discussion points related to "${subject}"

WRITING STYLE:
- Write like Gamma - clear, engaging, professional
- Be conversational but informative
- Focus on "${subject}" throughout
- Make it interesting to read
- Use simple, clear language
- Avoid jargon unless necessary

JSON Format (MUST be complete and valid):
{"slides":[{"title":"","summary":"","notes":""}, {"title":"","summary":"","notes":""}, ...]}

IMPORTANT: Ensure the JSON response is COMPLETE - all opening braces { must have closing braces }, all opening brackets [ must have closing brackets ], and all strings must be properly closed with quotes. Do not truncate the response.

Create ${targetSlides} beautiful, engaging slides about "${subject}" now:`

            // Use OpenAI API exclusively for generating slides
            // Retry logic for better reliability
            let lastError = null;
            const maxRetries = 2;
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
            const controller = typeof AbortController !== 'undefined' ? new AbortController() : null
            const timeoutId =
                controller != null
                    ? window.setTimeout(() => controller.abort(), AI_REQUEST_TIMEOUT_MS)
                    : null

            try {
                    if (attempt > 0) {
                        console.log(` Retry attempt ${attempt}/${maxRetries} for OpenAI API request...`);
                        // Wait a bit before retry
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                // USE OPENAI API ONLY - NO FALLBACK TO OTHER SERVICES
                let response = null
                
                // MUST use OpenAI API - validate API key first
                if (!OPENAI_API_KEY || OPENAI_API_KEY.length === 0 || !OPENAI_API_KEY.startsWith('sk-')) {
                    throw new Error('OpenAI API key is missing or invalid. Please provide a valid API key.')
                }
                
                console.log(' Generating slides using OpenAI API with GPT-4o model...')
                console.log(' Request details:', {
                    model: OPENAI_MODEL,
                    subject: subject,
                    slides: targetSlides,
                    endpoint: OPENAI_API_ENDPOINT,
                    max_tokens: 6000,
                    timeout: `${AI_REQUEST_TIMEOUT_MS / 1000}s`,
                    attempt: attempt + 1,
                    features: 'Images, Charts, Organized Layout'
                })
                
                // Make request to OpenAI API
                response = await fetch(OPENAI_API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: OPENAI_MODEL,
                        messages: [
                            {
                                role: 'system',
                                content: `You are an expert presentation designer like Gamma. Create beautiful, engaging slides about "${subject}". Write naturally and clearly. Every slide must focus on "${subject}". Always respond with valid JSON only - no markdown, no code blocks. Format: {"slides":[{"title":"","summary":"","notes":""}]}`
                            },
                            {
                                role: 'user',
                                content: instruction
                            }
                        ],
                        temperature: 0.7, // Slightly lower for more focused content
                        max_tokens: 6000, // Balanced: enough for content, fast enough to avoid timeout
                        response_format: { type: 'json_object' },
                        top_p: 0.9,
                        frequency_penalty: 0.2,
                        presence_penalty: 0.2
                    }),
                    cache: 'no-store',
                    signal: controller?.signal,
                })
                
                // Check response status
                if (!response.ok) {
                    const errorText = await response.text()
                    console.error(' OpenAI API error:', response.status, errorText)
                    throw new Error(`OpenAI API returned status ${response.status}: ${errorText.substring(0, 300)}`)
                }
                
                console.log(' OpenAI API request successful!')
                console.log(` Generating ${targetSlides} slides about: "${subject}"`)
                
                let rawText = ''
                let payload = null
                
                // OpenAI returns format: { choices: [{ message: { content: "..." } }] }
                    const responseData = await response.json()
                
                // Better error handling for OpenAI responses
                if (responseData.error) {
                    console.error(' OpenAI API Error:', responseData.error)
                    throw new Error(`OpenAI API Error: ${responseData.error.message || 'Unknown error'}`)
                }
                
                if (responseData.choices && responseData.choices[0] && responseData.choices[0].message) {
                    rawText = responseData.choices[0].message.content
                    console.log(' OpenAI response received, length:', rawText.length)
                    console.log(' Response preview (first 800 chars):', rawText.substring(0, 800))
                    
                    // Check if response mentions the subject
                    const responseLower = rawText.toLowerCase();
                    const subjectLower = (subject || '').toLowerCase();
                    const subjectWords = subjectLower.split(' ').filter(w => w.length > 2); // Get meaningful words
                    const mentionsSubject = subjectWords.length > 0 && subjectWords.some(word => responseLower.includes(word));
                    
                    if (subjectLower && !mentionsSubject) {
                        console.warn(` WARNING: Response may not mention subject "${subject}"`);
                        console.warn(`   Looking for words: ${subjectWords.join(', ')}`);
                        console.warn(`   Response contains: ${responseLower.substring(0, 200)}`);
        } else {
                        console.log(` Response correctly mentions subject "${subject}"`);
                        const mentionCount = subjectWords.filter(w => responseLower.includes(w)).length;
                        console.log(`   Found ${mentionCount}/${subjectWords.length} subject keywords in response`);
                    }
                } else {
                    console.error(' Invalid OpenAI response structure:', responseData)
                    throw new Error('Invalid response format from OpenAI API. Response structure is incorrect.')
                }
                
                // Log for debugging
                if (rawText && rawText.length > 0 && rawText.length < 5000) {
                    console.log('AI Response preview:', rawText.substring(0, 200))
                }
                
                // Parse the JSON content
                payload = extractJsonPayload(rawText)
                if (!payload || !Array.isArray(payload.slides) || !payload.slides.length) {
                    console.error(' Failed to parse AI response');
                    console.error('Raw text length:', rawText.length);
                    console.error('Raw text preview:', rawText.substring(0, 1000));
                    throw new Error('AI response format was invalid. Please try again.')
                }
                
                console.log(` Successfully parsed ${payload.slides.length} slides from AI response`);
                
                // Validate slides have proper content
                payload.slides.forEach((slide, idx) => {
                    const title = slide.title || slide.heading || '';
                    const summary = slide.summary || slide.description || '';
                    const hasTitle = title.trim().length > 0;
                    const hasContent = summary.trim().length > 50;
                    
                    console.log(` Slide ${idx + 1}:`, {
                        title: title.substring(0, 50),
                        titleLength: title.length,
                        summaryLength: summary.length,
                        hasTitle,
                        hasContent
                    });
                    
                    if (!hasTitle) {
                        console.warn(` Slide ${idx + 1} missing title`);
                    }
                    if (!hasContent) {
                        console.warn(` Slide ${idx + 1} has insufficient content (${summary.length} chars)`);
                    }
                });

                // Validate and clean slides - preserve detailed content
                const subjectLower = (subject || '').toLowerCase();
                const subjectKeywords = subjectLower.split(' ').filter(w => w.length > 2); // Extract keywords from subject
                
                console.log(` Validating slides for subject: "${subject}"`);
                console.log(`   Subject keywords: ${subjectKeywords.join(', ')}`);
                
                const validSlides = payload.slides
                    .slice(0, targetSlides)
                    .map((slide, idx) => {
                        // Get the most detailed content available
                        let title = cleanTextValue(slide.title || slide.heading || `Slide ${idx + 1}`)
                        let summary = cleanTextValue(
                            slide.summary || 
                            slide.description || 
                            slide.content || 
                            slide.body ||
                            slide.details ||
                            ''
                        )
                        
                        // VALIDATION: Ensure title and summary relate to the subject
                        const titleLower = title.toLowerCase();
                        const summaryLower = summary.toLowerCase();
                        const hasSubjectInTitle = subjectKeywords.some(keyword => titleLower.includes(keyword));
                        const hasSubjectInSummary = subjectKeywords.some(keyword => summaryLower.includes(keyword));
                        
                        // If title doesn't relate to subject, enhance it
                        if (!hasSubjectInTitle && subject && subject.length > 0) {
                            console.warn(` Slide ${idx + 1} title doesn't mention subject. Original: "${title}"`);
                            // Try to enhance title to include subject
                            if (!title.includes(subject)) {
                                title = `${subject}: ${title}`;
                            }
                        }
                        
                        // If summary doesn't relate to subject, add context
                        if (!hasSubjectInSummary && subject && subject.length > 0 && summary.length > 50) {
                            console.warn(` Slide ${idx + 1} summary doesn't mention subject. Adding context.`);
                            // Prepend subject context if summary is generic
                            if (summary.length < 200) {
                                summary = `${subject} ${summary}`;
                            }
                        }
                        const notes = cleanTextValue(
                            slide.notes || 
                            slide.speakerNotes || 
                            slide.talkingPoints ||
                            slide.keyPoints ||
                            ''
                        )
                        
                        // If summary is too short, try to get more detail from other fields
                        let enhancedSummary = summary
                        if (summary.length < 100) {
                            // Try to get more content from other fields - prioritize longer content
                            const allContent = [
                                slide.content,
                                slide.body,
                                slide.details,
                                slide.description,
                                notes
                            ].filter(c => c && c.length > summary.length)
                            .sort((a, b) => b.length - a.length); // Sort by length, longest first
                            
                            if (allContent.length > 0) {
                                enhancedSummary = cleanTextValue(allContent[0])
                            }
                        }
                        
                        // CRITICAL: Ensure we have substantial content - minimum 150 words
                        if (enhancedSummary.length < 150) {
                            // Combine all available content
                            const combinedContent = [
                                enhancedSummary,
                                cleanTextValue(slide.content || ''),
                                cleanTextValue(slide.body || ''),
                                cleanTextValue(slide.details || ''),
                                cleanTextValue(notes || '')
                            ].filter(c => c && c.length > 20)
                            .join(' ')
                            .trim();
                            
                            if (combinedContent.length > enhancedSummary.length) {
                                enhancedSummary = combinedContent;
                            }
                            
                            // If still too short, create detailed content about the title
                            if (enhancedSummary.length < 150) {
                                enhancedSummary = `${enhancedSummary} ${title} represents a significant opportunity in the current market landscape. Industry analysis shows strong growth potential with adoption rates increasing across major sectors. Key stakeholders are recognizing the strategic value and competitive advantages that ${title} provides. Market research indicates substantial ROI potential, with typical implementation timelines ranging from 6-12 months. Leading organizations are investing heavily in ${title}, with average budgets exceeding industry standards. The competitive landscape is evolving rapidly, creating both opportunities and challenges. Strategic implementation requires careful planning, stakeholder alignment, and proven methodologies. Success factors include executive sponsorship, clear objectives, and measurable outcomes. Risk mitigation strategies are essential for sustainable growth and long-term success.`
                            }
                        }
                        
                        console.log(` Slide ${idx + 1}: Title="${title}", Summary length=${enhancedSummary.length} chars`);
                        if (enhancedSummary.length < 200) {
                            console.warn(` Slide ${idx + 1} summary is short (${enhancedSummary.length} chars). Consider enhancing.`);
                        }
                        
                        return {
                            title,
                            summary: enhancedSummary,
                            description: enhancedSummary, // Keep description same as summary for compatibility
                            notes: notes || enhancedSummary, // Use summary as notes if notes are empty
                        }
                    })
                    .filter(slide => slide.title.length > 0)

                if (validSlides.length === 0) {
                    throw new Error('No valid slides were generated. Please try again.')
                }

                return validSlides
            } catch (error) {
                    lastError = error;
                    
                    // Clear timeout on error
                    if (timeoutId != null) {
                        window.clearTimeout(timeoutId)
                    }
                    
                    // If it's a timeout and we have retries left, continue to retry
                    if (error.name === 'AbortError' && attempt < maxRetries) {
                        console.warn(` Request timeout on attempt ${attempt + 1}, retrying...`);
                        continue;
                    }
                    
                    // If it's a timeout and no retries left, throw timeout error
                if (error.name === 'AbortError') {
                        throw new Error('AI request timed out after multiple attempts. Please try again with a shorter description or fewer slides.')
                }
                    
                    // For other errors, if we have retries left, continue
                    if (attempt < maxRetries) {
                        console.warn(` Request failed on attempt ${attempt + 1}: ${error.message}, retrying...`);
                        continue;
                    }
                    
                    // No retries left, throw the error
                throw error
            } finally {
                if (timeoutId != null) {
                    window.clearTimeout(timeoutId)
                }
            }
            }
            
            // If we get here, all retries failed
            throw lastError || new Error('Failed to generate slides after multiple attempts.')
        }

        function escapeHtml(text = '') {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
        }

        function deriveFocusTiles(slide, context) {
            const rawChunks = (slide.notes || '')
                .split(/[\n\.]+/)
                .map((chunk) => chunk.trim())
                .filter(Boolean)

            const tiles = rawChunks.slice(0, 3)
            const fallbackPhrases = [
                `Connect ${context.subjectKeyword} to measurable outcomes.`,
                `Clarify ownership and next decisions.`,
                `Highlight momentum and the executive ask.`,
            ]

            while (tiles.length < 3) {
                tiles.push(fallbackPhrases[tiles.length % fallbackPhrases.length])
            }

            return tiles.slice(0, 3)
        }

        function createAISlideStage(slide, index, total, context, slideId = null) {
            // Use the detailed summary/description from AI, not just the basic description
            // Ensure we always have content - check multiple sources
            const heading = escapeHtml(
                slide.title || 
                slide.heading || 
                (typeof slide === 'object' && slide.title) ||
                `Slide ${index + 1}`
            )
            
            // Get raw body content - check all possible sources with priority
            let rawBody = '';
            
            // Priority order: summary > description > content > body > notes
            if (slide.summary && slide.summary.trim().length > 50) {
                rawBody = slide.summary;
            } else if (slide.description && slide.description.trim().length > 50) {
                rawBody = slide.description;
            } else if (slide.content && slide.content.trim().length > 50) {
                rawBody = slide.content;
            } else if (slide.body && slide.body.trim().length > 50) {
                rawBody = slide.body;
            } else if (slide.notes && slide.notes.trim().length > 50) {
                rawBody = slide.notes;
            } else if (context && context.descriptionSentence && context.descriptionSentence.trim().length > 50) {
                rawBody = context.descriptionSentence;
            } else if (context && context.description && context.description.trim().length > 50) {
                rawBody = context.description;
            }
            
            // If still empty or too short, use fallback
            if (!rawBody || rawBody.trim().length < 50) {
                const title = slide.title || slide.heading || heading;
                // Better fallback that uses the actual subject from context
                const subjectTitle = context?.subjectTitle || context?.raw || title;
                rawBody = `${subjectTitle} represents an important topic that requires detailed explanation. This slide explores the key aspects of ${subjectTitle}, including its definition, core principles, practical applications, and strategic importance. Understanding ${subjectTitle} is essential for making informed decisions and achieving desired outcomes.`;
                console.warn(` Slide ${index + 1} has insufficient content. Using fallback content based on: "${subjectTitle}"`);
            }
            
            console.log(` Slide ${index + 1} content length: ${rawBody.length} characters`);
            
            // STEP 3: DECIDE BEST VISUAL REPRESENTATION - Smart Layout Detection
            // Analyze content to determine optimal layout type for maximum clarity
            const contentLower = rawBody.toLowerCase();
            let titleLower = (slide.title || heading || '').toLowerCase();
            const fullText = contentLower + ' ' + titleLower;
            
            // Layout type detection - Choose the layout that makes content most clear
            let layoutType = 'bullet-list'; // Default
            let shouldUseBullets = false;
            let shouldUseTwoColumn = false;
            let shouldUseTimeline = false;
            let shouldUseStepByStep = false;
            
            // Detect Timeline layout (for chronological information)
            if (/(timeline|chronology|history|evolution|journey|roadmap|milestone|year|date|period|quarter|decade|era|past|present|future)/i.test(fullText)) {
                layoutType = 'timeline';
                shouldUseTimeline = true;
                console.log(` Slide ${index + 1}: Detected Timeline layout`);
            }
            // Detect Step-by-step / Process layout (for procedures, workflows)
            else if (/(step|process|procedure|workflow|how to|guide|tutorial|method|approach|phase|stage|sequence|order)/i.test(fullText)) {
                layoutType = 'step-by-step';
                shouldUseStepByStep = true;
                shouldUseBullets = true;
                console.log(` Slide ${index + 1}: Detected Step-by-step layout`);
            }
            // Detect Two-column Comparison layout (for comparisons, pros/cons)
            else if (/(compare|comparison|versus|vs|pros?|cons?|advantages?|disadvantages?|benefits?|drawbacks?|difference|similar|contrast|both|either)/i.test(fullText)) {
                layoutType = 'two-column';
                shouldUseTwoColumn = true;
                console.log(` Slide ${index + 1}: Detected Two-column Comparison layout`);
            }
            // Detect Bullet List layout (for lists, features, benefits)
            else {
                // Define these variables here for use later
            const hasBulletIndicators = /(|||||||||-|\d+\.|\d+\))/.test(rawBody);
            const hasMultipleItems = rawBody.split(/\n|\. |; /).filter(line => line.trim().length > 15).length >= 3;
                const isListLike = /(key|items|points|benefits|features|challenges|recommendations|segments|categories|types|options|factors|elements|components)/i.test(titleLower);
                
                if (hasBulletIndicators || hasMultipleItems || isListLike) {
                    layoutType = 'bullet-list';
                    shouldUseBullets = true;
                    console.log(` Slide ${index + 1}: Detected Bullet List layout`);
                }
            }
            
            // Define hasBulletIndicators, hasMultipleItems, isListLike for use in bullet detection (outside if-else)
            const hasBulletIndicators = /(|||||||||-|\d+\.|\d+\))/.test(rawBody);
            const hasMultipleItems = rawBody.split(/\n|\. |; /).filter(line => line.trim().length > 15).length >= 3;
            const isListLike = /(key|steps|items|points|benefits|features|challenges|recommendations|segments|categories|types|options|advantages|disadvantages|factors|elements|components)/i.test(titleLower);
            
            // Check if content is narrative/story-like (should use paragraph)
            const isNarrative = /(overview|introduction|summary|conclusion|background|context|story|narrative|description|explanation)/i.test(titleLower);
            const isShortContent = rawBody.length < 50;
            
            // Decide: Use bullet points if content is clearly list-like, otherwise use paragraph
            let bodyPoints = [];
            
            // Always show content - don't hide it if short
            if ((hasBulletIndicators || hasMultipleItems || isListLike) && !isNarrative) {
                // Content needs bullet points - SMART SPLITTING
                shouldUseBullets = true;
                
                // First, try to split by actual bullet indicators
                bodyPoints = rawBody
                    .split(/\n||||||||||-|\d+\.|\d+\)|; /)
                    .map(line => line.trim().replace(/^[-\d+\.\)\s]+/, '').trim())
                    .filter(line => line.length > 10 && line.length < 80 && !line.match(/^(and|or|the|a|an|but|however|this|that|these|those)$/i))
                    .filter(line => {
                        // Filter out incomplete sentences
                        const incompleteEndings = /(of|in|on|at|for|with|to|from|by|about|into|onto)$/i;
                        return !incompleteEndings.test(line.trim());
                    })
                    .slice(0, 4); // Max 4 bullet points - keep it concise
                
                // If splitting didn't work well, try by sentences
                if (bodyPoints.length <= 1) {
                    const sentences = rawBody
                        .split(/[.!?]+/)
                        .map(sentence => sentence.trim())
                        .filter(sentence => sentence.length > 15 && sentence.length < 60) // Shorter sentences
                        .filter(sentence => {
                            return sentence.length > 15 && !sentence.match(/^(and|or|the|a|an|but|however)$/i);
                        })
                        .slice(0, 3); // Max 3 sentences - keep it concise
                    
                    if (sentences.length >= 2) {
                        bodyPoints = sentences;
                    }
                }
                
                // Only use bullets if we have at least 2 good points
                if (bodyPoints.length < 2) {
                    shouldUseBullets = false;
                } else {
                    // Limit to 3 points max for concise, visible content
                    bodyPoints = bodyPoints.slice(0, 3);
                }
            }
            
            // Format content - ALWAYS show content, ensure it's substantial
            // If we have bullet points, use them; otherwise use the full body text
            let body = shouldUseBullets && bodyPoints.length >= 2
                ? bodyPoints.map(point => escapeHtml(point)).join('\n')
                : escapeHtml(rawBody || '')
            
            // CRITICAL: Ensure body has substantial content - but keep it concise
            // Truncate if too long to ensure visibility
            if (body && body.trim().length > 300) {
                body = body.trim().substring(0, 300) + '...';
            }
            if (!body || body.trim().length < 30) {
                // Try ALL possible sources in priority order
                const allSources = [
                    slide.summary,
                    slide.description,
                    slide.content,
                    slide.body,
                    slide.notes,
                    rawBody
                ].filter(s => s && typeof s === 'string' && s.trim().length > 20);
                
                if (allSources.length > 0) {
                    // Use the longest, most detailed content available
                    const bestContent = allSources.sort((a, b) => b.length - a.length)[0];
                    body = escapeHtml(bestContent);
                    console.log(` Using content from slide object, length: ${bestContent.length}`);
                }
            }
            
            // Final fallback - create meaningful content from title if still empty
            if (!body || body.trim().length < 50) {
                const title = slide.title || slide.heading || heading;
                body = escapeHtml(`${title} is a strategic initiative that addresses key business challenges and opportunities. This presentation provides comprehensive insights into ${title}, including its core components, implementation strategies, and expected outcomes. Key stakeholders will gain a clear understanding of how ${title} can drive organizational success and deliver measurable value through innovative approaches and proven methodologies.`);
                console.warn(` Using fallback content for slide ${index + 1}`);
            }
            
            // Ensure minimum length for good visibility
            if (body.trim().length < 100) {
                const title = slide.title || slide.heading || heading;
                const additionalContent = ` Understanding ${title} requires examining its fundamental principles, strategic importance, and practical applications in today's business environment.`;
                body = body + escapeHtml(additionalContent);
            }
            
            // Check if this is a Flow Chart slide (titleLower already defined above)
            const isFlowChart = titleLower.includes('flow chart') || 
                               titleLower.includes('flowchart') || 
                               (titleLower.includes('flow') && (titleLower.includes('chart') || titleLower.includes('diagram') || titleLower.includes('process')));
            
            // Check if slide has Flow Chart element
            const hasElements = slide.els && slide.els.length > 0;
            const hasFlowChart = hasElements && slide.els.some(el => el.type === 'chart' && el.chartType === 'flow');
            
            // For Flow Chart slides: NO TEXT, only title + chart
            const bodyPointsForTemplate = (isFlowChart || hasFlowChart) ? [] : ((shouldUseBullets && bodyPoints.length >= 2) ? bodyPoints : [])
            
            // Log content details for debugging
            console.log(` Slide ${index + 1} "${heading}": Content length=${body.length} chars, rawBody length=${rawBody.length} chars`);
            if (body.length < 200) {
                console.warn(` Slide ${index + 1} content is short. Consider enhancing.`);
            }
            
            const badgeLabel = index === 0 ? 'Executive Overview' : `Section ${String(index + 1).padStart(2, '0')}`
            const tiles = deriveFocusTiles(slide, context)
            const currentSlideId = slideId || slide.id || `slide-${index + 1}`

            const tileHtml = tiles
                .map(
                    (tile, idx) => `
                      <div class="rounded-2xl border border-white/10 bg-white/5 p-4">
                        <p class="text-[0.6rem] uppercase tracking-[0.3em] text-emerald-200">Focus ${idx + 1}</p>
                        <p class="mt-1.5 text-xs text-slate-100">${escapeHtml(tile)}</p>
                      </div>
                    `
                )
                .join('')

            const presenterNote =
                slide.notes && slide.notes.trim().length
                    ? `
                      <div class="rounded-2xl border border-white/10 bg-white/5 p-4 text-xs text-slate-100">
                        <p class="text-[0.6rem] uppercase tracking-[0.3em] text-emerald-200">Presenter note</p>
                        <p class="mt-1">${escapeHtml(slide.notes)}</p>
                      </div>
                    `
                    : ''

            // Get custom elements for this slide
            const customElements = slide.customElements || []
            const customElementsHtml = customElements.map((el, idx) => {
                if (el.type === 'text') {
                    return `
                      <div 
                        class="draggable-text absolute cursor-move select-none outline-none focus:ring-2 focus:ring-emerald-400/50 rounded-lg px-2 py-1 hover:bg-white/10 transition"
                        data-element-id="${el.id}"
                        data-element-type="text"
                        contenteditable="true"
                        style="left: ${el.x || 50}%; top: ${el.y || 30}%; color: ${el.color || '#ffffff'}; font-size: ${el.fontSize || '16px'}; font-weight: ${el.fontWeight || '400'}; min-width: 100px;"
                      >${escapeHtml(el.text || 'New text')}</div>
                    `
                } else if (el.type === 'shape') {
                    const shapeStyles = {
                        rectangle: 'rounded-lg',
                        circle: 'rounded-full',
                        triangle: 'clip-path: polygon(50% 0%, 0% 100%, 100% 100%);',
                    }
                    return `
                      <div 
                        class="draggable-shape absolute cursor-move select-none"
                        data-element-id="${el.id}"
                        data-element-type="shape"
                        style="left: ${el.x || 50}%; top: ${el.y || 30}%; width: ${el.width || 100}px; height: ${el.height || 100}px; background: ${el.fill || '#ffffff'}; border: ${el.stroke || '2px solid rgba(255,255,255,0.3)'}; ${shapeStyles[el.shapeType || 'rectangle']}"
                      ></div>
                    `
                }
                return ''
            }).join('')

            // Get design preferences from slide or use defaults
            const design = slide.design || {}
            const bgStyle = design.background || 'gradient-dark'
            const showTitle = design.showTitle !== false
            const showBadge = design.showBadge !== false
            const showSlideNumber = design.showSlideNumber !== false
            const layoutPosition = design.layoutPosition || 'center'
            const customColor = design.customColor || '#0f172a'
            
            // Check if slide has charts or images to adjust text position
            // Note: hasElements is already defined at line 10475, hasFlowChart is already defined at line 10476
            // Reuse existing variables
            const hasChart = hasElements && slide.els.some(el => el.type === 'chart');
            const hasImage = hasElements && slide.els.some(el => el.type === 'image');
            // hasFlowChart is already defined above, but check again for safety
            const hasFlowChartCheck = hasChart && slide.els.some(el => el.type === 'chart' && el.chartType === 'flow');
            const hasBoth = hasChart && hasImage;
            
            // Check if this is a Flow Chart slide by title
            // Check if this is a Flow Chart slide by title (titleLower and isFlowChart already defined above)
            // For Flow Chart slides: NO description text, only title + chart
            // Note: isFlowChart is defined at line 10470, hasFlowChart is defined at line 10476
            const showDescription = (isFlowChart || hasFlowChart || hasFlowChartCheck) ? false : (design.showDescription !== false && (bodyPointsForTemplate.length > 0 || rawBody.length > 0));
            
            // GAMMA-STYLE PROFESSIONAL LAYOUT - PERFECT ORGANIZATION
            // Slide width: 960px
            // Layout strategy:
            // - Image: Always on LEFT side (x: 30-50px, width: 300-350px)
            // - Chart: Always on RIGHT side (x: 580-600px, width: 300-340px)
            // - Text: Positioned intelligently based on what's present
            //   * With image only: Text on RIGHT side of image (organized, clean)
            //   * With chart only: Text on LEFT side (before chart)
            //   * With both: Text in MIDDLE (between image and chart)
            //   * No elements: Text CENTERED
            
            // Calculate exact positions based on actual image/chart dimensions
            let imageWidth = 350; // Default image width
            let imageX = 30; // Default image X position
            let chartX = 600; // Default chart X position
            let chartWidth = 320; // Default chart width
            
            if (hasImage) {
                const imageEl = slide.els.find(el => el.type === 'image');
                if (imageEl) {
                    imageX = imageEl.x || 30;
                    imageWidth = imageEl.width || 350;
                }
            }
            
            if (hasChart) {
                const chartEl = slide.els.find(el => el.type === 'chart');
                if (chartEl) {
                    chartX = chartEl.x || 600;
                    chartWidth = chartEl.width || 320;
                }
            }
            
            // Calculate text position based on actual element positions
            let textLeft, textMaxWidth, textTop;
            if (hasBoth) {
                // Image on LEFT, Text in MIDDLE, Chart on RIGHT
                const imageEnd = imageX + imageWidth; // e.g., 30 + 350 = 380px
                const chartStart = chartX; // e.g., 600px
                const gap = 20; // Gap between elements
                textLeft = `${imageEnd + gap}px`; // After image + gap (e.g., 400px)
                textMaxWidth = `${chartStart - imageEnd - (gap * 2)}px`; // Space between image and chart (e.g., 600 - 380 - 40 = 180px)
                textTop = '80px';
            } else if (hasImage) {
                // Image on LEFT, Text on RIGHT side of image (organized layout)
                const imageEnd = imageX + imageWidth; // e.g., 30 + 350 = 380px
                const gap = 30; // Gap between image and text (increased for better spacing)
                const rightMargin = 40; // Right margin
                textLeft = `${imageEnd + gap}px`; // After image + gap (e.g., 410px)
                textMaxWidth = `${960 - imageEnd - gap - rightMargin}px`; // Rest of space (e.g., 960 - 380 - 30 - 40 = 510px)
                textTop = '80px'; // Aligned with image top - reduced from 15% to remove unnecessary space
            } else if (hasChart) {
                // Chart on RIGHT, Text on LEFT (before chart) - organized layout
                const gap = 30; // Gap before chart (increased for better spacing)
                const leftMargin = 48; // Left margin
                textLeft = `${leftMargin}px`; // From left
                textMaxWidth = `${chartX - leftMargin - gap}px`; // Before chart (e.g., 600 - 48 - 30 = 522px)
                textTop = '80px';
            } else {
                // No elements, text centered
                textLeft = '50%';
                textMaxWidth = '700px';
                textTop = '100px';
            }
            
            console.log(` Slide ${index + 1} layout:`, {
                hasImage,
                hasChart,
                imageX,
                imageWidth,
                chartX,
                chartWidth,
                textLeft,
                textMaxWidth
            });
            
            // Use calculated positions for organized layout
            // Calculate max height based on slide height (540px) and top position
            // Make sure all text is visible without scrolling
            const topValue = typeof textTop === 'string' && textTop.includes('%') 
                ? parseFloat(textTop) 
                : (typeof textTop === 'string' && textTop.includes('px')
                    ? parseFloat(textTop) / 540 * 100
                    : parseFloat(textTop || '80') / 540 * 100);
            const topPixels = typeof textTop === 'string' && textTop.includes('px')
                ? parseFloat(textTop)
                : (typeof textTop === 'string' && textTop.includes('%')
                    ? parseFloat(textTop) / 100 * 540
                    : parseFloat(textTop || '80'));
            const maxHeightValue = 540 - topPixels - 20; // 20px bottom margin - ensure all text is visible
            const position = {
                    left: textLeft, 
                top: textTop || '80px',
                bottom: '20px', // Ensure text doesn't go below slide
                width: textMaxWidth || 'auto', // Use calculated max width
                    transform: (!hasChart && !hasImage) ? 'translateX(-50%)' : 'none', 
                    maxWidth: textMaxWidth,
                    maxHeight: `${maxHeightValue}px`,
                    bottom: '40px' // Ensure text doesn't go below this
            }
            
            // Background styles
            let backgroundHtml = ''
            if (bgStyle === 'gradient-dark') {
                backgroundHtml = `
                  <div class="absolute inset-0 bg-slate-950"></div>
                  <div class="absolute inset-0 bg-gradient-to-br from-indigo-600/45 via-slate-900/75 to-emerald-500/35"></div>
                  <div class="absolute -top-16 -left-10 h-52 w-52 rounded-full bg-emerald-500/20 blur-3xl"></div>
                  <div class="absolute -bottom-24 right-0 h-60 w-60 rounded-full bg-indigo-500/30 blur-3xl"></div>
                `
            } else if (bgStyle === 'gradient-light') {
                backgroundHtml = `
                  <div class="absolute inset-0 bg-gradient-to-br from-blue-50 via-indigo-50 to-emerald-50"></div>
                  <div class="absolute -top-16 -left-10 h-52 w-52 rounded-full bg-emerald-200/30 blur-3xl"></div>
                  <div class="absolute -bottom-24 right-0 h-60 w-60 rounded-full bg-indigo-200/30 blur-3xl"></div>
                `
            } else if (bgStyle === 'solid-dark') {
                backgroundHtml = `<div class="absolute inset-0 bg-slate-900"></div>`
            } else if (bgStyle === 'solid-light') {
                backgroundHtml = `<div class="absolute inset-0 bg-slate-100"></div>`
            } else if (bgStyle === 'white') {
                backgroundHtml = `<div class="absolute inset-0 bg-white"></div>`
            } else if (bgStyle === 'custom') {
                backgroundHtml = `<div class="absolute inset-0" style="background-color: ${customColor};"></div>`
            } else if (bgStyle === 'aramco-ados') {
                // ADOS Project Update Template - Exact match
                backgroundHtml = `
                  <div class="absolute inset-0 bg-white"></div>
                  <div class="absolute top-0 left-0 right-0 h-12 bg-blue-600"></div>
                  <div class="absolute top-12 left-0 right-0 h-0.5 bg-slate-300"></div>
                `
            } else if (bgStyle === 'aramco-governance') {
                // SA SCDT - AD Governance Template - Exact match with logo
                backgroundHtml = `
                  <div class="absolute inset-0 bg-white"></div>
                  <div class="absolute top-3 left-4 flex items-center gap-2">
                    <div class="flex items-center gap-1.5">
                      <div class="w-5 h-5 rounded bg-gradient-to-br from-emerald-500 to-blue-500 flex items-center justify-center">
                        <span class="text-[0.5rem] font-bold text-white">A</span>
                      </div>
                      <span class="text-xs font-bold text-slate-700 uppercase tracking-tight">aramco</span>
                    </div>
                  </div>
                  <div class="absolute top-10 left-0 right-0 h-px bg-slate-300"></div>
                  <div class="absolute top-14 left-6 flex gap-1.5">
                    <div class="w-2 h-2 rounded-full bg-emerald-500"></div>
                    <div class="w-2 h-2 rounded-full bg-slate-300"></div>
                    <div class="w-2 h-2 rounded-full bg-slate-300"></div>
                  </div>
                `
            } else if (bgStyle === 'aramco-sao') {
                // SAO Master Template - Exact match with aramco digital logo
                backgroundHtml = `
                  <div class="absolute inset-0 bg-white"></div>
                  <div class="absolute top-0 left-0 right-0 h-14 bg-slate-800"></div>
                  <div class="absolute top-2 left-4 flex items-center gap-2">
                    <div class="flex items-center gap-1.5">
                      <div class="w-5 h-5 rounded bg-gradient-to-br from-emerald-500 to-blue-500 flex items-center justify-center">
                        <span class="text-[0.5rem] font-bold text-white">A</span>
                      </div>
                      <div class="flex flex-col">
                        <span class="text-xs font-bold text-white uppercase tracking-tight leading-tight">aramco</span>
                        <span class="text-[0.6rem] font-semibold text-white/90 uppercase tracking-tight leading-tight">digital</span>
                      </div>
                    </div>
                  </div>
                  <div class="absolute top-16 left-6 space-y-1.5">
                    <div class="h-0.5 bg-slate-300 w-48"></div>
                    <div class="h-0.5 bg-slate-300 w-40"></div>
                    <div class="h-0.5 bg-slate-300 w-52"></div>
                  </div>
                `
            }
            
            // Text color based on background
            const textColor = (bgStyle === 'gradient-light' || bgStyle === 'solid-light' || bgStyle === 'white' || bgStyle === 'aramco-ados' || bgStyle === 'aramco-governance' || bgStyle === 'aramco-sao') ? 'text-slate-800' : 'text-white'
            const textColorLight = (bgStyle === 'gradient-light' || bgStyle === 'solid-light' || bgStyle === 'white' || bgStyle === 'aramco-ados' || bgStyle === 'aramco-governance' || bgStyle === 'aramco-sao') ? 'text-slate-600' : 'text-slate-200'
            
            return `
              <div class="absolute inset-0 overflow-hidden rounded-[14px]">
                ${backgroundHtml}
                <div class="relative h-full w-full ${textColor}" data-slide-container="${currentSlideId}">
                  <div class="flex flex-col gap-3 absolute draggable-container" style="left: ${position.left || 'auto'}; top: ${position.top || '80px'}; right: ${position.right || 'auto'}; bottom: ${position.bottom || '20px'} !important; transform: ${position.transform || 'none'}; max-width: ${position.maxWidth || 'calc(100% - 80px)'}; width: ${position.width || 'auto'}; max-height: ${position.maxHeight || 'calc(100% - 100px)'} !important; overflow: hidden !important; z-index: 100; pointer-events: auto; display: flex !important; visibility: visible !important; opacity: 1 !important; position: absolute !important; box-sizing: border-box !important; align-items: flex-start !important; border: 2px solid transparent !important;">
                    ${showBadge ? `<span class="inline-flex w-fit items-center gap-2.5 rounded-full border ${textColor === 'text-white' ? 'border-white/25 bg-white/10 backdrop-blur-sm shadow-lg' : 'border-slate-300/50 bg-white/80 backdrop-blur-sm shadow-md'} px-5 py-1.5 text-[0.65rem] font-bold uppercase tracking-[0.4em] ${textColor === 'text-white' ? 'text-emerald-300' : 'text-slate-700'} animate-slideInDown" style="z-index: 101; animation-duration: 0.5s; display: inline-flex !important; visibility: visible !important;">
                      ${escapeHtml(badgeLabel)}
                    </span>` : ''}
                    ${showTitle ? `<div style="position: relative; display: inline-block; width: 100%;">
                      <h2 
                      contenteditable="true" 
                        spellcheck="true"
                      data-editable-title="${currentSlideId}"
                        class="draggable-text text-3xl font-bold tracking-tight outline-none focus:ring-2 focus:ring-emerald-400/50 focus:bg-white/5 rounded-lg px-3 py-1 -mx-3 -my-1 cursor-text hover:bg-white/5 transition-all duration-200 animate-fadeIn"
                        style="min-height: 2.5rem; z-index: 102; position: relative; line-height: 1.2; letter-spacing: -0.02em; width: 100%; max-width: 100%; user-select: text !important; -webkit-user-select: text !important; -moz-user-select: text !important; pointer-events: auto !important; -webkit-user-modify: read-write-plaintext-only !important; overflow: visible; word-wrap: break-word; overflow-wrap: break-word; ${textColor === 'text-white' ? 'color: #ffffff !important; text-shadow: 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(0,0,0,0.3) !important;' : 'color: #1e293b !important; font-weight: 800 !important;'}; display: block !important; visibility: visible !important; opacity: 1 !important;"
                        onfocus="this.style.outline='2px solid rgba(16, 185, 129, 0.5)'; const toolbar=this.parentElement.querySelector('.text-format-toolbar'); if(toolbar) { toolbar.style.display='flex'; toolbar.style.position='absolute'; toolbar.style.zIndex='10000'; } const deleteBtn=this.parentElement.querySelector('.delete-text-btn'); if(deleteBtn) deleteBtn.style.display='block';"
                        onblur="setTimeout(() => { const toolbar=this.parentElement.querySelector('.text-format-toolbar'); if(toolbar) toolbar.style.display='none'; this.style.outline='none'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }, 200);"
                        oninput="if(typeof app !== 'undefined' && app.saveState) { clearTimeout(this._saveTimeout); this._saveTimeout = setTimeout(() => app.saveState(), 1000); }"
                      >${heading || 'Slide Title'}</h2>
                      <div class="text-format-toolbar" style="position: absolute; top: -45px; left: 0; display: none; gap: 4px; background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10000; flex-wrap: wrap; max-width: 400px;">
                        <input type="number" min="12" max="72" value="36" onchange="const h2=this.closest('div').parentElement.querySelector('h2'); if(h2) { h2.style.fontSize=this.value+'px'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="width: 60px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;" placeholder="Size" title="Font Size">
                        <input type="color" value="${textColor === 'text-white' ? '#ffffff' : '#1e293b'}" onchange="const h2=this.closest('div').parentElement.querySelector('h2'); if(h2) { h2.style.color=this.value; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="width: 40px; height: 28px; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer;" title="Text Color">
                        <button onclick="const h2=this.closest('div').parentElement.querySelector('h2'); if(h2) { h2.style.fontWeight=h2.style.fontWeight==='bold'?'normal':'bold'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-weight: bold;" title="Bold">B</button>
                        <button onclick="const h2=this.closest('div').parentElement.querySelector('h2'); if(h2) { h2.style.fontStyle=h2.style.fontStyle==='italic'?'normal':'italic'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-style: italic;" title="Italic">I</button>
                        <button onclick="const h2=this.closest('div').parentElement.querySelector('h2'); if(h2) { h2.style.textDecoration=h2.style.textDecoration==='underline'?'none':'underline'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; text-decoration: underline;" title="Underline">U</button>
                      </div>
                      <button 
                        class="delete-text-btn" 
                        onclick="this.parentElement.querySelector('h2').remove(); if(typeof app !== 'undefined' && app.saveState) app.saveState(); this.remove();"
                        style="position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: none; z-index: 1000; font-size: 14px; line-height: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"
                        title="Delete text"
                        onmouseenter="this.style.background='#dc2626'"
                        onmouseleave="this.style.background='#ef4444'"
                      ></button>
                    </div>` : ''}
                    ${showDescription ? (bodyPointsForTemplate.length >= 2 ? `
                      <div style="position: relative; width: 100%;">
                      <ul class="draggable-text ${textColorLight} outline-none space-y-2 list-none pl-0" 
                      contenteditable="true" 
                        spellcheck="true"
                      data-editable-description="${currentSlideId}"
                        style="min-height: 1.5rem; word-wrap: break-word; overflow-wrap: break-word; z-index: 103; position: relative; width: 100%; max-width: 100%; user-select: text !important; -webkit-user-select: text !important; -moz-user-select: text !important; pointer-events: auto !important; cursor: text !important; -webkit-user-modify: read-write-plaintext-only !important; overflow: hidden !important; box-sizing: border-box; display: flex !important; flex-direction: column !important; gap: 8px !important;"
                        onfocus="this.style.outline='2px solid rgba(16, 185, 129, 0.5)'; this.parentElement.querySelector('.delete-text-btn')?.style.setProperty('display', 'block', 'important');"
                        onblur="this.style.outline='none'; setTimeout(() => { if(typeof app !== 'undefined' && app.saveState) app.saveState(); }, 100);"
                        oninput="if(typeof app !== 'undefined' && app.saveState) { clearTimeout(this._saveTimeout); this._saveTimeout = setTimeout(() => app.saveState(), 1000); }">
                        ${bodyPointsForTemplate.map((point, idx) => `
                            <li class="flex items-start gap-3 animate-slideInUp" style="animation-delay: ${idx * 0.15}s; animation-duration: 0.6s; animation-fill-mode: both; animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1); margin-bottom: 6px; width: 100%; flex-shrink: 0;">
                                <span class="text-emerald-400 mt-1.5 flex-shrink-0 font-bold drop-shadow-lg" style="font-size: 0.75rem; line-height: 1.4; filter: drop-shadow(0 0 4px rgba(16, 185, 129, 0.3));"></span>
                                <span class="flex-1 leading-relaxed font-semibold" contenteditable="true" style="line-height: 1.5; font-size: 1rem; letter-spacing: 0.01em; min-height: 1.5rem; overflow: hidden !important; width: 100%; max-width: 100%; ${textColor === 'text-white' ? 'color: #ffffff !important; text-shadow: 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(0,0,0,0.3) !important;' : 'color: #1e293b !important; font-weight: 700 !important;'}; display: block !important; visibility: visible !important; opacity: 1 !important; user-select: text !important; -webkit-user-select: text !important; cursor: text !important; word-wrap: break-word; overflow-wrap: break-word; position: relative; box-sizing: border-box !important;" onfocus="this.closest('li').querySelector('.text-format-toolbar')?.style.setProperty('display', 'flex', 'important');" onblur="setTimeout(() => { this.closest('li').querySelector('.text-format-toolbar')?.style.setProperty('display', 'none', 'important'); if(typeof app !== 'undefined' && app.saveState) app.saveState(); }, 200);" oninput="if(typeof app !== 'undefined' && app.saveState) { clearTimeout(this._saveTimeout); this._saveTimeout = setTimeout(() => app.saveState(), 1000); }">
                                    ${escapeHtml(point)}
                                    <div class="text-format-toolbar" style="position: absolute; top: -50px; left: 0; display: none; gap: 4px; background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10000; flex-wrap: wrap; max-width: 450px; align-items: center;">
                                      <label style="font-size: 11px; color: #6b7280; margin-right: 4px;">Size:</label>
                                      <input type="number" min="10" max="40" value="16" onchange="const span=this.closest('div').parentElement; if(span) { span.style.fontSize=this.value+'px'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="width: 65px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;" placeholder="Size" title="Font Size">
                                      <label style="font-size: 11px; color: #6b7280; margin-left: 4px; margin-right: 4px;">Color:</label>
                                      <input type="color" value="${textColor === 'text-white' ? '#ffffff' : '#1e293b'}" onchange="const span=this.closest('div').parentElement; if(span) { span.style.color=this.value; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="width: 40px; height: 32px; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer;" title="Text Color">
                                      <button onclick="const el=this.closest('div').parentElement; el.style.fontWeight=el.style.fontWeight==='bold'?'normal':'bold'; this.style.background=el.style.fontWeight==='bold'?'#e5e7eb':'white'; if(typeof app !== 'undefined' && app.saveState) app.saveState();" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.2s;" title="Bold">B</button>
                                      <button onclick="const el=this.closest('div').parentElement; el.style.fontStyle=el.style.fontStyle==='italic'?'normal':'italic'; this.style.background=el.style.fontStyle==='italic'?'#e5e7eb':'white'; if(typeof app !== 'undefined' && app.saveState) app.saveState();" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-style: italic; font-size: 13px; transition: all 0.2s;" title="Italic">I</button>
                                      <button onclick="const el=this.closest('div').parentElement; el.style.textDecoration=el.style.textDecoration==='underline'?'none':'underline'; this.style.background=el.style.textDecoration==='underline'?'#e5e7eb':'white'; if(typeof app !== 'undefined' && app.saveState) app.saveState();" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; text-decoration: underline; font-size: 13px; transition: all 0.2s;" title="Underline">U</button>
                                    </div>
                                </span>
                            </li>
                        `).join('')}
                        </ul>
                        <button 
                          class="delete-text-btn" 
                          onclick="this.parentElement.querySelector('ul').remove(); if(typeof app !== 'undefined' && app.saveState) app.saveState(); this.remove();"
                          style="position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: none; z-index: 1000; font-size: 14px; line-height: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"
                          title="Delete text"
                          onmouseenter="this.style.background='#dc2626'"
                          onmouseleave="this.style.background='#ef4444'"
                        ></button>
                      </div>` : `
                      <div style="position: relative; width: 100%;">
                      <p 
                        contenteditable="true" 
                          spellcheck="true"
                        data-editable-description="${currentSlideId}"
                          class="draggable-text text-lg ${textColorLight} outline-none focus:ring-2 focus:ring-emerald-400/50 focus:bg-white/5 rounded-lg px-3 py-1 -mx-3 -my-1 cursor-text hover:bg-white/5 transition-all duration-200 leading-relaxed animate-fadeIn"
                          style="min-height: 1.5rem; max-height: none; word-wrap: break-word; overflow-wrap: break-word; overflow: hidden !important; line-height: 1.7; letter-spacing: 0.01em; z-index: 103; position: relative; width: 100%; max-width: 100%; user-select: text !important; -webkit-user-select: text !important; -moz-user-select: text !important; pointer-events: auto !important; -webkit-user-modify: read-write-plaintext-only !important; box-sizing: border-box; ${textColor === 'text-white' ? 'color: #ffffff !important; text-shadow: 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(0,0,0,0.3) !important; font-weight: 600 !important;' : 'color: #1e293b !important; font-weight: 700 !important;'}; display: block !important; visibility: visible !important; opacity: 1 !important;"
                          onfocus="this.style.outline='2px solid rgba(16, 185, 129, 0.5)'; this.parentElement.querySelector('.delete-text-btn')?.style.setProperty('display', 'block', 'important'); this.parentElement.querySelector('.text-format-toolbar')?.style.setProperty('display', 'flex', 'important');"
                          onblur="setTimeout(() => { this.style.outline='none'; this.parentElement.querySelector('.text-format-toolbar')?.style.setProperty('display', 'none', 'important'); if(typeof app !== 'undefined' && app.saveState) app.saveState(); }, 200);"
                          oninput="if(typeof app !== 'undefined' && app.saveState) { clearTimeout(this._saveTimeout); this._saveTimeout = setTimeout(() => app.saveState(), 1000); }"
                        >${body || 'Add your content here...'}</p>
                        <div class="text-format-toolbar" style="position: absolute; top: -50px; left: 0; display: none; gap: 4px; background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10000; flex-wrap: wrap; max-width: 450px; align-items: center;">
                          <label style="font-size: 11px; color: #6b7280; margin-right: 4px;">Size:</label>
                          <input type="number" min="10" max="60" value="18" onchange="const p=this.closest('div').parentElement.querySelector('p'); if(p) { p.style.fontSize=this.value+'px'; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="width: 65px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;" placeholder="Size" title="Font Size">
                          <label style="font-size: 11px; color: #6b7280; margin-left: 4px; margin-right: 4px;">Color:</label>
                          <input type="color" value="${textColor === 'text-white' ? '#ffffff' : '#1e293b'}" onchange="const p=this.closest('div').parentElement.querySelector('p'); if(p) { p.style.color=this.value; if(typeof app !== 'undefined' && app.saveState) app.saveState(); }" style="width: 40px; height: 32px; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer;" title="Text Color">
                          <button onclick="const el=this.closest('div').previousElementSibling; el.style.fontWeight=el.style.fontWeight==='bold'?'normal':'bold'; this.style.background=el.style.fontWeight==='bold'?'#e5e7eb':'white'; if(typeof app !== 'undefined' && app.saveState) app.saveState();" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.2s;" title="Bold">B</button>
                          <button onclick="const el=this.closest('div').previousElementSibling; el.style.fontStyle=el.style.fontStyle==='italic'?'normal':'italic'; this.style.background=el.style.fontStyle==='italic'?'#e5e7eb':'white'; if(typeof app !== 'undefined' && app.saveState) app.saveState();" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-style: italic; font-size: 13px; transition: all 0.2s;" title="Italic">I</button>
                          <button onclick="const el=this.closest('div').previousElementSibling; el.style.textDecoration=el.style.textDecoration==='underline'?'none':'underline'; this.style.background=el.style.textDecoration==='underline'?'#e5e7eb':'white'; if(typeof app !== 'undefined' && app.saveState) app.saveState();" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; text-decoration: underline; font-size: 13px; transition: all 0.2s;" title="Underline">U</button>
                        </div>
                        <button 
                          class="delete-text-btn" 
                          onclick="this.parentElement.querySelector('p').remove(); if(typeof app !== 'undefined' && app.saveState) app.saveState(); this.remove();"
                          style="position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: none; z-index: 1000; font-size: 14px; line-height: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"
                          title="Delete text"
                          onmouseenter="this.style.background='#dc2626'"
                          onmouseleave="this.style.background='#ef4444'"
                        ></button>
                      </div>
                    `) : ''}
                    ${showSlideNumber ? `<div class="text-xs ${textColorLight} opacity-60" style="z-index: 104; position: relative;">Slide ${index + 1} / ${total}</div>` : ''}
                  </div>
                  
                  ${hasImage ? (() => {
                    const imageEl = slide.els.find(el => el.type === 'image');
                    if (imageEl && imageEl.src) {
                      const imgX = imageEl.x || 30;
                      const imgY = imageEl.y || 100;
                      const imgW = imageEl.width || 350;
                      const imgH = imageEl.height || 340;
                      return `
                        <div class="absolute" style="left: ${imgX}px; top: ${imgY}px; width: ${imgW}px; height: ${imgH}px; z-index: 50; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
                          <img src="${imageEl.src}" alt="${escapeHtml(slide.title || 'Slide image')}" style="width: 100%; height: 100%; object-fit: cover; display: block;" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #667eea 0%, #764ba2 100%)';" />
                        </div>
                      `;
                    }
                    return '';
                  })() : ''}
                  
                  ${hasChart ? (() => {
                    const chartEl = slide.els.find(el => el.type === 'chart');
                    if (chartEl) {
                      // For Flow Chart: Center it and make it larger
                      const isFlow = chartEl.chartType === 'flow';
                      const chartX = isFlow ? 320 : (chartEl.x || 600);
                      const chartY = isFlow ? 120 : (chartEl.y || 100);
                      const chartW = isFlow ? 320 : (chartEl.width || 320);
                      const chartH = isFlow ? 380 : (chartEl.height || 340);
                      return `
                        <div class="absolute flow-chart-container" style="left: ${chartX}px; top: ${chartY}px; width: ${chartW}px; height: ${chartH}px; z-index: 50; background: rgba(255,255,255,0.05); border-radius: 12px; padding: ${isFlow ? '20px' : '16px'}; backdrop-blur-sm; cursor: pointer;" data-chart-id="${chartEl.id}" onclick="if(typeof app !== 'undefined' && app.editChart) app.editChart('${chartEl.id}')" title="Click to edit Flow Chart">
                          <canvas id="chart-${index}-${Date.now()}" width="${chartW}" height="${chartH}"></canvas>
                          ${isFlow ? `<div style="position: absolute; top: 8px; right: 8px; background: rgba(16, 185, 129, 0.9); color: white; border-radius: 6px; padding: 4px 8px; font-size: 11px; font-weight: 600; pointer-events: none; opacity: 0.8;">Edit</div>` : ''}
                        </div>
                      `;
                    }
                    return '';
                  })() : ''}
                  
                  ${customElementsHtml}
                </div>
              </div>
            `
        }

        function createAISlidePreview(slide, index, context) {
            // Create a mini version of the actual slide with same elements
            const heading = escapeHtml(slide.title || slide.heading || `Slide ${index + 1}`)
            const body = escapeHtml(slide.description || slide.summary || context.descriptionSentence || '')
            
            // Get design preferences
            const design = slide.design || {}
            const bgStyle = design.background || 'gradient-dark'
            const customColor = design.customColor || '#0f172a'
            
            // Check for elements
            const hasElementsPreview = slide.els && slide.els.length > 0;
            const hasImage = hasElementsPreview && slide.els.some(el => el.type === 'image');
            const hasChart = hasElementsPreview && slide.els.some(el => el.type === 'chart');
            
            // Background styles (mini version)
            let backgroundHtml = ''
            if (bgStyle === 'gradient-dark') {
                backgroundHtml = `<div class="absolute inset-0 bg-slate-950"></div><div class="absolute inset-0 bg-gradient-to-br from-indigo-600/45 via-slate-900/75 to-emerald-500/35"></div>`
            } else if (bgStyle === 'gradient-light') {
                backgroundHtml = `<div class="absolute inset-0 bg-gradient-to-br from-blue-50 via-indigo-50 to-emerald-50"></div>`
            } else if (bgStyle === 'solid-dark') {
                backgroundHtml = `<div class="absolute inset-0 bg-slate-900"></div>`
            } else if (bgStyle === 'solid-light') {
                backgroundHtml = `<div class="absolute inset-0 bg-slate-100"></div>`
            } else if (bgStyle === 'white') {
                backgroundHtml = `<div class="absolute inset-0 bg-white"></div>`
            } else if (bgStyle === 'custom') {
                backgroundHtml = `<div class="absolute inset-0" style="background-color: ${customColor};"></div>`
            } else {
                backgroundHtml = `<div class="absolute inset-0 bg-slate-950"></div><div class="absolute inset-0 bg-gradient-to-br from-indigo-600/45 via-slate-900/75 to-emerald-500/35"></div>`
            }
            
            // Text color
            const textColor = (bgStyle === 'gradient-light' || bgStyle === 'solid-light' || bgStyle === 'white') ? 'text-slate-800' : 'text-white'
            
            // Image preview (mini)
            let imageHtml = '';
            let imageEl = null;
            if (hasImage) {
                imageEl = slide.els.find(el => el.type === 'image');
                if (imageEl && imageEl.src) {
                    // Scale down for preview: original x:30, y:100, w:350, h:340
                    // Preview is ~160px wide, so scale factor is ~160/960 = 0.167
                    const scale = 0.167;
                    const imgX = (imageEl.x || 30) * scale;
                    const imgY = (imageEl.y || 100) * scale;
                    const imgW = (imageEl.width || 350) * scale;
                    const imgH = (imageEl.height || 340) * scale;
                    imageHtml = `
                        <div class="absolute" style="left: ${imgX}px; top: ${imgY}px; width: ${imgW}px; height: ${imgH}px; border-radius: 4px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">
                            <img src="${imageEl.src}" alt="" style="width: 100%; height: 100%; object-fit: cover; display: block;" onerror="this.style.display='none';" />
                        </div>
                    `;
                }
            }
            
            // Chart preview (mini)
            let chartHtml = '';
            let chartEl = null;
            if (hasChart) {
                chartEl = slide.els.find(el => el.type === 'chart');
                if (chartEl) {
                    const scale = 0.167;
                    const chartX = (chartEl.x || 600) * scale;
                    const chartY = (chartEl.y || 100) * scale;
                    const chartW = (chartEl.width || 320) * scale;
                    const chartH = (chartEl.height || 340) * scale;
                    chartHtml = `
                        <div class="absolute" style="left: ${chartX}px; top: ${chartY}px; width: ${chartW}px; height: ${chartH}px; background: rgba(255,255,255,0.1); border-radius: 4px; backdrop-blur-sm;"></div>
                    `;
                }
            }
            
            // Text preview (mini) - positioned same as main slide
            let textLeft = '50%';
            let textMaxWidth = '60%';
            const scale = 0.167;
            if (hasImage && !hasChart && imageEl) {
                // Image on left, text on right
                textLeft = `${((imageEl.x || 30) + (imageEl.width || 350) + 20) * scale}px`;
                textMaxWidth = `${(960 - (imageEl.x || 30) - (imageEl.width || 350) - 40) * scale}px`;
            } else if (hasImage && hasChart && imageEl && chartEl) {
                // Image left, text middle, chart right
                textLeft = `${((imageEl.x || 30) + (imageEl.width || 350) + 20) * scale}px`;
                textMaxWidth = `${((chartEl.x || 600) - (imageEl.x || 30) - (imageEl.width || 350) - 40) * scale}px`;
            }
            
            // Split body into points for preview
            const bodyPoints = body.split(/[\-\*]/).filter(p => p.trim().length > 10).slice(0, 2);
            const bodyText = bodyPoints.length > 0 ? bodyPoints.map(p => p.trim()).join('  ') : body.substring(0, 80);
            
            return `
              <div class="absolute inset-0 rounded-lg overflow-hidden">
                ${backgroundHtml}
                ${imageHtml}
                ${chartHtml}
                <div class="absolute" style="left: ${textLeft}; top: 8px; max-width: ${textMaxWidth}; transform: ${hasImage ? 'none' : 'translateX(-50%)'};">
                  <p class="text-[0.5rem] font-bold ${textColor} line-clamp-1 leading-tight" style="${textColor === 'text-white' ? 'text-shadow: 0 1px 2px rgba(0,0,0,0.5);' : ''}">${heading}</p>
                  <p class="text-[0.4rem] ${textColor === 'text-white' ? 'text-slate-200' : 'text-slate-600'} line-clamp-2 leading-tight mt-0.5">${bodyText}</p>
                </div>
              </div>
            `
        }

        function updateUrlForAIDeck(title, description, slideCount) {
            if (!window.history?.replaceState) return
            const params = new URLSearchParams(window.location.search)
            params.set('template', 'ai')
            params.set('subject', title)
            if (description && description.trim().length) {
                params.set('description', description.trim())
            } else {
                params.delete('description')
            }
            params.set('slides', String(slideCount))
            const newUrl = `${window.location.pathname}?${params.toString()}`
            window.history.replaceState({}, '', newUrl)
        }

        let slideSequence = 0

        function createAISlideObject(slide, index, total, context, designOverride = null) {
            slideSequence += 1
            
            // Apply design override if provided
            const finalDesign = designOverride || slide.design || {
                background: 'gradient-dark',
                customColor: '#0f172a',
                showTitle: true,
                showDescription: true,
                showBadge: true,
                showSlideNumber: true,
                layoutPosition: 'center',
            }
            
            // Create slide with design applied (preserve els if present)
            const slideWithDesign = {
                ...slide,
                summary: slide.summary || slide.description || '',
                description: slide.description || slide.summary || '',
                design: finalDesign,
                els: slide.els || [] // Preserve elements array
            }
            
            const slideId = `slide-${slideSequence}`
            return {
                id: slideId,
                variant: 'ai',
                title: slide.title || `Slide ${index + 1}`,
                description: slide.description || slide.summary || '',
                summary: slide.summary || slide.description || '', // Keep summary separately
                notes: slide.notes || '',
                notesOpen: false,
                customElements: slide.customElements || [],
                design: finalDesign,
                stageHtml: createAISlideStage(slideWithDesign, index, total, context, slideId),
                previewHtml: createAISlidePreview(slide, index, context),
            }
        }

        async function replaceSlidesWithAIGeneration(inputs = {}, options = {}) {
            const { silent = false, slideBlueprint = null, design = null } = options
            const rawTitle = typeof inputs.title === 'string' ? inputs.title : ''
            const rawDescription = typeof inputs.description === 'string' ? inputs.description : ''
            const rawSlides = Number.parseInt(inputs.slideCount, 10)
            
            // Show loading message if not silent
            if (!silent) {
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'ai-generation-loading';
                loadingOverlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 20px;';
                loadingOverlay.innerHTML = `
                    <div style="background: white; padding: 30px 40px; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); text-align: center;">
                        <div style="width: 50px; height: 50px; border: 4px solid #e5e7eb; border-top-color: #10b981; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                        <div style="font-size: 18px; font-weight: 600; color: #1e293b; margin-bottom: 8px;">Creating slides...</div>
                        <div style="font-size: 14px; color: #64748b;">Please wait, this may take a few moments</div>
                    </div>
                    <style>
                        @keyframes spin { to { transform: rotate(360deg); } }
                    </style>
                `;
                document.body.appendChild(loadingOverlay);
            }

            const sanitizedTitle = rawTitle.trim().replace(/\s{2,}/g, ' ')
            const deckTitleText = sanitizedTitle.length ? sanitizedTitle : 'AI Strategy Briefing'
            const slideTotal = clamp(
                Number.isNaN(rawSlides) ? DEFAULT_AI_SLIDE_COUNT : rawSlides,
                MIN_AI_SLIDES,
                MAX_AI_SLIDES
            )
            const context = buildSubjectContext(deckTitleText, rawDescription)
            
            // If slideBlueprint is provided, generate content for each title based on main subject
            let slidesToUse = [];
            if (slideBlueprint && Array.isArray(slideBlueprint) && slideBlueprint.length > 0) {
                console.log(` Generating content for ${slideBlueprint.length} slides with titles from blueprint`);
                console.log(`   Main subject: "${deckTitleText}"`);
                
                // Generate content for each title in the blueprint
                slidesToUse = await Promise.all(slideBlueprint.map(async (blueprintSlide, index) => {
                    const slideTitle = blueprintSlide.title || `Slide ${index + 1}`;
                    
                    // Generate content for this specific slide title about the main subject
                    try {
                        const aiSlides = await fetchFreeAIDeckPlan({
                            title: deckTitleText,
                            description: `Generate VERY DETAILED and COMPREHENSIVE content for a slide titled "${slideTitle}" about "${deckTitleText}". The slide must be SPECIFICALLY about "${deckTitleText}" and relate "${slideTitle}" to "${deckTitleText}". Include specific examples, real data, statistics, and detailed explanations. Minimum 150 words of content. EVERY sentence must mention or relate to "${deckTitleText}".`,
                            slideCount: 1
                        });
                        
                        if (aiSlides && aiSlides.length > 0) {
                            const aiSlide = aiSlides[0];
                            return {
                                title: slideTitle, // Use the blueprint title
                                description: aiSlide.description || aiSlide.summary || '',
                                summary: aiSlide.summary || aiSlide.description || '',
                                notes: aiSlide.notes || '',
                                originalSubject: deckTitleText.toLowerCase().trim(),
                                subject: deckTitleText.toLowerCase().trim()
                            };
                        }
                    } catch (error) {
                        console.error(` Error generating content for slide "${slideTitle}":`, error);
                    }
                    
                    // Fallback if generation fails
                    return {
                        title: slideTitle,
                        description: `Content about ${deckTitleText}: ${slideTitle}`,
                        summary: `This slide discusses ${slideTitle} in the context of ${deckTitleText}.`,
                        notes: '',
                        originalSubject: deckTitleText.toLowerCase().trim(),
                        subject: deckTitleText.toLowerCase().trim()
                    };
                }));
                
                console.log(` Generated content for ${slidesToUse.length} slides`);
            } else {
                // No blueprint - use standard generation
            const fallbackSlides = generateAISlides(context, slideTotal)
                slidesToUse = overlaySlidesWithBlueprint(fallbackSlides, slideBlueprint)
            }

            slideSequence = 0
            
            // Gamma-style design - Professional, modern, engaging
            const finalDesign = design ? {
                background: design.background || 'gradient-dark',
                customColor: design.customColor || '#0f172a',
                showTitle: true,
                showDescription: true,
                showBadge: true,
                showSlideNumber: true,
                layoutPosition: 'center',
            } : {
                // Default Gamma-style design
                background: 'gradient-dark',
                customColor: '#0f172a',
                showTitle: true,
                showDescription: true,
                showBadge: true,
                showSlideNumber: true,
                layoutPosition: 'center',
            }
            
            // Smart function to determine if slide needs an image - ENHANCED
            function shouldAddImage(slide, index) {
                const content = (slide.description || slide.summary || slide.title || '').toLowerCase();
                const title = (slide.title || '').toLowerCase();
                const fullText = content + ' ' + title;
                
                // DON'T add image to Flow Chart slides
                if (title.includes('flow chart') || title.includes('flowchart') || title.includes('flow') && (title.includes('chart') || title.includes('diagram') || title.includes('process'))) {
                    return false;
                }
                
                // Comprehensive visual keywords that suggest images
                const imageKeywords = [
                    // Technology & AI
                    'technology', 'digital', 'innovation', 'ai', 'artificial intelligence', 'machine learning', 'ml', 'deep learning',
                    'data', 'analytics', 'cloud', 'software', 'hardware', 'device', 'system', 'platform', 'computing',
                    // Business & Strategy
                    'business', 'strategy', 'growth', 'market', 'customer', 'user', 'team', 'people', 'organization',
                    'product', 'service', 'solution', 'architecture', 'design', 'process', 'workflow', 'enterprise',
                    // Industry specific
                    'healthcare', 'medical', 'hospital', 'patient', 'treatment', 'care', 'veterinary', 'animal', 'cat', 'dog',
                    'finance', 'banking', 'financial', 'investment', 'trading', 'money',
                    'education', 'learning', 'school', 'university', 'student', 'training',
                    'retail', 'shopping', 'store', 'ecommerce', 'online',
                    'manufacturing', 'production', 'factory', 'industrial',
                    // General
                    'network', 'security', 'cyber', 'mobile', 'web', 'app', 'application',
                    'transformation', 'change', 'evolution', 'future', 'vision', 'roadmap',
                    'infrastructure', 'company', 'corporate', 'office', 'meeting', 'presentation'
                ];
                
                // Check if content matches image keywords
                const hasImageKeywords = imageKeywords.some(keyword => fullText.includes(keyword));
                
                // Strong visual indicators - always add image
                const strongVisualIndicators = [
                    'veterinary', 'medical', 'healthcare', 'patient', 'treatment', 'care',
                    'technology', 'digital', 'innovation', 'ai', 'artificial intelligence',
                    'business', 'strategy', 'growth', 'market', 'customer'
                ];
                const hasStrongVisual = strongVisualIndicators.some(keyword => fullText.includes(keyword));
                
                // Don't add image to first slide (cover) unless explicitly needed
                if (index === 0 && !hasStrongVisual) {
                    return false;
                }
                
                // Add image if has keywords or strong visual indicators
                return hasImageKeywords || hasStrongVisual;
            }
            
            // Smart function to determine if slide needs a chart - ENHANCED
            function shouldAddChart(slide, index) {
                const content = (slide.description || slide.summary || slide.title || '').toLowerCase();
                const title = (slide.title || '').toLowerCase();
                const fullText = content + ' ' + title;
                
                // Data/metrics keywords - expanded list
                const dataKeywords = [
                    'percent', 'percentage', '%', 'growth', 'increase', 'decrease', 'trend',
                    'statistics', 'data', 'metrics', 'kpi', 'performance', 'result', 'outcome',
                    'comparison', 'compare', 'versus', 'vs', 'analysis', 'forecast', 'projection',
                    'revenue', 'sales', 'profit', 'cost', 'budget', 'expense', 'income',
                    'market share', 'adoption', 'usage', 'users', 'customers', 'clients',
                    'quarter', 'q1', 'q2', 'q3', 'q4', 'year', 'annual', 'monthly', 'weekly',
                    'distribution', 'breakdown', 'segment', 'category', 'region', 'country',
                    'chart', 'graph', 'visualization', 'metric', 'measurement', 'indicator',
                    'progress', 'milestone', 'achievement', 'target', 'goal', 'objective',
                    'number', 'value', 'amount', 'total', 'figure', 'statistic'
                ];
                
                // Check for numbers in content (including percentages)
                const numberMatches = fullText.match(/\d+(\.\d+)?%?/g);
                const hasNumbers = numberMatches && numberMatches.length > 0;
                const hasMultipleNumbers = numberMatches && numberMatches.length >= 2; // At least 2 numbers
                const hasPercentages = /%\s*\d+|\d+\s*%/.test(fullText);
                const hasDataKeywords = dataKeywords.some(keyword => fullText.includes(keyword));
                
                // More lenient: add chart if has multiple numbers OR (has numbers AND data keywords)
                // This ensures charts are added when there's actual data to visualize
                return hasMultipleNumbers || (hasNumbers && hasDataKeywords);
            }
            
            // PERFECT ORGANIZATION: Organize elements to prevent overlap
            function organizeElements(elements) {
                if (!elements || elements.length === 0) return;
                
                const images = elements.filter(el => el.type === 'image');
                const charts = elements.filter(el => el.type === 'chart');
                
                // PERFECT ORGANIZATION: Images on LEFT, Charts on FAR RIGHT
                images.forEach((img, idx) => {
                    img.x = 30; // FIXED: Always on LEFT
                    img.y = 100; // FIXED: Top aligned
                    img.width = charts.length > 0 ? 320 : 360; // Organized width
                    img.height = 340; // FIXED: Consistent height
                });
                
                charts.forEach((chart, idx) => {
                    chart.x = 640; // FIXED: Always on FAR RIGHT for perfect organization
                    chart.y = 100; // FIXED: Top aligned with image
                    chart.width = 280; // Organized width
                    chart.height = 340; // FIXED: Same height as image
                });
                
                console.log(` Organized ${images.length} images and ${charts.length} charts - PERFECT LAYOUT`);
            }
            
            // Get relevant image URL based on TITLE - USE DALL-E 3 FOR AI-GENERATED IMAGES
            async function getImageUrl(slide) {
                // PRIORITY: Generate highly relevant images using DALL-E 3 based on title/content
                const title = (slide.title || slide.heading || '').trim();
                const content = (slide.description || slide.summary || slide.content || '').trim();
                
                // CRITICAL: Use the original subject from the main presentation title
                // This ensures images are always related to the main topic
                const originalSubject = (slide.originalSubject || slide.subject || '').toLowerCase().trim();
                
                // Common words to remove
                const commonWords = ['introduction', 'to', 'the', 'of', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'for', 'with', 'by', 'from', 'about', 'understanding', 'exploring', 'overview', 'guide', 'basics', 'fundamentals', 'how', 'what', 'why', 'when', 'where', 'role', 'impact', 'challenges', 'types', 'components', 'mechanics', 'vision', 'now', 'next', 'days', 'plan', 'landscape', 'opportunity', 'solution', 'architecture', 'data', 'platform', 'readiness', 'value', 'realization', 'roadmap'];
                
                // Use original subject if available (from main presentation title)
                let mainSubject = originalSubject;
                
                // If no original subject, extract from slide title
                if (!mainSubject || mainSubject.length < 2) {
                    const titleWords = title.toLowerCase()
                        .replace(/[^\w\s]/g, ' ')
                        .split(/\s+/)
                        .filter(word => word.length > 2 && !commonWords.includes(word));
                    
                    // Get main subject (first meaningful word or phrase)
                    mainSubject = titleWords.length > 0 ? titleWords[0] : title.toLowerCase().substring(0, 20);
                    
                    // If we have multiple meaningful words, use them
                    if (titleWords.length > 1) {
                        const meaningfulWords = titleWords.slice(0, 2).join(' ');
                        if (meaningfulWords.length > 3 && meaningfulWords.length < 30) {
                            mainSubject = meaningfulWords;
                        }
                    }
                }
                
                // Clean up: remove common prefixes/suffixes
                mainSubject = mainSubject.replace(/^(the|a|an)\s+/i, '').trim();
                
                // If still empty or too short, use a default
                if (!mainSubject || mainSubject.length < 2) {
                    mainSubject = 'technology';
                }
                
                // Extract key terms from content for better context
                let contentKeywords = '';
                if (content && content.length > 0) {
                    // Extract important technical terms (longer words are usually more specific)
                    const contentWords = content.toLowerCase()
                        .replace(/[^\w\s]/g, ' ')
                        .split(/\s+/)
                        .filter(word => word.length > 5 && !commonWords.includes(word))
                        .slice(0, 2);
                    
                    if (contentWords.length > 0) {
                        contentKeywords = contentWords.join(' ');
                    }
                }
                
                // Create very specific prompt
                let imagePrompt = mainSubject;
                if (contentKeywords) {
                    imagePrompt = `${mainSubject} ${contentKeywords}`;
                }
                
                // Clean up and limit length
                imagePrompt = imagePrompt.trim().substring(0, 80);
                
                console.log(` Generating highly relevant image for: "${title}"`);
                console.log(`   Main subject: "${mainSubject}"`);
                console.log(`   Content keywords: "${contentKeywords}"`);
                console.log(`   Full prompt: "${imagePrompt}"`);
                
                // Try DALL-E 3 with retry logic (MUST be relevant to topic)
                const openAIKey = app.getOpenAIKey();
                if (openAIKey && openAIKey.startsWith('sk-')) {
                    // Retry up to 2 times for better reliability
                    for (let attempt = 0; attempt < 3; attempt++) {
                        try {
                            // Create very simple prompt for DALL-E 3
                            // DALL-E 3 prefers short, keyword-based prompts (under 100 chars works best)
                            let dallePrompt = '';
                            
                            // Use very simple, keyword-based prompts
                            const subjectLower = mainSubject.toLowerCase();
                            
                            if (subjectLower.includes('robotic') || subjectLower.includes('robot')) {
                                dallePrompt = `robots, robotic arms, industrial automation`;
                            } else if (subjectLower.includes('ai') || subjectLower.includes('artificial') || subjectLower.includes('intelligence')) {
                                dallePrompt = `AI technology, neural networks`;
                            } else if (subjectLower.includes('health') || subjectLower.includes('medical')) {
                                dallePrompt = `medical equipment, healthcare`;
                            } else if (subjectLower.includes('data') || subjectLower.includes('platform')) {
                                dallePrompt = `data analytics, digital platform`;
                            } else if (subjectLower.includes('roadmap') || subjectLower.includes('next') || subjectLower.includes('plan')) {
                                dallePrompt = `strategic planning, business roadmap`;
                            } else if (subjectLower.includes('opportunity') || subjectLower.includes('landscape') || subjectLower.includes('market')) {
                                dallePrompt = `business opportunities, market growth`;
                            } else if (subjectLower.includes('solution') || subjectLower.includes('architecture')) {
                                dallePrompt = `solution architecture, system design`;
                            } else if (subjectLower.includes('vision')) {
                                dallePrompt = `future vision, innovation`;
                } else {
                                // Use just the main subject (first 2 words max)
                                const words = mainSubject.split(' ').slice(0, 2).join(' ');
                                dallePrompt = words.toLowerCase();
                            }
                            
                            // Add minimal style (keep total under 100 chars for best results)
                            dallePrompt = `${dallePrompt}, professional, high quality`.trim();
                            
                            // Keep it very short (under 100 chars for best results)
                            dallePrompt = dallePrompt.substring(0, 100);
                            
                            if (attempt > 0) {
                                console.log(` DALL-E retry attempt ${attempt + 1}/3 for "${title}"`);
                                await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Wait before retry
                            } else {
                                console.log(` Calling DALL-E 3 with specific prompt (${dallePrompt.length} chars): "${dallePrompt}"`);
                            }
                            
                            // Use longer timeout (20 seconds) for better success rate
                            const dallePromise = fetch('https://api.openai.com/v1/images/generations', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${openAIKey}`
                                },
                                body: JSON.stringify({
                                    model: 'dall-e-3',
                                    prompt: dallePrompt,
                                    n: 1,
                                    size: '1024x1024',
                                    quality: 'standard'
                                })
                            });
                            
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('DALL-E timeout')), 20000) // 20 seconds
                            );
                            
                            const response = await Promise.race([dallePromise, timeoutPromise]);
                            
                            if (response.ok) {
                                const data = await response.json();
                                if (data.data && data.data[0] && data.data[0].url) {
                                    console.log(` DALL-E 3 generated highly relevant image for "${title}" (attempt ${attempt + 1})`);
                                    window.dalleErrorCount = 0; // Reset error count on success
                                    
                                    const imageUrl = data.data[0].url;
                                    
                                    // Fix CORS issue: Try multiple methods to load the image
                                    // Method 1: Try direct fetch with no-cors (for blob conversion)
                                    try {
                                        // Use no-cors mode to fetch the image (we can't read the response, but we can use it)
                                        const imageResponse = await fetch(imageUrl, {
                                            mode: 'no-cors'
                                        });
                                        
                                        // Since no-cors doesn't allow reading response, try alternative proxy
                                        // Use a more reliable CORS proxy
                                        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;
                                        console.log(` Using CORS proxy for DALL-E image: ${proxyUrl.substring(0, 80)}...`);
                                        return proxyUrl;
                                    } catch (fetchError) {
                                        console.warn(` CORS error, trying alternative proxy:`, fetchError);
                                        // Try alternative CORS proxy
                                        try {
                                            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;
                                            return proxyUrl;
                                        } catch (e) {
                                            // Final fallback - return original URL (might work in some browsers)
                                            console.warn(` All CORS proxies failed, returning original URL`);
                                            return imageUrl;
                                        }
                                    }
                                }
                            } else {
                                const status = response.status;
                                const errorData = await response.json().catch(() => ({}));
                                
                                console.error(` DALL-E API error ${status}:`, errorData);
                                
                                // For 400 errors, try with a much simpler prompt
                                if (status === 400) {
                                    console.warn(` DALL-E API client error 400 (Bad Request). Error details:`, errorData);
                                    if (attempt < 2) {
                                        // Use the simplest possible prompt on retry
                                        const simpleSubject = mainSubject.split(' ')[0]; // Just first word
                                        dallePrompt = `${simpleSubject}, professional business, high quality`;
                                        dallePrompt = dallePrompt.trim().substring(0, 100);
                                        console.log(` Retrying with very simple prompt (${dallePrompt.length} chars): "${dallePrompt}"`);
                                        continue; // Retry with simpler prompt
                                    } else {
                                        console.error(` DALL-E prompt rejected after 3 attempts. Final error:`, errorData);
                                        // Log the actual error message for debugging
                                        if (errorData.error && errorData.error.message) {
                                            console.error(`   Error message: ${errorData.error.message}`);
                                        }
                                        break;
                                    }
                                }
                                
                                // Don't retry on other client errors (401, 403)
                                if (status >= 400 && status < 500 && status !== 429 && status !== 400) {
                                    console.warn(` DALL-E API client error ${status}, not retrying`);
                                    break;
                                }
                                
                                // Retry on server errors (500, 502, 503) or rate limits (429)
                                if (status >= 500 || status === 429) {
                                    console.warn(` DALL-E API error ${status} (attempt ${attempt + 1}/3), will retry...`);
                                    if (attempt === 2) {
                                        window.dalleErrorCount = (window.dalleErrorCount || 0) + 1;
                                    }
                                    continue; // Retry
                                }
                            }
                        } catch (error) {
                            // Timeout or network error
                            if (error.message === 'DALL-E timeout') {
                                console.warn(` DALL-E timeout for "${title}" (attempt ${attempt + 1}/3)`);
                                if (attempt < 2) {
                                    continue; // Retry
                                }
                            } else {
                                console.warn(` DALL-E generation failed for "${title}":`, error.message);
                                if (attempt < 2) {
                                    continue; // Retry
                                }
                                window.dalleErrorCount = (window.dalleErrorCount || 0) + 1;
                            }
                        }
                    }
                }
                
                // Final fallback: Use Picsum (not topic-specific, but at least shows an image)
                // This should rarely be used if DALL-E works properly
                const keywordHash = mainSubject.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const picsumId = 1 + (keywordHash % 1000);
                const fallbackUrl = `https://picsum.photos/960/540?random=${picsumId}`;
                
                console.error(` All DALL-E attempts failed for "${title}". Using Picsum fallback (not topic-specific). Please check your OpenAI API key and network connection.`);
                return fallbackUrl;
            }
            
            // Extract chart data from slide content - IMPROVED for REAL data
            function extractChartData(slide) {
                const content = (slide.description || slide.summary || slide.title || '').toLowerCase();
                const fullContent = slide.description || slide.summary || slide.content || '';
                const title = (slide.title || '').toLowerCase();
                
                // Check if this is a Flow Chart slide
                const isFlowChart = title.includes('flow chart') || title.includes('flowchart') || 
                                   (title.includes('flow') && (title.includes('chart') || title.includes('diagram') || title.includes('process')));
                
                // Extract Flow Chart steps from content if it's a Flow Chart slide
                if (isFlowChart) {
                    // Try to extract steps/phases from content - SHORT and CLEAR
                    const stepPatterns = [
                        /(?:step|phase|stage|process)\s+\d+[:\-]?\s*([^\.\n]{1,25})/gi,
                        /(?:first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth)[:\-]?\s*([^\.\n]{1,25})/gi,
                        /(?:start|begin|initiate|plan|design|develop|implement|test|deploy|end|finish)[:\-]?\s*([^\.\n]{1,25})/gi,
                        /(?:1|2|3|4|5|6|7|8|9|10)[\.\)]\s*([^\.\n]{1,25})/gi,
                        // Extract key action verbs and short phrases
                        /\b(capture|preprocess|extract|detect|match|store|search|compare|decide|output|alert|monitor|log)\b[^\.\n]{0,20}/gi
                    ];
                    
                    const steps = [];
                    stepPatterns.forEach(pattern => {
                        const matches = fullContent.matchAll(pattern);
                        for (const match of matches) {
                            if (match[1]) {
                                let stepText = match[1].trim();
                                // Truncate to max 30 characters (3-4 words)
                                if (stepText.length > 30) {
                                    const words = stepText.split(' ');
                                    if (words.length > 4) {
                                        stepText = words.slice(0, 4).join(' ');
                                    } else {
                                        stepText = stepText.substring(0, 27) + '...';
                                    }
                                }
                                if (stepText.length > 3 && stepText.length <= 30) {
                                    steps.push(stepText);
                                }
                            }
                        }
                    });
                    
                    // If no steps found, try splitting by common separators - SHORT steps only
                    if (steps.length < 2) {
                        const splitSteps = fullContent
                            .split(/[\.\n;]/)
                            .map(s => {
                                let trimmed = s.trim();
                                // Keep only short sentences (max 30 chars)
                                if (trimmed.length > 30) {
                                    const words = trimmed.split(' ');
                                    if (words.length > 4) {
                                        trimmed = words.slice(0, 4).join(' ');
                                    } else {
                                        trimmed = trimmed.substring(0, 27) + '...';
                                    }
                                }
                                return trimmed;
                            })
                            .filter(s => s.length > 5 && s.length <= 30)
                            .slice(0, 5);
                        
                        if (splitSteps.length >= 2) {
                            steps.push(...splitSteps);
                        }
                    }
                    
                    // If still no steps, use common flow chart steps - SHORT and CLEAR
                    if (steps.length < 2) {
                        // Extract key words from content for context-aware steps
                        const keyWords = fullContent.toLowerCase().match(/\b(capture|process|extract|detect|match|store|search|analyze|compare|decide|output|alert|monitor|log|start|begin|end|finish)\b/g) || [];
                        const uniqueKeyWords = [...new Set(keyWords)].slice(0, 6);
                        
                        if (uniqueKeyWords.length >= 2) {
                            // Capitalize first letter
                            steps.push(...uniqueKeyWords.map(w => w.charAt(0).toUpperCase() + w.slice(1)));
                        } else {
                            // Default professional flow steps
                            const commonSteps = ['Start', 'Process', 'Analyze', 'Decide', 'Output', 'End'];
                            steps.push(...commonSteps.slice(0, Math.min(6, commonSteps.length)));
                        }
                    }
                    
                    // Remove duplicates, truncate long steps, and limit to 5 steps
                    const uniqueSteps = [...new Set(steps)]
                        .map(step => {
                            // Ensure each step is short (max 25 chars)
                            if (step.length > 25) {
                                const words = step.split(' ');
                                if (words.length > 4) {
                                    return words.slice(0, 4).join(' ');
                                }
                                return step.substring(0, 22) + '...';
                            }
                            return step;
                        })
                        .slice(0, 5);
                    
                    if (uniqueSteps.length >= 2) {
                        console.log(` Creating Flow Chart with ${uniqueSteps.length} steps from content`);
                        return {
                            type: 'flow',
                            labels: uniqueSteps,
                            values: uniqueSteps.map(() => 1) // Flow charts don't need values
                        };
                    }
                }
                
                // Extract numbers and percentages from content
                const numbers = fullContent.match(/\d+(\.\d+)?%?/g) || [];
                const percentages = fullContent.match(/\d+(\.\d+)?%/g) || [];
                
                // Try to extract years for timeline charts
                const years = fullContent.match(/\b(20\d{2}|19\d{2})\b/g) || [];
                
                console.log(` Extracting chart data from slide: "${slide.title}"`);
                console.log(`   Found ${numbers.length} numbers, ${percentages.length} percentages, ${years.length} years`);
                
                if (percentages.length >= 3) {
                    // Pie chart for percentages - use REAL percentages from content
                    const values = percentages.map(p => parseFloat(p.replace('%', ''))).filter(v => v > 0 && v <= 100).slice(0, 4);
                    if (values.length >= 3) {
                        // Try to extract labels from context
                        const labels = [];
                        percentages.slice(0, values.length).forEach((p, i) => {
                            // Try to find label near the percentage
                            const pIndex = fullContent.indexOf(p);
                            const context = fullContent.substring(Math.max(0, pIndex - 30), Math.min(fullContent.length, pIndex + 30));
                            const labelMatch = context.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/);
                            labels.push(labelMatch ? labelMatch[1] : `Segment ${i + 1}`);
                        });
                        console.log(` Creating pie chart with ${values.length} real data points`);
                    return {
                        type: 'pie',
                            labels: labels.length === values.length ? labels : ['Segment 1', 'Segment 2', 'Segment 3', 'Segment 4'].slice(0, values.length),
                        values: values
                    };
                    }
                } else if (years.length >= 3 && numbers.length >= 3) {
                    // Line chart for time series - use REAL years and values
                    const uniqueYears = [...new Set(years)].sort().slice(0, 5);
                    const values = numbers.map(n => parseFloat(n.replace('%', ''))).filter(v => v > 0 && v < 10000).slice(0, uniqueYears.length);
                    if (values.length >= 3 && uniqueYears.length >= 3) {
                        console.log(` Creating line chart with real timeline data`);
                        return {
                            type: 'line',
                            labels: uniqueYears,
                            values: values.slice(0, uniqueYears.length)
                        };
                    }
                } else if (numbers.length >= 3) {
                    // Bar or line chart - use REAL numbers from content
                    const isTrend = /trend|growth|over time|timeline|forecast|evolution|progress|increase|decrease/i.test(content);
                    const values = numbers.map(n => parseFloat(n.replace('%', ''))).filter(v => v > 0 && v < 10000).slice(0, 5);
                    if (values.length >= 3) {
                        // Try to extract meaningful labels
                        const labels = [];
                        if (years.length >= values.length) {
                            labels.push(...[...new Set(years)].slice(0, values.length));
                        } else {
                            // Try to find period labels
                            const periodMatches = fullContent.match(/(Q[1-4]|quarter|year|month|week)/gi);
                            if (periodMatches && periodMatches.length >= values.length) {
                                labels.push(...periodMatches.slice(0, values.length));
                            } else {
                                labels.push(...['Period 1', 'Period 2', 'Period 3', 'Period 4'].slice(0, values.length));
                            }
                        }
                        console.log(` Creating ${isTrend ? 'line' : 'bar'} chart with ${values.length} real data points`);
                        return {
                            type: isTrend ? 'line' : 'bar',
                            labels: labels,
                            values: values
                        };
                    }
                }
                
                // If no real data found, don't create a chart with fake data
                console.log(` No sufficient real data found for chart. Skipping chart creation.`);
                return null;
            }
            
            // Convert AI slides to app.data format with smart elements
            // Use Promise.all to generate all images in parallel
            // Pass the original subject to each slide for better image generation
            const originalSubject = (deckTitleText || rawTitle || '').toLowerCase().trim();
            app.data = await Promise.all(slidesToUse.map(async (entry, index) => {
                // Add original subject to entry for image generation
                entry.originalSubject = originalSubject;
                entry.subject = originalSubject;
                try {
                    // Ensure we have title and description FIRST - check all sources
                    const slideTitle = entry.title || entry.heading || `Slide ${index + 1}`;
                    const slideDescription = entry.summary || entry.description || entry.content || 'Add your content here';
                    const slideSummary = entry.summary || entry.description || slideDescription;
                
                    // Smart element detection - ALWAYS add image for ALL slides
                const elements = [];
                
                    // Check if this is a Flow Chart slide - NO IMAGE for Flow Chart
                    const isFlowChart = slideTitle.toLowerCase().includes('flow chart') || 
                                       slideTitle.toLowerCase().includes('flowchart') || 
                                       (slideTitle.toLowerCase().includes('flow') && (slideTitle.toLowerCase().includes('chart') || slideTitle.toLowerCase().includes('diagram') || slideTitle.toLowerCase().includes('process')));
                    
                    // Check if chart will be added
                    let hasChart = false;
                    try {
                        hasChart = shouldAddChart(entry, index);
                    } catch (chartError) {
                        console.error(` Error checking chart for slide ${index + 1}:`, chartError);
                    }
                    
                    // Check if image should be added (NOT for Flow Chart)
                    const shouldAddImg = shouldAddImage(entry, index) && !isFlowChart;
                    
                    // GAMMA-STYLE PROFESSIONAL LAYOUT: Image on LEFT, Text on RIGHT (organized, clean)
                    // Generate relevant image using getImageUrl (waits for DALL-E or uses fallback) - ONLY if not Flow Chart
                    if (shouldAddImg) {
                        let imageUrl;
                        try {
                            imageUrl = await getImageUrl(entry);
                        } catch (imgError) {
                            console.error(` Error getting image for slide ${index + 1}:`, imgError);
                            // Final fallback
                            const title = entry.title || entry.heading || `Slide ${index + 1}`;
                            const keywordHash = title.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                            const picsumId = 1 + (keywordHash % 1000);
                            imageUrl = `https://picsum.photos/960/540?random=${picsumId}`;
                        }
                        
                        // PERFECT ORGANIZATION: Image on LEFT, Text on RIGHT, Chart on FAR RIGHT
                        const imageElement = {
                            id: `image-${index}-${Date.now()}`,
                            type: 'image',
                            src: imageUrl,
                            x: 30, // FIXED: Always on LEFT
                            y: 100, // FIXED: Top aligned
                            width: hasChart ? 320 : 360, // Organized width
                            height: 340, // FIXED: Consistent height
                            animation: index === 0 ? 'fadeIn' : 'slideInLeft',
                            borderRadius: 12,
                            objectFit: 'cover'
                        };
                        elements.push(imageElement);
                        console.log(` Added image for slide ${index + 1} (title: "${entry.title}") with ${imageElement.animation} animation:`, imageUrl);
                        console.log(`    Image details:`, {
                            id: imageElement.id,
                            src: imageUrl.substring(0, 80) + '...',
                            position: `x:${imageElement.x}, y:${imageElement.y}`,
                            size: `${imageElement.width}x${imageElement.height}`
                        });
                    } else if (isFlowChart) {
                        console.log(` Flow Chart slide ${index + 1} - NO IMAGE (as requested)`);
                    }
                    
                    // Add chart when REAL data is available - ONLY use real data from content
                    // For Flow Chart, always add it if detected
                    if (hasChart || isFlowChart) {
                        try {
                    const chartData = extractChartData(entry);
                            // For Flow Chart, only need 2 steps minimum; for other charts, need 3 data points
                            const minDataPoints = chartData && chartData.type === 'flow' ? 2 : 3;
                            if (chartData && chartData.labels && chartData.labels.length >= minDataPoints) {
                                // PERFECT ORGANIZATION: Chart on FAR RIGHT side, aligned with image (or centered for Flow Chart)
                                // Flow Chart: Centered and fits within slide (960x540)
                                // Leave space for title at top (80px) and bottom margin (20px)
                                const chartX = isFlowChart ? 80 : 640; // Left-aligned for Flow Chart to show full width
                                const chartY = isFlowChart ? 100 : 100; // Below title
                                const chartW = isFlowChart ? 800 : 280; // Full width for Flow Chart (960 - 80*2 = 800)
                                const chartH = isFlowChart ? 360 : 340; // Fits in slide height (540 - 100 - 80 = 360)
                                
                        const chartElement = {
                            id: `chart-${index}-${Date.now()}`,
                            type: 'chart',
                                    x: chartX, // Centered for Flow Chart, right for others
                                    y: chartY, // Top aligned
                                    width: chartW, // Organized width
                                    height: chartH, // Organized height
                            chartType: chartData.type,
                            labels: chartData.labels,
                                    values: chartData.values || chartData.labels.map(() => 1), // REAL data from content
                                    colors: ['#10b981', '#059669', '#047857', '#065f46', '#0891b2', '#0d9488', '#14b8a6'].slice(0, chartData.labels.length),
                                    animation: 'slideInRight',
                                    borderRadius: 12,
                                    backgroundColor: 'rgba(255, 255, 255, 0.05)',
                                    borderColor: 'rgba(255, 255, 255, 0.1)'
                        };
                        elements.push(chartElement);
                                console.log(` Added ${chartData.type} chart for slide ${index + 1} with ${chartData.labels.length} ${chartData.type === 'flow' ? 'steps' : 'data points'}:`, chartData.labels);
                            } else {
                                console.log(` Skipping chart for slide ${index + 1} - insufficient data (need ${minDataPoints} ${chartData && chartData.type === 'flow' ? 'steps' : 'data points'})`);
                            }
                        } catch (chartError) {
                            console.error(` Error creating chart for slide ${index + 1}:`, chartError);
                        }
                    }
                    
                    // Organize elements to prevent overlap
                    try {
                        if (typeof organizeElements === 'function') {
                            organizeElements(elements);
                        }
                    } catch (orgError) {
                        console.error(` Error organizing elements for slide ${index + 1}:`, orgError);
                    }
                    
                    // Create slide object with design applied (AFTER we have elements)
                    // Add elements to entry so createAISlideStage can access them
                    const entryWithElements = {
                        ...entry,
                        els: elements
                    };
                    
                    let slideObj;
                    try {
                        slideObj = createAISlideObject(entryWithElements, index, slideTotal, context, finalDesign);
                    } catch (slideError) {
                        console.error(` Error creating slide object for slide ${index + 1}:`, slideError);
                        // Fallback slide object
                        slideObj = {
                            title: slideTitle,
                            description: slideDescription,
                            summary: slideSummary,
                            notes: entry.notes || '',
                            design: finalDesign,
                            stageHtml: '',
                            previewHtml: ''
                        };
                    }
                    
                    console.log(` Slide ${index + 1} - Title: "${slideTitle}"`);
                    console.log(`    Description length: ${slideDescription.length} chars, Summary: ${slideSummary.length} chars`);
                    console.log(`    Elements: ${elements.length} total (${elements.filter(e => e.type === 'image').length} images, ${elements.filter(e => e.type === 'chart').length} charts)`);
                
                    // Convert to app.data format - use slideObj data but ensure we have fallbacks
                return {
                    els: elements,
                    bg: 'white',
                    transition: 'fade',
                        title: slideObj?.title || slideTitle,
                        description: slideObj?.description || slideObj?.summary || slideDescription,
                        summary: slideObj?.summary || slideObj?.description || slideSummary,
                        notes: slideObj?.notes || entry.notes || '',
                    variant: 'ai',
                        design: slideObj?.design || finalDesign,
                        stageHtml: slideObj?.stageHtml || '',
                        previewHtml: slideObj?.previewHtml || '',
                }
                } catch (error) {
                    console.error(` Critical error creating slide ${index + 1}:`, error);
                    // Return a basic slide even if everything fails
                    return {
                        els: [],
                        bg: 'white',
                        transition: 'fade',
                        title: entry.title || entry.heading || `Slide ${index + 1}`,
                        description: entry.summary || entry.description || entry.content || 'Add your content here',
                        summary: entry.summary || entry.description || '',
                        notes: entry.notes || '',
                        variant: 'ai',
                        design: finalDesign,
                        stageHtml: '',
                        previewHtml: '',
                    }
                }
            }))
            app.curr = 0

            // Update deck title
            const titleInput = document.getElementById('title')
            if (titleInput) {
                titleInput.value = deckTitleText
            }

            // Render slides
            if (app.renderSlides) {
                app.renderSlides()
            }
            if (app.loadCanvas) {
                app.loadCanvas()
            }
            if (app.saveState) {
                app.saveState()
            }

            updateUrlForAIDeck(deckTitleText, rawDescription, slideTotal)
            
            // Remove loading overlay
            const loadingOverlay = document.getElementById('ai-generation-loading');
            if (loadingOverlay) {
                loadingOverlay.remove();
            }
        }
        // ============ End AI Functions ============

        window.onload = async () => {
            app.init();
            
            const params = new URLSearchParams(window.location.search);
            const shared = params.get('data');
            if (shared) {
                try {
                    const d = JSON.parse(atob(shared));
                    app.data = d.slides;
                    document.getElementById('title').value = d.title || '';
                    app.renderSlides();
                    app.loadCanvas();
                    app.saveState();
                } catch (e) {
                    console.error('Failed to load shared presentation');
                }
            }

            // Load presentation from Firebase if presentationId is provided
            const presentationId = params.get('presentationId');
            const ownerId = params.get('ownerId');
            
            if (presentationId && window.firebaseDb) {
                try {
                    const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
                    const userId = ownerId || window.currentUser?.uid || window.currentUserId;
                    
                    if (userId) {
                        const presentationRef = doc(window.firebaseDb, 'users', userId, 'presentations', presentationId);
                        const presentationSnap = await getDoc(presentationRef);
                        
                        if (presentationSnap.exists()) {
                            const data = presentationSnap.data();
                            app.data = data.slides || [];
                            document.getElementById('title').value = data.title || '';
                            app.curr = 0;
                            // Store presentationId for future saves
                            app.currentPresentationId = presentationId;
                            app.saveState();
                            app.loadCanvas();
                            app.renderSlides();
                            app.showNotification('Presentation loaded successfully');
                        } else {
                            app.showNotification('Presentation not found', 'error');
                        }
                    }
                } catch (e) {
                    console.error('Failed to load presentation from Firebase:', e);
                    app.showNotification('Failed to load presentation', 'error');
                }
            }

            // Close export menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.header-right')) {
                    document.getElementById('exportMenu').classList.remove('show');
                }
                
                // Close category dropdowns when clicking outside
                if (!e.target.closest('.dropdown-wrapper')) {
                    document.querySelectorAll('.category-dropdown').forEach(dd => {
                        dd.classList.remove('show');
                    });
                }
                
                // Close category panel when clicking outside
                if (!e.target.closest('.toolbar')) {
                    const panel = document.getElementById('categoryPanel');
                    const propertiesPanel = document.getElementById('propertiesPanel');
                    if (panel) panel.classList.remove('show');
                    document.querySelectorAll('.category-tab').forEach(tab => tab.classList.remove('active'));
                    app.activeCategory = null;
                    // Remove padding from properties panel
                    if (propertiesPanel) {
                        propertiesPanel.classList.remove('category-panel-open');
                    }
                }
            });

            // Ensure category tabs work properly - add event listeners as backup
            document.querySelectorAll('.category-tab').forEach(tab => {
                const category = tab.dataset.category || tab.getAttribute('onclick')?.match(/showCategory\(['"]([^'"]+)['"]\)/)?.[1] || (tab.id === 'chatbot-toggle' ? 'ai-assistant' : null);
                if (category) {
                    // Remove existing onclick and add event listener instead
                    tab.removeAttribute('onclick');
                    tab.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        app.showCategory(category);
                    });
                }
            });

            // Chatbot functionality
            const chatbotModal = document.getElementById('chatbot-modal');
            const chatbotClose = document.getElementById('chatbot-close');
            const chatbotInput = document.getElementById('chatbot-input');
            const chatbotSend = document.getElementById('chatbot-send');
            const chatbotMessages = document.getElementById('chatbot-messages');
            const chatbotSuggestions = document.getElementById('chatbot-suggestions');
            let chatbotLang = null;

            // Close chatbot
            if (chatbotClose) {
                chatbotClose.addEventListener('click', () => {
                    if (chatbotModal) {
                        chatbotModal.classList.add('hidden');
                        chatbotModal.classList.remove('flex');
                    }
                    const chatbotToggle = document.getElementById('chatbot-toggle');
                    if (chatbotToggle) {
                        chatbotToggle.classList.remove('active');
                    }
                });
            }

            // Language selection (handle dynamically added buttons)
            document.addEventListener('click', (e) => {
                if (e.target.closest('.lang-btn')) {
                    const btn = e.target.closest('.lang-btn');
                    chatbotLang = btn.dataset.lang;
                    document.querySelectorAll('.lang-btn').forEach(b => {
                        b.classList.remove('border-emerald-300', 'bg-emerald-50', 'text-emerald-600');
                        b.classList.add('border-slate-200', 'bg-white', 'text-slate-600');
                    });
                    btn.classList.remove('border-slate-200', 'bg-white', 'text-slate-600');
                    btn.classList.add('border-emerald-300', 'bg-emerald-50', 'text-emerald-600');
                    
                    if (chatbotInput) {
                        chatbotInput.placeholder = chatbotLang === 'ar' ? ' ...' : 'Type your message...';
                        chatbotInput.disabled = false;
                    }

                    // Show suggestions based on language
                    if (chatbotSuggestions) {
                        const suggestions = chatbotLang === 'ar' 
                            ? ['  ', '  ', '  ']
                            : ['Suggest slide titles', 'How to improve design?', 'Add new slide'];
                        chatbotSuggestions.innerHTML = suggestions.map(s => 
                            `<button class="suggestion-btn rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-600 hover:border-emerald-300 hover:bg-emerald-50 hover:text-emerald-600 transition">${s}</button>`
                        ).join('');
                    }
                }
            });

            // Chatbot message handler
            function handleChatbotMessage(message) {
                const lowerMessage = message.toLowerCase();
                const isArabic = chatbotLang === 'ar';
                
                // Handle "add new slide" / "  "
                if ((lowerMessage.includes('add') && lowerMessage.includes('slide')) || 
                    (lowerMessage.includes('') && (lowerMessage.includes('') || lowerMessage.includes('')))) {
                    if (app && app.addSlide) {
                        app.addSlide();
                        return isArabic ? '    !' : 'New slide added successfully!';
                    }
                    return isArabic ? '    .   .' : 'Error adding slide. Please try again.';
                }
                
                // Handle "suggest titles" / " "
                if (lowerMessage.includes('suggest') && lowerMessage.includes('title') ||
                    lowerMessage.includes('') && lowerMessage.includes('')) {
                    const currentSlides = app?.data || [];
                    if (currentSlides.length === 0) {
                        return isArabic ? '     .   .' : 'No slides in the presentation. Add a slide first.';
                    }
                    
                    const suggestions = isArabic ? [
                        '  ',
                        ' ',
                        ' ',
                        ' ',
                        ' '
                    ] : [
                        'Executive Overview',
                        'Problem & Solution',
                        'Results & Achievements',
                        'Next Steps',
                        'Conclusion & Recommendations'
                    ];
                    
                    let response = isArabic ? ' :\n\n' : 'Title suggestions:\n\n';
                    suggestions.slice(0, Math.min(5, currentSlides.length)).forEach((title, idx) => {
                        response += `${idx + 1}. ${title}\n`;
                    });
                    return response;
                }
                
                // Handle "improve design" / " "
                if (lowerMessage.includes('improve') && lowerMessage.includes('design') ||
                    lowerMessage.includes('') && (lowerMessage.includes('') || lowerMessage.includes(''))) {
                    return isArabic ? 
                        ' :\n\n1.   \n2.     \n3.     \n4.    \n5.      ' :
                        'To improve design:\n\n1. Use consistent colors\n2. Add images or charts\n3. Use clear, readable fonts\n4. Maintain proper spacing\n5. Use headings and subheadings effectively';
                }
                
                // Default response
                return isArabic ? 
                    '  !   :\n\n   \n   \n  \n     \n\n  .' :
                    'Thank you for your message! I can help you with:\n\n Adding a new slide\n Suggesting slide titles\n Improving design\n Creating an AI presentation\n\nType your request and I\'ll help you.';
            }

            // Send message
            if (chatbotSend && chatbotInput) {
                const sendMessage = () => {
                    if (!chatbotLang) {
                        const alertMsg = chatbotInput.placeholder.includes('') ? '   ' : 'Please select a language first';
                        alert(alertMsg);
                        return;
                    }
                    const message = chatbotInput.value.trim();
                    if (!message) return;

                    // Add user message
                    const userMsg = document.createElement('div');
                    userMsg.className = 'flex items-start gap-3 justify-end';
                    const isArabic = chatbotLang === 'ar';
                    userMsg.innerHTML = `
                        <div class="flex-1 rounded-2xl bg-emerald-100 px-4 py-3 text-right max-w-[80%]">
                            <p class="text-sm text-slate-700" style="direction: ${isArabic ? 'rtl' : 'ltr'}; text-align: ${isArabic ? 'right' : 'left'};">${message}</p>
                        </div>
                    `;
                    if (chatbotMessages) {
                        chatbotMessages.appendChild(userMsg);
                        chatbotInput.value = '';
                        chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
                    }

                    // Process message and show response
                    setTimeout(() => {
                        const response = handleChatbotMessage(message);
                        const aiMsg = document.createElement('div');
                        aiMsg.className = 'flex items-start gap-3';
                        aiMsg.innerHTML = `
                            <div class="h-8 w-8 rounded-full bg-gradient-to-br from-emerald-500 to-sky-500 flex items-center justify-center flex-shrink-0">
                                <svg class="h-4 w-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                                </svg>
                            </div>
                            <div class="flex-1 rounded-2xl bg-slate-50 px-4 py-3">
                                <p class="text-sm text-slate-700 whitespace-pre-line" style="direction: ${isArabic ? 'rtl' : 'ltr'}; text-align: ${isArabic ? 'right' : 'left'};">${response}</p>
                            </div>
                        `;
                        if (chatbotMessages) {
                            chatbotMessages.appendChild(aiMsg);
                            chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
                        }
                    }, 500);
                };

                chatbotSend.addEventListener('click', sendMessage);
                chatbotInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendMessage();
                    }
                });

                // Handle suggestion button clicks
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.suggestion-btn')) {
                        const btn = e.target.closest('.suggestion-btn');
                        const suggestionText = btn.textContent.trim();
                        chatbotInput.value = suggestionText;
                        sendMessage();
                    }
                });
            }

            // Close chatbot when clicking outside
            if (chatbotModal) {
                chatbotModal.addEventListener('click', (e) => {
                    if (e.target === chatbotModal) {
                        chatbotModal.classList.add('hidden');
                        chatbotModal.classList.remove('flex');
                        const chatbotToggle = document.getElementById('chatbot-toggle');
                        if (chatbotToggle) {
                            chatbotToggle.classList.remove('active');
                        }
                    }
                });
            }

            // AI Setup Modal functionality - Full implementation from editor-ai1.html
            const deckSetupModal = document.querySelector('[data-deck-setup-modal]');
            const deckSetupForm = deckSetupModal?.querySelector('[data-deck-setup-form]');
            const deckSetupTitleInput = deckSetupModal?.querySelector('#deck-setup-title');
            const deckSetupDescriptionInput = deckSetupModal?.querySelector('#deck-setup-description');
            const deckSetupSlidesInput = deckSetupModal?.querySelector('#deck-setup-slides');
            const deckSetupBackground = deckSetupModal?.querySelector('#deck-setup-background');
            const deckSetupCustomColor = deckSetupModal?.querySelector('#deck-setup-custom-color');
            const deckSetupCustomColorContainer = deckSetupModal?.querySelector('#deck-setup-custom-color-container');
            const deckSetupError = deckSetupModal?.querySelector('[data-deck-setup-error]');
            const deckSetupCloseButtons = deckSetupModal?.querySelectorAll('[data-deck-setup-close]');
            const deckSetupSubmitButton = deckSetupForm?.querySelector('button[type="submit"]');
            let deckSetupSlideTitlesSection = deckSetupModal?.querySelector('#deck-setup-slide-titles-section');
            let deckSetupSlideTitlesList = deckSetupModal?.querySelector('#deck-setup-slide-titles-list');
            
            // Store selected slide titles
            let deckSetupSelectedTitles = [];
            let deckSetupIsLoading = false;
            
            // Slide Titles Selection Modal
            const slideTitlesModal = document.querySelector('[data-slide-titles-modal]');
            let selectedSlideTitles = [];
            let allAvailableTitles = [];
            let slideTitlesConfig = {};

            function clearDeckSetupError() {
                if (!deckSetupError) return;
                deckSetupError.textContent = '';
                deckSetupError.classList.add('hidden');
            }

            function showDeckSetupError(message = '') {
                if (!deckSetupError) return;
                deckSetupError.textContent = message;
                deckSetupError.classList.remove('hidden');
            }

            function setDeckSetupLoadingState(isLoading = false) {
                deckSetupIsLoading = Boolean(isLoading);
                deckSetupForm?.classList.toggle('opacity-60', deckSetupIsLoading);
                deckSetupForm?.classList.toggle('pointer-events-none', deckSetupIsLoading);
                if (deckSetupSubmitButton) {
                    deckSetupSubmitButton.disabled = deckSetupIsLoading;
                    deckSetupSubmitButton.innerHTML = deckSetupIsLoading
                        ? `<span class="inline-flex items-center gap-2"><span class="h-3 w-3 animate-spin rounded-full border-2 border-white/50 border-t-white"></span>Thinking</span>`
                        : 'Generate deck';
                }
            }

            function openDeckSetupModal(prefill = {}) {
                if (!deckSetupModal) return;
                const prefillTitle =
                    typeof prefill.title === 'string' && prefill.title.trim().length
                        ? prefill.title.trim()
                        : document.getElementById('title')?.value?.trim() || '';
                const prefillDescription =
                    typeof prefill.description === 'string' ? prefill.description.trim() : '';
                const prefillSlidesRaw = Number.parseInt(prefill.slides, 10);
                const prefillSlides = Number.isNaN(prefillSlidesRaw)
                    ? DEFAULT_AI_SLIDE_COUNT
                    : clamp(prefillSlidesRaw, MIN_AI_SLIDES, MAX_AI_SLIDES);

                if (deckSetupTitleInput) {
                    deckSetupTitleInput.value = prefillTitle;
                }
                if (deckSetupDescriptionInput) {
                    deckSetupDescriptionInput.value = prefillDescription;
                }
                if (deckSetupSlidesInput) {
                    deckSetupSlidesInput.value = String(prefillSlides);
                }

                clearDeckSetupError();
                setDeckSetupLoadingState(false);
                deckSetupSelectedTitles = [];
                
                // Reset step indicator to step 1
                updateStepIndicator(1);
                
                // Hide sub-titles section initially - will show after title is entered
                if (deckSetupSlideTitlesSection) {
                    deckSetupSlideTitlesSection.classList.add('hidden');
                }
                if (deckSetupSlideTitlesList) {
                    deckSetupSlideTitlesList.innerHTML = '';
                }
                
                // Reset title check icon
                const titleCheckIcon = document.querySelector('.title-check-icon');
                if (titleCheckIcon) {
                    titleCheckIcon.style.opacity = '0';
                }
                // Hide description and slides initially - show only title input
                if (deckSetupDescriptionInput && deckSetupDescriptionInput.closest('div')) {
                    deckSetupDescriptionInput.closest('div').classList.add('hidden');
                }
                if (deckSetupSlidesInput && deckSetupSlidesInput.closest('div')) {
                    deckSetupSlidesInput.closest('div').classList.add('hidden');
                }
                deckSetupModal.classList.remove('hidden');
                deckSetupModal.classList.add('flex');
                window.setTimeout(() => {
                    deckSetupTitleInput?.focus();
                    deckSetupTitleInput?.select();
                }, 40);
            }

            function closeDeckSetupModal() {
                if (!deckSetupModal) return;
                clearDeckSetupError();
                deckSetupModal.classList.add('hidden');
                deckSetupModal.classList.remove('flex');
            }
            
            // Function to update step indicator
            function updateStepIndicator(activeStep) {
                for (let i = 1; i <= 3; i++) {
                    const stepIndicator = document.querySelector(`.step-indicator[data-step="${i}"]`);
                    const stepNumber = stepIndicator?.querySelector('.step-number');
                    const stepLabel = stepIndicator?.querySelector('.step-label');
                    const stepConnector = document.querySelectorAll('.step-connector')[i - 1];
                    
                    if (i <= activeStep) {
                        // Active or completed step
                        stepIndicator?.classList.remove('opacity-40');
                        stepIndicator?.classList.add('opacity-100');
                        if (stepNumber) {
                            stepNumber.classList.remove('bg-slate-300', 'text-slate-600');
                            stepNumber.classList.add('bg-emerald-500', 'text-white', 'shadow-lg');
                            if (i < activeStep) {
                                stepNumber.innerHTML = '';
                            } else {
                                stepNumber.innerHTML = i;
                            }
                        }
                        if (stepLabel) {
                            stepLabel.classList.remove('text-slate-500');
                            stepLabel.classList.add('text-slate-700');
                        }
                        if (stepConnector && i < activeStep) {
                            stepConnector.classList.remove('bg-slate-200');
                            stepConnector.classList.add('bg-emerald-500');
                        }
                    } else {
                        // Inactive step
                        stepIndicator?.classList.add('opacity-40');
                        stepIndicator?.classList.remove('opacity-100');
                        if (stepNumber) {
                            stepNumber.classList.remove('bg-emerald-500', 'text-white', 'shadow-lg');
                            stepNumber.classList.add('bg-slate-300', 'text-slate-600');
                            stepNumber.innerHTML = i;
                        }
                        if (stepLabel) {
                            stepLabel.classList.remove('text-slate-700');
                            stepLabel.classList.add('text-slate-500');
                        }
                    }
                }
            }

            // Slide count adjustment functions
            function adjustSlideCount(delta) {
                if (!deckSetupSlidesInput) return;
                const currentValue = Number.parseInt(deckSetupSlidesInput.value, 10) || DEFAULT_AI_SLIDE_COUNT;
                const newValue = clamp(currentValue + delta, MIN_AI_SLIDES, MAX_AI_SLIDES);
                deckSetupSlidesInput.value = String(newValue);
                // Trigger change event to ensure validation
                deckSetupSlidesInput.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Expose functions to global scope for onclick handlers
            if (typeof app === 'undefined') {
                window.app = {};
            }
            app.increaseSlideCount = () => adjustSlideCount(1);
            app.decreaseSlideCount = () => adjustSlideCount(-1);
            app.validateSlideCount = () => {
                if (!deckSetupSlidesInput) return;
                const value = Number.parseInt(deckSetupSlidesInput.value, 10);
                if (Number.isNaN(value)) {
                    deckSetupSlidesInput.value = String(DEFAULT_AI_SLIDE_COUNT);
                } else {
                    const clamped = clamp(value, MIN_AI_SLIDES, MAX_AI_SLIDES);
                    if (clamped !== value) {
                        deckSetupSlidesInput.value = String(clamped);
                    }
                }
            };

            // Update background preview
            function updateBackgroundPreview() {
                const preview = document.getElementById('deck-setup-background-preview');
                if (!preview) return;
                
                const bgStyle = deckSetupBackground?.value || 'gradient-dark';
                const customColor = deckSetupCustomColor?.value || '#0f172a';
                
                let previewHtml = '';
                if (bgStyle === 'gradient-dark') {
                    previewHtml = `
                        <div class="absolute inset-0 bg-slate-950"></div>
                        <div class="absolute inset-0 bg-gradient-to-br from-indigo-600/45 via-slate-900/75 to-emerald-500/35"></div>
                        <div class="absolute -top-8 -left-5 h-24 w-24 rounded-full bg-emerald-500/20 blur-2xl"></div>
                        <div class="absolute -bottom-12 right-0 h-28 w-28 rounded-full bg-indigo-500/30 blur-2xl"></div>
                    `;
                } else if (bgStyle === 'gradient-light') {
                    previewHtml = `
                        <div class="absolute inset-0 bg-gradient-to-br from-blue-50 via-indigo-50 to-emerald-50"></div>
                        <div class="absolute -top-8 -left-5 h-24 w-24 rounded-full bg-emerald-200/30 blur-2xl"></div>
                        <div class="absolute -bottom-12 right-0 h-28 w-28 rounded-full bg-indigo-200/30 blur-2xl"></div>
                    `;
                } else if (bgStyle === 'solid-dark') {
                    previewHtml = `<div class="absolute inset-0 bg-slate-900"></div>`;
                } else if (bgStyle === 'solid-light') {
                    previewHtml = `<div class="absolute inset-0 bg-slate-100"></div>`;
                } else if (bgStyle === 'white') {
                    previewHtml = `<div class="absolute inset-0 bg-white"></div>`;
                } else if (bgStyle === 'custom') {
                    previewHtml = `<div class="absolute inset-0" style="background-color: ${customColor};"></div>`;
                } else if (bgStyle === 'aramco-ados') {
                    // ADOS Project Update Template Preview - Exact match
                    previewHtml = `
                        <div class="absolute inset-0 bg-white"></div>
                        <div class="absolute top-0 left-0 right-0 h-8 bg-blue-600"></div>
                        <div class="absolute top-8 left-0 right-0 h-px bg-slate-300"></div>
                    `;
                } else if (bgStyle === 'aramco-governance') {
                    // SA SCDT - AD Governance Template Preview - Exact match with logo
                    previewHtml = `
                        <div class="absolute inset-0 bg-white"></div>
                        <div class="absolute top-2 left-2 flex items-center gap-1.5">
                            <div class="w-4 h-4 rounded bg-gradient-to-br from-emerald-500 to-blue-500 flex items-center justify-center">
                                <span class="text-[0.4rem] font-bold text-white">A</span>
                            </div>
                            <span class="text-[0.6rem] font-bold text-slate-700 uppercase tracking-tight">aramco</span>
                        </div>
                        <div class="absolute top-6 left-0 right-0 h-px bg-slate-300"></div>
                        <div class="absolute top-8 left-3 flex gap-1">
                            <div class="w-1.5 h-1.5 rounded-full bg-emerald-500"></div>
                            <div class="w-1.5 h-1.5 rounded-full bg-slate-300"></div>
                            <div class="w-1.5 h-1.5 rounded-full bg-slate-300"></div>
                        </div>
                    `;
                } else if (bgStyle === 'aramco-sao') {
                    // SAO Master Template Preview - Exact match with aramco digital logo
                    previewHtml = `
                        <div class="absolute inset-0 bg-white"></div>
                        <div class="absolute top-0 left-0 right-0 h-9 bg-slate-800"></div>
                        <div class="absolute top-1 left-2 flex items-center gap-1.5">
                            <div class="w-4 h-4 rounded bg-gradient-to-br from-emerald-500 to-blue-500 flex items-center justify-center">
                                <span class="text-[0.4rem] font-bold text-white">A</span>
                            </div>
                            <div class="flex flex-col">
                                <span class="text-[0.6rem] font-bold text-white uppercase tracking-tight leading-tight">aramco</span>
                                <span class="text-[0.5rem] font-semibold text-white/90 uppercase tracking-tight leading-tight">digital</span>
                            </div>
                        </div>
                        <div class="absolute top-10 left-3 space-y-1">
                            <div class="h-px bg-slate-300 w-24"></div>
                            <div class="h-px bg-slate-300 w-20"></div>
                            <div class="h-px bg-slate-300 w-26"></div>
                        </div>
                    `;
                }
                
                preview.innerHTML = previewHtml;
            }

            // Handle background square selection
            const bgOptionButtons = deckSetupModal?.querySelectorAll('[data-bg-option]');
            bgOptionButtons?.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    const bgValue = button.getAttribute('data-bg-option');
                    
                    // Update hidden input immediately
                    if (deckSetupBackground) {
                        deckSetupBackground.value = bgValue;
                    }
                    
                    // Update selected state
                    bgOptionButtons.forEach(btn => {
                        btn.classList.remove('border-emerald-400');
                        btn.classList.add('border-slate-200');
                    });
                    button.classList.remove('border-slate-200');
                    button.classList.add('border-emerald-400');
                    
                    // Show/hide custom color picker
                    if (bgValue === 'custom') {
                        deckSetupCustomColorContainer?.classList.remove('hidden');
                    } else {
                        deckSetupCustomColorContainer?.classList.add('hidden');
                    }
                    
                    // Update preview immediately
                    updateBackgroundPreview();
                });
            });

            // Update custom color preview when color changes
            deckSetupCustomColor?.addEventListener('input', (e) => {
                const customBgPreview = document.getElementById('custom-bg-preview');
                if (customBgPreview) {
                    customBgPreview.style.backgroundColor = e.target.value;
                }
                updateBackgroundPreview();
            });

            // Close buttons
            deckSetupCloseButtons?.forEach(button => {
                button.addEventListener('click', closeDeckSetupModal);
            });

            // Generate slide titles when title is entered - AUTO SHOW SUB-TITLES
            if (deckSetupTitleInput) {
                let titleGenerationTimeout = null;
                deckSetupTitleInput.addEventListener('input', async () => {
                    const title = deckSetupTitleInput.value.trim();
                    // Default to 6 slides if input not available
                    const slides = deckSetupSlidesInput ? (Number.parseInt(deckSetupSlidesInput.value ?? '6', 10) || 6) : 6;
                    
                    console.log(' Title input detected:', title, 'Slides:', slides);
                    
                    // Clear previous timeout
                    if (titleGenerationTimeout) {
                        clearTimeout(titleGenerationTimeout);
                    }
                    
                    // Wait 1 second after user stops typing
                    titleGenerationTimeout = setTimeout(async () => {
                        if (title.length >= 3) {
                            console.log(' Generating titles for:', title, '(length:', title.length, ')');
                            
                            // Re-fetch elements to ensure they're available
                            deckSetupSlideTitlesSection = document.querySelector('#deck-setup-slide-titles-section');
                            deckSetupSlideTitlesList = document.querySelector('#deck-setup-slide-titles-list');
                            
                            console.log(' Elements found:', {
                                section: !!deckSetupSlideTitlesSection,
                                list: !!deckSetupSlideTitlesList
                            });
                            
                            // Update step indicator to step 2
                            updateStepIndicator(2);
                            
                            // Show checkmark on title input
                            const titleCheckIcon = document.querySelector('.title-check-icon');
                            if (titleCheckIcon) {
                                titleCheckIcon.style.opacity = '1';
                            }
                            
                            // Show the sub-titles section - FORCE with !important
                            if (deckSetupSlideTitlesSection) {
                                deckSetupSlideTitlesSection.classList.remove('hidden');
                                deckSetupSlideTitlesSection.style.setProperty('display', 'block', 'important');
                                deckSetupSlideTitlesSection.style.setProperty('visibility', 'visible', 'important');
                                deckSetupSlideTitlesSection.style.setProperty('opacity', '1', 'important');
                                deckSetupSlideTitlesSection.classList.add('animate-fadeIn');
                                console.log(' Section shown');
                            } else {
                                console.error(' Section not found!');
                            }
                            
                            // Show loading state with fun animation
                            if (deckSetupSlideTitlesList) {
                                deckSetupSlideTitlesList.innerHTML = `
                                    <div class="text-center py-8 animate-fadeIn">
                                        <div class="inline-flex flex-col items-center gap-3">
                                            <div class="relative">
                                                <span class="h-8 w-8 animate-spin rounded-full border-3 border-slate-300 border-t-emerald-500 block"></span>
                                                <span class="absolute inset-0 flex items-center justify-center">
                                                    <span class="text-emerald-500 text-xs"></span>
                                                </span>
                                            </div>
                                            <div class="text-sm font-semibold text-slate-700">Generating amazing sections...</div>
                                            <div class="text-xs text-slate-500">AI is crafting your presentation structure</div>
                                        </div>
                                    </div>
                                `;
                                console.log(' Loading message set');
                            } else {
                                console.error(' List not found!');
                            }
                            
                            // Default to 6 slides for title generation
                            await generateDeckSetupTitles(title, 6);
                        } else {
                            console.log(' Title too short (length:', title.length, '), need at least 3 characters');
                            if (deckSetupSlideTitlesSection) {
                                deckSetupSlideTitlesSection.classList.add('hidden');
                            }
                            deckSetupSelectedTitles = [];
                        }
                    }, 1000);
                });
            }
            
            // Function to generate titles and show them in the setup modal
            async function generateDeckSetupTitles(title, slideCount) {
                console.log(' generateDeckSetupTitles called with:', { title, slideCount });
                
                // Always re-fetch elements to ensure they're available
                deckSetupSlideTitlesSection = document.querySelector('#deck-setup-slide-titles-section');
                deckSetupSlideTitlesList = document.querySelector('#deck-setup-slide-titles-list');
                
                console.log(' deckSetupSlideTitlesList:', deckSetupSlideTitlesList);
                console.log(' deckSetupSlideTitlesSection:', deckSetupSlideTitlesSection);
                
                if (!deckSetupSlideTitlesList || !deckSetupSlideTitlesSection) {
                    console.error(' Missing elements:', { 
                        deckSetupSlideTitlesList: !!deckSetupSlideTitlesList, 
                        deckSetupSlideTitlesSection: !!deckSetupSlideTitlesSection 
                    });
                    console.error(' Cannot proceed without elements');
                    return;
                }
                
                // Ensure section is visible BEFORE setting loading message - FORCE with !important
                if (deckSetupSlideTitlesSection) {
                    deckSetupSlideTitlesSection.classList.remove('hidden');
                    deckSetupSlideTitlesSection.style.setProperty('display', 'block', 'important');
                    deckSetupSlideTitlesSection.style.setProperty('visibility', 'visible', 'important');
                    deckSetupSlideTitlesSection.style.setProperty('opacity', '1', 'important');
                    console.log(' Section is now visible (removed hidden class, forced display)');
                } else {
                    console.error(' deckSetupSlideTitlesSection not found');
                    // Try to find it again
                    const retrySection = document.querySelector('#deck-setup-slide-titles-section');
                    if (retrySection) {
                        retrySection.classList.remove('hidden');
                        retrySection.style.setProperty('display', 'block', 'important');
                        retrySection.style.setProperty('visibility', 'visible', 'important');
                        console.log(' Found section on retry');
                    }
                }
                if (deckSetupSlideTitlesList) {
                    deckSetupSlideTitlesList.innerHTML = '<div class="text-center py-8"><div class="inline-flex items-center gap-2 text-sm text-slate-500"><span class="h-4 w-4 animate-spin rounded-full border-2 border-slate-300 border-t-emerald-500"></span>Generating sub-titles...</div></div>';
                    console.log(' Loading message set');
                } else {
                    console.error(' deckSetupSlideTitlesList not found');
                    // Try to find it again
                    const retryList = document.querySelector('#deck-setup-slide-titles-list');
                    if (retryList) {
                        retryList.innerHTML = '<div class="text-center py-8"><div class="inline-flex items-center gap-2 text-sm text-slate-500"><span class="h-4 w-4 animate-spin rounded-full border-2 border-slate-300 border-t-emerald-500"></span>Generating sub-titles...</div></div>';
                        console.log(' Found list on retry');
                    }
                }
                console.log(' Section should now be visible');
                
                try {
                    const openAIKey = app.getOpenAIKey();
                    if (!openAIKey) {
                        console.error(' No OpenAI key found');
                        deckSetupSlideTitlesList.innerHTML = '<div class="text-center py-4 text-sm text-amber-600">OpenAI API key not found. Please add your API key.</div>';
                        return;
                    }
                    
                    console.log(' Sending request to OpenAI...');
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openAIKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are a presentation expert. Generate ONLY slide titles (no descriptions, no content) for a presentation about "${title}". Return a JSON array of exactly ${slideCount} title strings. Example: ["Title 1", "Title 2", "Title 3"]`
                                },
                                {
                                    role: 'user',
                                    content: `Generate ${slideCount} slide titles for a presentation about "${title}". Return ONLY a JSON array of title strings, nothing else.`
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 500
                        })
                    });
                    
                    console.log(' Response status:', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const content = data.choices[0]?.message?.content || '';
                        console.log(' Raw response:', content);
                        
                        const titlesJson = content.replace(/```json\n?|\n?```/g, '').trim();
                        const titles = JSON.parse(titlesJson);
                        console.log(' Parsed titles:', titles);
                        
                        if (Array.isArray(titles) && titles.length > 0) {
                            deckSetupSelectedTitles = titles.map(title => ({
                                title: title,
                                description: '',
                                summary: '',
                                notes: ''
                            }));
                            console.log(' Final selected titles:', deckSetupSelectedTitles);
                            
                            // Update step indicator - step 2 is now complete, show step 3
                            updateStepIndicator(3);
                            
                            // Re-fetch elements to ensure they're available
                            deckSetupSlideTitlesSection = document.querySelector('#deck-setup-slide-titles-section');
                            deckSetupSlideTitlesList = document.querySelector('#deck-setup-slide-titles-list');
                            
                            console.log(' After generation - Section:', !!deckSetupSlideTitlesSection, 'List:', !!deckSetupSlideTitlesList);
                            
                            // Ensure section is visible - FORCE display with !important
                            if (deckSetupSlideTitlesSection) {
                                deckSetupSlideTitlesSection.classList.remove('hidden');
                                deckSetupSlideTitlesSection.style.setProperty('display', 'block', 'important');
                                deckSetupSlideTitlesSection.style.setProperty('visibility', 'visible', 'important');
                                deckSetupSlideTitlesSection.style.setProperty('opacity', '1', 'important');
                                console.log(' Section is visible after titles generated');
                            } else {
                                console.error(' Section not found after generation!');
                            }
                            
                            // Show description input after titles are generated (slides input is hidden permanently)
                            if (deckSetupDescriptionInput && deckSetupDescriptionInput.closest('div')) {
                                deckSetupDescriptionInput.closest('div').classList.remove('hidden');
                            }
                            
                            // Render titles with animation
                            if (deckSetupSlideTitlesList) {
                                renderDeckSetupTitles();
                            } else {
                                console.error(' Cannot render titles - list not found!');
                            }
                            // Scroll to titles section
                            setTimeout(() => {
                                const section = document.querySelector('#deck-setup-slide-titles-section');
                                if (section) {
                                    section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                }
                            }, 200);
                        } else {
                            console.error(' Invalid titles format');
                            deckSetupSlideTitlesList.innerHTML = '<div class="text-center py-4 text-sm text-amber-600">Invalid response format. Please try again.</div>';
                        }
                    } else {
                        const errorText = await response.text();
                        console.error(' API error:', response.status, errorText);
                        deckSetupSlideTitlesList.innerHTML = '<div class="text-center py-4 text-sm text-amber-600">Failed to generate titles. Please check your API key.</div>';
                    }
                } catch (error) {
                    console.error(' Failed to generate titles:', error);
                    deckSetupSlideTitlesList.innerHTML = '<div class="text-center py-4 text-sm text-amber-600">Failed to generate titles. You can proceed without selecting titles.</div>';
                }
            }
            
            // Function to render titles in the setup modal - Enhanced with selectable options
            function renderDeckSetupTitles() {
                console.log(' renderDeckSetupTitles called');
                
                // Always try to find the elements fresh
                deckSetupSlideTitlesSection = document.querySelector('#deck-setup-slide-titles-section');
                deckSetupSlideTitlesList = document.querySelector('#deck-setup-slide-titles-list');
                
                console.log(' deckSetupSlideTitlesList:', deckSetupSlideTitlesList);
                console.log(' deckSetupSelectedTitles:', deckSetupSelectedTitles);
                
                if (!deckSetupSlideTitlesList) {
                    console.error(' Could not find deck-setup-slide-titles-list');
                    return;
                }
                
                // Ensure section is visible - FORCE with !important
                if (deckSetupSlideTitlesSection) {
                    deckSetupSlideTitlesSection.classList.remove('hidden');
                    deckSetupSlideTitlesSection.style.setProperty('display', 'block', 'important');
                    deckSetupSlideTitlesSection.style.setProperty('visibility', 'visible', 'important');
                    deckSetupSlideTitlesSection.style.setProperty('opacity', '1', 'important');
                    console.log(' Section forced to be visible');
                }
                
                deckSetupSlideTitlesList.innerHTML = '';
                
                if (deckSetupSelectedTitles.length === 0) {
                    console.log(' No titles selected');
                    deckSetupSlideTitlesList.innerHTML = '<div class="text-center py-4 text-sm text-slate-500">Enter the main title - Sub-titles will appear automatically after 1 second</div>';
                    return;
                }
                
                console.log(` Rendering ${deckSetupSelectedTitles.length} titles`);
                
                deckSetupSelectedTitles.forEach((slide, index) => {
                    const slideDiv = document.createElement('div');
                    slideDiv.className = 'group relative rounded-xl border-2 border-slate-200 bg-gradient-to-br from-white to-slate-50 p-4 hover:border-emerald-400 hover:shadow-lg transition-all duration-300 cursor-pointer transform hover:scale-[1.02] animate-slideInUp';
                    slideDiv.style.animationDelay = `${index * 0.1}s`;
                    slideDiv.style.animationFillMode = 'both';
                    slideDiv.setAttribute('data-title-index', index);
                    slideDiv.innerHTML = `
                        <div class="flex items-start justify-between gap-3">
                            <div class="flex-1">
                                <div class="flex items-center gap-2 mb-2">
                                    <div class="flex-shrink-0 w-6 h-6 rounded-full bg-emerald-100 text-emerald-700 flex items-center justify-center text-xs font-bold">
                                        ${index + 1}
                                    </div>
                                    <input
                                        type="text"
                                        value="${escapeHtml(slide.title || `Slide ${index + 1}`)}"
                                        data-title-input="${index}"
                                        class="flex-1 text-base font-semibold text-slate-800 bg-transparent border-none outline-none focus:ring-2 focus:ring-emerald-200 rounded-lg px-2 py-1"
                                        placeholder="Section title"
                                        onclick="event.stopPropagation()"
                                    />
                                </div>
                                <textarea
                                    data-content-input="${index}"
                                    class="w-full text-sm text-slate-600 bg-white/60 rounded-lg border border-slate-200 px-3 py-2 resize-none focus:ring-2 focus:ring-emerald-200 focus:border-emerald-300"
                                    rows="2"
                                    placeholder="Add key points or ideas for this section..."
                                    onclick="event.stopPropagation()"
                                >${escapeHtml(slide.description || slide.summary || '')}</textarea>
                            </div>
                            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                <button
                                    type="button"
                                    data-move-title="${index}"
                                    class="p-2 rounded-lg text-slate-400 hover:bg-emerald-50 hover:text-emerald-600 transition"
                                    title="Move up"
                                    onclick="event.stopPropagation()"
                                >
                                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
                                    </svg>
                                </button>
                                <button
                                    type="button"
                                    data-delete-title="${index}"
                                    class="p-2 rounded-lg text-slate-400 hover:bg-red-50 hover:text-red-600 transition"
                                    title="Delete"
                                    onclick="event.stopPropagation()"
                                >
                                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `;
                    deckSetupSlideTitlesList.appendChild(slideDiv);
                });
                
                console.log(` Rendered ${deckSetupSelectedTitles.length} title cards`);
                console.log(' deckSetupSlideTitlesList children:', deckSetupSlideTitlesList.children.length);
                
                // Add event listeners for title inputs
                deckSetupSlideTitlesList.querySelectorAll('[data-title-input]').forEach(input => {
                    const index = parseInt(input.getAttribute('data-title-input'));
                    input.addEventListener('input', (e) => {
                        if (deckSetupSelectedTitles[index]) {
                            deckSetupSelectedTitles[index].title = e.target.value.trim() || deckSetupSelectedTitles[index].title;
                        }
                    });
                });
                
                // Add event listeners for content inputs
                deckSetupSlideTitlesList.querySelectorAll('[data-content-input]').forEach(input => {
                    const index = parseInt(input.getAttribute('data-content-input'));
                    input.addEventListener('input', (e) => {
                        if (deckSetupSelectedTitles[index]) {
                            deckSetupSelectedTitles[index].description = e.target.value.trim();
                            deckSetupSelectedTitles[index].summary = e.target.value.trim();
                        }
                    });
                });
                
                // Add event listeners for delete buttons
                deckSetupSlideTitlesList.querySelectorAll('[data-delete-title]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.closest('[data-delete-title]').getAttribute('data-delete-title'));
                        if (index >= 0 && index < deckSetupSelectedTitles.length) {
                            deckSetupSelectedTitles.splice(index, 1);
                            renderDeckSetupTitles();
                        }
                    });
                });
                
                // Add event listeners for move buttons (simple up/down)
                deckSetupSlideTitlesList.querySelectorAll('[data-move-title]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const index = parseInt(e.target.closest('[data-move-title]').getAttribute('data-move-title'));
                        if (index > 0) {
                            // Move up
                            [deckSetupSelectedTitles[index], deckSetupSelectedTitles[index - 1]] = [deckSetupSelectedTitles[index - 1], deckSetupSelectedTitles[index]];
                            renderDeckSetupTitles();
                        }
                    });
                });
                
                // Add click handler to select/deselect titles (optional - for future checkbox feature)
                deckSetupSlideTitlesList.querySelectorAll('[data-title-index]').forEach(card => {
                    card.addEventListener('click', (e) => {
                        // Only toggle if clicking on the card itself, not on inputs/buttons
                        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && !e.target.closest('button')) {
                            card.classList.toggle('ring-2');
                            card.classList.toggle('ring-emerald-400');
                        }
                    });
                });
            }
            
            // Function to remove a title from the setup modal
            window.removeDeckSetupTitle = function(index) {
                if (index < 0 || index >= deckSetupSelectedTitles.length) return;
                deckSetupSelectedTitles.splice(index, 1);
                renderDeckSetupTitles();
            };
            
            // Add special options
            if (deckSetupModal) {
                deckSetupModal.addEventListener('click', (e) => {
                    const addFlowchart = e.target.closest('[data-add-flowchart]');
                    const addIntroduction = e.target.closest('[data-add-introduction]');
                    const addConclusion = e.target.closest('[data-add-conclusion]');
                    const addSummary = e.target.closest('[data-add-summary]');
                    const addQa = e.target.closest('[data-add-qa]');
                    
                    if (addFlowchart) {
                        const title = deckSetupTitleInput?.value?.trim() || 'Presentation';
                        deckSetupSelectedTitles.push({
                            title: `${title}: Flow Chart`,
                            description: '',
                            summary: '',
                            notes: ''
                        });
                        renderDeckSetupTitles();
                    } else if (addIntroduction) {
                        deckSetupSelectedTitles.unshift({
                            title: 'Introduction',
                            description: '',
                            summary: '',
                            notes: ''
                        });
                        renderDeckSetupTitles();
                    } else if (addConclusion) {
                        deckSetupSelectedTitles.push({
                            title: 'Conclusion',
                            description: '',
                            summary: '',
                            notes: ''
                        });
                        renderDeckSetupTitles();
                    } else if (addSummary) {
                        deckSetupSelectedTitles.push({
                            title: 'Summary',
                            description: '',
                            summary: '',
                            notes: ''
                        });
                        renderDeckSetupTitles();
                    } else if (addQa) {
                        deckSetupSelectedTitles.push({
                            title: 'Q&A',
                            description: '',
                            summary: '',
                            notes: ''
                        });
                        renderDeckSetupTitles();
                    }
                });
            }

            // Close on background click
            if (deckSetupModal) {
                deckSetupModal.addEventListener('click', (e) => {
                    if (e.target === deckSetupModal) {
                        closeDeckSetupModal();
                    }
                });
            }

            // Form submit - Full AI implementation
            if (deckSetupForm) {
                deckSetupForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    if (deckSetupIsLoading) return;
                    clearDeckSetupError();

                    const titleValue = deckSetupTitleInput?.value?.trim() || '';
                    const descriptionValue = deckSetupDescriptionInput?.value?.trim() || '';
                    const slidesRaw = Number.parseInt(deckSetupSlidesInput?.value ?? '', 10);
                    const backgroundValue = deckSetupBackground?.value || 'gradient-dark';
                    const customColorValue = deckSetupCustomColor?.value || '#0f172a';

                    if (!titleValue.length) {
                        showDeckSetupError('Add a title so we can tailor the deck.');
                        deckSetupTitleInput?.focus();
                        return;
                    }

                    // Use number of selected titles, or default to 6 if no titles selected
                    const slidesClamped = deckSetupSelectedTitles.length > 0 
                        ? deckSetupSelectedTitles.length 
                        : (Number.parseInt(deckSetupSlidesInput?.value ?? '6', 10) || 6);

                    // Use selected titles from the setup modal, or generate them if not available
                    let slideTitlesOnly = deckSetupSelectedTitles.length > 0 
                        ? [...deckSetupSelectedTitles]
                        : [];

                    // If no titles selected, generate them now
                    if (slideTitlesOnly.length === 0) {
                    setDeckSetupLoadingState(true);
                    let aiError = null;

                        // Update loading message for OpenAI generation
                    if (deckSetupSubmitButton) {
                            deckSetupSubmitButton.innerHTML = `<span class="inline-flex items-center gap-2"><span class="h-3 w-3 animate-spin rounded-full border-2 border-white/50 border-t-white"></span>Generating slide titles</span>`;
                    }

                    try {
                            const openAIKey = app.getOpenAIKey();
                            if (openAIKey) {
                                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${openAIKey}`
                                    },
                                    body: JSON.stringify({
                                        model: 'gpt-4o',
                                        messages: [
                                            {
                                                role: 'system',
                                                content: `You are a presentation expert. Generate ONLY slide titles (no descriptions, no content) for a presentation about "${titleValue}". Return a JSON array of exactly ${slidesClamped} title strings. Example: ["Title 1", "Title 2", "Title 3"]`
                                            },
                                            {
                                                role: 'user',
                                                content: `Generate ${slidesClamped} slide titles for a presentation about "${titleValue}". ${descriptionValue ? `Context: ${descriptionValue}` : ''} Return ONLY a JSON array of title strings, nothing else.`
                                            }
                                        ],
                                        temperature: 0.7,
                                        max_tokens: 500
                                    })
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    const content = data.choices[0]?.message?.content || '';
                                    const titlesJson = content.replace(/```json\n?|\n?```/g, '').trim();
                                    const titles = JSON.parse(titlesJson);
                                    
                                    if (Array.isArray(titles) && titles.length > 0) {
                                        slideTitlesOnly = titles.map(title => ({
                                            title: title,
                                            description: '',
                                            summary: '',
                                            notes: ''
                                        }));
                                    }
                                }
                        }
                    } catch (error) {
                        aiError = error;
                            console.error(' Failed to generate titles:', error);
                            // Generate fallback titles
                            slideTitlesOnly = Array.from({ length: slidesClamped }, (_, i) => ({
                                title: `${titleValue}: Slide ${i + 1}`,
                                description: '',
                                summary: '',
                                notes: ''
                            }));
                    } finally {
                        setDeckSetupLoadingState(false);
                        }
                    }

                    // Close setup modal and generate directly (no review modal)
                    closeDeckSetupModal();
                    
                    // Generate directly using the titles from the setup modal
                    await replaceSlidesWithAIGeneration(
                        {
                            title: titleValue,
                            description: descriptionValue,
                            slideCount: slidesClamped,
                        },
                        { 
                            silent: false, 
                            slideBlueprint: slideTitlesOnly,
                            design: {
                                background: backgroundValue,
                                customColor: customColorValue,
                            }
                        }
                    );
                });
            }

            // Interactive Slide Titles Review Modal
            const slideTitlesReviewModal = document.querySelector('[data-slide-titles-review-modal]');
            let reviewModalConfig = {};
            let reviewTitles = [];
            
            function openSlideTitlesReviewModal(config) {
                reviewModalConfig = config;
                reviewTitles = [...(config.titles || [])];
                
                if (!slideTitlesReviewModal) {
                    console.error('Review modal not found');
                    // Fallback: generate directly
                    generateFromReviewTitles();
                    return;
                }
                
                console.log('Opening review modal with', reviewTitles.length, 'titles');
                renderReviewTitles();
                slideTitlesReviewModal.classList.remove('hidden');
                slideTitlesReviewModal.classList.add('flex');
            }
            
            function closeSlideTitlesReviewModal() {
                if (!slideTitlesReviewModal) return;
                slideTitlesReviewModal.classList.add('hidden');
                slideTitlesReviewModal.classList.remove('flex');
            }
            
            function renderReviewTitles() {
                const container = document.getElementById('slide-titles-review-list');
                if (!container) {
                    console.error('slide-titles-review-list not found');
                    return;
                }
                
                container.innerHTML = '';
                
                if (reviewTitles.length === 0) {
                    container.innerHTML = '<p class="text-center py-8 text-sm text-slate-500">No titles available. Please add sections.</p>';
                    return;
                }
                
                reviewTitles.forEach((slide, index) => {
                    const slideDiv = document.createElement('div');
                    slideDiv.className = 'rounded-2xl border border-slate-200 bg-white p-4 hover:border-emerald-300 transition';
                    slideDiv.innerHTML = `
                        <div class="flex items-start justify-between gap-3 mb-2">
                            <input
                                type="text"
                                value="${escapeHtml(slide.title || `Slide ${index + 1}`)}"
                                data-title-input="${index}"
                                class="flex-1 text-base font-semibold text-slate-800 bg-transparent border-none outline-none focus:ring-2 focus:ring-emerald-200 rounded-lg px-2 py-1"
                                placeholder="Section title"
                            />
                            <div class="flex items-center gap-1">
                                <button
                                    type="button"
                                    data-delete-title="${index}"
                                    class="p-2 rounded-lg text-slate-400 hover:bg-red-50 hover:text-red-600 transition"
                                    title="Delete"
                                >
                                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                    </svg>
                                </button>
                                <button
                                    type="button"
                                    data-move-title="${index}"
                                    class="p-2 rounded-lg text-slate-400 hover:bg-slate-100 hover:text-slate-600 transition cursor-move"
                                    title="Move"
                                >
                                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <p class="text-xs text-slate-500 mb-2">List key ideas (not final wording)</p>
                        <textarea
                            data-content-input="${index}"
                            class="w-full text-sm text-slate-600 bg-slate-50 rounded-lg border border-slate-200 px-3 py-2 resize-none focus:ring-2 focus:ring-emerald-200 focus:border-emerald-300"
                            rows="3"
                            placeholder="Add key points or ideas for this section..."
                        >${escapeHtml(slide.description || slide.summary || '')}</textarea>
                    `;
                    container.appendChild(slideDiv);
                });
            }
            
            function generateFromReviewTitles() {
                const slideTitlesOnly = reviewTitles.map(slide => ({
                    title: slide.title || 'Untitled',
                    description: slide.description || slide.summary || '',
                    summary: slide.summary || slide.description || '',
                    notes: slide.notes || ''
                }));
                
                closeSlideTitlesReviewModal();
                
                replaceSlidesWithAIGeneration(
                    {
                        title: reviewModalConfig.title,
                        description: reviewModalConfig.description,
                        slideCount: reviewModalConfig.slideCount,
                    },
                    { 
                        silent: false, 
                        slideBlueprint: slideTitlesOnly,
                        design: {
                            background: reviewModalConfig.background,
                            customColor: reviewModalConfig.customColor,
                        }
                    }
                ).then(() => {
                        window.setTimeout(() => {
                            const toast = document.querySelector('[data-share-toast]');
                            if (toast) {
                            toast.textContent = ` Generated ${slideTitlesOnly.length} AI-powered slides. Please verify all facts and data for accuracy.`;
                                toast.classList.remove('hidden');
                                window.setTimeout(() => toast.classList.add('hidden'), 6000);
                            }
                        }, 300);
                });
            }
            
            // Event listeners for review modal
            if (slideTitlesReviewModal) {
                // Close buttons
                const closeBtns = slideTitlesReviewModal.querySelectorAll('[data-slide-titles-review-close]');
                closeBtns.forEach(btn => {
                    btn.addEventListener('click', closeSlideTitlesReviewModal);
                });
                
                // Generate design button
                const generateBtn = slideTitlesReviewModal.querySelector('[data-generate-design-btn]');
                if (generateBtn) {
                    generateBtn.addEventListener('click', () => {
                        // Update titles from inputs
                        const titleInputs = slideTitlesReviewModal.querySelectorAll('[data-title-input]');
                        const contentInputs = slideTitlesReviewModal.querySelectorAll('[data-content-input]');
                        
                        titleInputs.forEach((input, index) => {
                            if (reviewTitles[index]) {
                                reviewTitles[index].title = input.value.trim() || reviewTitles[index].title;
                            }
                        });
                        
                        contentInputs.forEach((input, index) => {
                            if (reviewTitles[index]) {
                                reviewTitles[index].description = input.value.trim();
                                reviewTitles[index].summary = input.value.trim();
                            }
                        });
                        
                        generateFromReviewTitles();
                    });
                }
                
                // Add section button
                const addSectionBtn = slideTitlesReviewModal.querySelector('[data-add-section-btn]');
                if (addSectionBtn) {
                    addSectionBtn.addEventListener('click', () => {
                        reviewTitles.push({
                            title: 'New Section',
                            description: '',
                            summary: '',
                            notes: ''
                        });
                        renderReviewTitles();
                    });
                }
                
                // Delete title
                slideTitlesReviewModal.addEventListener('click', (e) => {
                    const deleteBtn = e.target.closest('[data-delete-title]');
                    if (deleteBtn) {
                        const index = parseInt(deleteBtn.getAttribute('data-delete-title'));
                        if (index >= 0 && index < reviewTitles.length) {
                            reviewTitles.splice(index, 1);
                            renderReviewTitles();
                        }
                    }
                });
                
                // Move title (simple up/down)
                slideTitlesReviewModal.addEventListener('click', (e) => {
                    const moveBtn = e.target.closest('[data-move-title]');
                    if (moveBtn) {
                        const index = parseInt(moveBtn.getAttribute('data-move-title'));
                        if (index > 0) {
                            // Move up
                            [reviewTitles[index], reviewTitles[index - 1]] = [reviewTitles[index - 1], reviewTitles[index]];
                            renderReviewTitles();
                        }
                    }
                });
            }
            
            // Slide Titles Modal Functions
            // Slide Titles Modal Functions (only one definition)
            function openSlideTitlesModal(config) {
                slideTitlesConfig = config;
                // Handle both array of strings and array of objects
                const rawSlides = config.aiSlides || [];
                selectedSlideTitles = rawSlides.map(slide => {
                    if (typeof slide === 'string') {
                        return { title: slide, description: '', summary: '', notes: '' };
                    }
                    return {
                        title: slide.title || slide.heading || '',
                        description: slide.description || '',
                        summary: slide.summary || '',
                        notes: slide.notes || ''
                    };
                }).filter(slide => slide.title && slide.title.trim().length > 0);
                allAvailableTitles = [...selectedSlideTitles];
                
                if (!slideTitlesModal) {
                    console.error('Slide titles modal not found');
                    return;
                }
                
                console.log('Opening slide titles modal with', selectedSlideTitles.length, 'titles');
                console.log('Titles:', selectedSlideTitles.map(s => s.title));
                
                renderSlideTitles();
                slideTitlesModal.classList.remove('hidden');
                slideTitlesModal.classList.add('flex');
            }
            
            function closeSlideTitlesModal() {
                if (!slideTitlesModal) return;
                slideTitlesModal.classList.add('hidden');
                slideTitlesModal.classList.remove('flex');
            }
            
            function renderSlideTitles() {
                const container = document.getElementById('slide-titles-list');
                if (!container) {
                    console.error('slide-titles-list container not found');
                    return;
                }
                
                container.innerHTML = '';
                
                if (selectedSlideTitles.length === 0) {
                    container.innerHTML = '<p class="text-sm text-slate-500 text-center py-8">   .    .</p>';
                    return;
                }
                
                selectedSlideTitles.forEach((slide, index) => {
                    const slideTitle = slide.title || slide.heading || `Slide ${index + 1}`;
                    const slideDiv = document.createElement('div');
                    slideDiv.className = 'flex items-center gap-3 p-4 rounded-2xl border border-slate-200 bg-white/90 hover:border-emerald-300 transition';
                    slideDiv.innerHTML = `
                        <span class="flex-shrink-0 w-8 h-8 rounded-full bg-emerald-100 text-emerald-600 flex items-center justify-center text-sm font-bold">${index + 1}</span>
                        <span class="flex-1 text-sm font-medium text-slate-700">${escapeHtml(slideTitle)}</span>
                        <button
                            type="button"
                            onclick="removeSlideTitle(${index})"
                            class="flex-shrink-0 w-8 h-8 rounded-full border border-red-200 bg-red-50 text-red-600 flex items-center justify-center text-sm font-bold transition hover:bg-red-100 hover:border-red-300"
                            title=""
                        >
                            
                        </button>
                    `;
                    container.appendChild(slideDiv);
                });
            }
            
            function removeSlideTitle(index) {
                if (index < 0 || index >= selectedSlideTitles.length) return;
                
                // Remove the title
                const removedTitle = selectedSlideTitles[index];
                selectedSlideTitles.splice(index, 1);
                
                // Generate alternative titles
                generateAlternativeTitles(index);
                
                renderSlideTitles();
            }
            
            // Make removeSlideTitle available globally
            if (typeof window !== 'undefined') {
                window.removeSlideTitle = removeSlideTitle;
            }
            
            async function generateAlternativeTitles(removedIndex) {
                const openAIKey = app.getOpenAIKey();
                if (!openAIKey) return;
                
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openAIKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are a presentation expert. Generate 3 alternative slide titles in Arabic and English related to "${slideTitlesConfig.title}". Return ONLY a JSON array of strings, no other text.`
                                },
                                {
                                    role: 'user',
                                    content: `Generate 3 alternative slide titles for a presentation about "${slideTitlesConfig.title}". Return as JSON array: ["Title 1", "Title 2", "Title 3"]`
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 200
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const content = data.choices[0]?.message?.content || '';
                        const alternatives = JSON.parse(content.replace(/```json\n?|\n?```/g, ''));
                        
                        if (Array.isArray(alternatives) && alternatives.length > 0) {
                            // Show alternatives in a dropdown or add them to available titles
                            showAlternativeTitles(alternatives);
                        }
                    }
                } catch (error) {
                    console.error('Error generating alternatives:', error);
                }
            }
            
            function showAlternativeTitles(alternatives) {
                const container = document.getElementById('slide-titles-list');
                if (!container) return;
                
                const alternativesDiv = document.createElement('div');
                alternativesDiv.className = 'mt-4 p-4 rounded-2xl border-2 border-dashed border-emerald-200 bg-emerald-50';
                alternativesDiv.innerHTML = `
                    <p class="text-xs font-semibold text-emerald-700 mb-2">  :</p>
                    <div class="space-y-2">
                        ${alternatives.map((alt, idx) => `
                            <button
                                type="button"
                                onclick="addAlternativeTitle('${escapeHtml(alt)}')"
                                class="w-full text-left p-3 rounded-xl border border-emerald-200 bg-white hover:border-emerald-300 hover:bg-emerald-50 transition text-sm text-slate-700"
                            >
                                ${escapeHtml(alt)}
                            </button>
                        `).join('')}
                    </div>
                `;
                container.appendChild(alternativesDiv);
            }
            
            function addAlternativeTitle(title) {
                selectedSlideTitles.push({
                    title: title,
                    description: '',
                    summary: '',
                    notes: ''
                });
                renderSlideTitles();
            }
            
            // Make addAlternativeTitle available globally
            if (typeof window !== 'undefined') {
                window.addAlternativeTitle = addAlternativeTitle;
            }
            
            // Event listeners for slide titles modal - setup once
            if (slideTitlesModal) {
                const slideTitlesCloseBtns = slideTitlesModal.querySelectorAll('[data-slide-titles-close]');
                const slideTitlesGenBtn = slideTitlesModal.querySelector('[data-slide-titles-generate]');
                const slideTitlesAddBtns = slideTitlesModal.querySelectorAll('[data-add-option]');
                
                if (slideTitlesCloseBtns) {
                    slideTitlesCloseBtns.forEach(btn => {
                        btn.addEventListener('click', closeSlideTitlesModal);
                    });
                }
                
                if (slideTitlesGenBtn) {
                    slideTitlesGenBtn.addEventListener('click', async () => {
                        if (selectedSlideTitles.length === 0) {
                            alert('     ');
                            return;
                        }
                        
                        closeSlideTitlesModal();
                        
                        // Generate slides with selected titles
                        await replaceSlidesWithAIGeneration(
                            {
                                title: slideTitlesConfig.title,
                                description: slideTitlesConfig.description,
                                slideCount: selectedSlideTitles.length,
                            },
                            { 
                                silent: false, 
                                slideBlueprint: selectedSlideTitles,
                                design: {
                                    background: slideTitlesConfig.background,
                                    customColor: slideTitlesConfig.customColor,
                                }
                            }
                        );
                    });
                }
                
                if (slideTitlesAddBtns) {
                    slideTitlesAddBtns.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const option = btn.getAttribute('data-add-option');
                            let newTitle = '';
                            
                            switch(option) {
                                case 'flowchart':
                                    newTitle = `${slideTitlesConfig.title}: Flow Chart`;
                                    break;
                                case 'introduction':
                                    newTitle = `: ${slideTitlesConfig.title}`;
                                    break;
                                case 'conclusion':
                                    newTitle = `: ${slideTitlesConfig.title}`;
                                    break;
                                case 'summary':
                                    newTitle = `: ${slideTitlesConfig.title}`;
                                    break;
                                case 'qna':
                                    newTitle = ` : ${slideTitlesConfig.title}`;
                                    break;
                            }
                            
                            if (newTitle) {
                                addAlternativeTitle(newTitle);
                            }
                        });
                    });
                }
            }

            // Initial preview update
            setTimeout(updateBackgroundPreview, 100);

            // Open AI Setup Modal on page load (if not already set up)
            setTimeout(() => {
                const hasSetup = localStorage.getItem('ai-deck-setup');
                if (!hasSetup) {
                    openDeckSetupModal();
                }
            }, 500);

            // Close modals with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (chatbotModal && !chatbotModal.classList.contains('hidden')) {
                        chatbotModal.classList.add('hidden');
                        chatbotModal.classList.remove('flex');
                        const chatbotToggle = document.getElementById('chatbot-toggle');
                        if (chatbotToggle) {
                            chatbotToggle.classList.remove('active');
                        }
                    }
                    if (deckSetupModal && !deckSetupModal.classList.contains('hidden')) {
                        closeDeckSetupModal();
                    }
                }
            });
        };
    </script>
<script>
(function () {
  let tipEl = null;
  let arrowEl = null;
  let activeTarget = null;

  function showTooltip(target) {
    const text = target.getAttribute('data-tooltip');
    if (!text) return;

    if (!tipEl) {
      tipEl = document.createElement('div');
      tipEl.className = 'js-tooltip';
      document.body.appendChild(tipEl);

      arrowEl = document.createElement('div');
      arrowEl.className = 'js-tooltip-arrow';
      document.body.appendChild(arrowEl);
    }

    tipEl.textContent = text;
    tipEl.style.display = 'block';
    arrowEl.style.display = 'block';

    positionTooltip(target);
    activeTarget = target;
  }

  function hideTooltip() {
    if (tipEl) tipEl.style.display = 'none';
    if (arrowEl) arrowEl.style.display = 'none';
    activeTarget = null;
  }

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  function positionTooltip(target) {
    const rect = target.getBoundingClientRect();
    // Initial center above the target
    const centerX = rect.left + rect.width / 2;
    const topY = rect.top;

    // Measure tooltip size by temporarily showing it
    tipEl.style.visibility = 'hidden';
    tipEl.style.display = 'block';
    const tipWidth = tipEl.offsetWidth;
    const tipHeight = tipEl.offsetHeight;
    tipEl.style.visibility = '';
    // Compute final positions with viewport clamping
    const padding = 8;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const left = clamp(centerX, padding + tipWidth / 2, vw - padding - tipWidth / 2);
    let top = topY - padding - tipHeight;

    // If not enough space above, place below
    if (top < padding) {
      top = rect.bottom + padding + tipHeight; // place arrow below as well
      tipEl.style.transform = 'translate(-50%, -100%)'; // adjust transform to anchor below
      arrowEl.style.borderTopColor = 'transparent';
      arrowEl.style.borderBottomColor = '#1f2937';
      arrowEl.style.top = (rect.bottom + padding) + 'px';
    } else {
      tipEl.style.transform = 'translate(-50%, -6px)';
      arrowEl.style.borderBottomColor = 'transparent';
      arrowEl.style.borderTopColor = '#1f2937';
      arrowEl.style.top = (topY - padding) + 'px';
    }

    tipEl.style.left = left + 'px';
    tipEl.style.top = top + 'px';

    arrowEl.style.left = clamp(centerX, padding + 6, vw - padding - 6) + 'px';
  }

  // Delegate listeners
  document.addEventListener('mouseover', function (e) {
    const target = e.target.closest('[data-tooltip]');
    if (!target) return;
    showTooltip(target);
  });
  document.addEventListener('mouseout', function (e) {
    const related = e.relatedTarget;
    if (activeTarget && (!related || !related.closest('[data-tooltip]'))) {
      hideTooltip();
    }
  });
  document.addEventListener('mousemove', function () {
    if (activeTarget) positionTooltip(activeTarget);
  });
  window.addEventListener('scroll', function () {
    if (activeTarget) positionTooltip(activeTarget);
  }, true);
  window.addEventListener('resize', function () {
    if (activeTarget) positionTooltip(activeTarget);
  });
})();
</script>

    <!-- Chatbot Modal -->
    <div id="chatbot-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black/40 backdrop-blur-sm">
      <div class="relative w-full max-w-2xl mx-4 bg-white rounded-3xl shadow-2xl border border-white/60 backdrop-blur-xl overflow-hidden flex flex-col max-h-[85vh]">
        <!-- Header -->
        <div class="flex items-center justify-between px-6 py-4 border-b border-slate-200/80 bg-gradient-to-r from-emerald-50 to-sky-50">
          <div class="flex items-center gap-3">
            <div class="h-10 w-10 rounded-full bg-gradient-to-br from-emerald-500 to-sky-500 flex items-center justify-center">
              <svg class="h-6 w-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
              </svg>
            </div>
            <div>
              <h3 class="text-sm font-semibold text-slate-700">AI Assistant</h3>
              <p class="text-xs text-slate-500">Get suggestions and help with your presentation</p>
            </div>
          </div>
          <button id="chatbot-close" class="rounded-full p-2 text-slate-400 hover:bg-white/80 hover:text-slate-600 transition">
            <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        <!-- Chat Messages -->
        <div id="chatbot-messages" class="flex-1 overflow-y-auto px-6 py-4 space-y-4 bg-white">
          <div class="flex items-start gap-3">
            <div class="h-8 w-8 rounded-full bg-gradient-to-br from-emerald-500 to-sky-500 flex items-center justify-center flex-shrink-0">
              <svg class="h-4 w-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
              </svg>
            </div>
            <div class="flex-1 rounded-2xl bg-slate-50 px-4 py-3">
              <p class="text-sm text-slate-700">Hello! I'm your AI assistant. Please choose your preferred language:</p>
              <div class="mt-3 flex gap-2">
                <button class="lang-btn rounded-full border border-emerald-300 bg-emerald-50 px-4 py-2 text-xs font-semibold text-emerald-600 hover:bg-emerald-100 transition" data-lang="ar"></button>
                <button class="lang-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-xs font-semibold text-slate-600 hover:border-emerald-300 hover:bg-emerald-50 hover:text-emerald-600 transition" data-lang="en">English</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Quick Suggestions -->
        <div id="chatbot-suggestions" class="px-6 py-3 border-t border-slate-200/80 bg-slate-50/50">
          <!-- Suggestions will be populated after language selection -->
        </div>

        <!-- Input Area -->
        <div class="px-6 py-4 border-t border-slate-200/80 bg-white">
          <div class="flex items-center gap-3">
            <input 
              type="text" 
              id="chatbot-input" 
              placeholder="Select language first..." 
              class="flex-1 rounded-xl border border-slate-200 bg-white px-4 py-2.5 text-sm text-slate-700 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:border-emerald-400"
            />
            <button id="chatbot-send" class="rounded-xl bg-emerald-500 px-5 py-2.5 text-sm font-semibold text-white shadow-md shadow-emerald-500/30 hover:bg-emerald-400 transition flex items-center gap-2">
              <span>Send</span>
              <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- AI Setup Modal -->
    <div
      data-deck-setup-modal
      class="fixed inset-0 z-50 hidden items-center justify-center bg-slate-900/55 px-4 py-6 backdrop-blur-md overflow-y-auto"
    >
      <div class="relative w-full max-w-xl rounded-3xl border border-white/60 bg-white/95 p-6 shadow-2xl shadow-emerald-500/20 my-8 max-h-[90vh] overflow-y-auto">
        <!-- Progress Steps Indicator -->
        <div class="mb-6">
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center gap-2 step-indicator" data-step="1">
              <div class="flex items-center justify-center w-8 h-8 rounded-full bg-emerald-500 text-white text-sm font-bold shadow-lg transition-all duration-300 step-number">1</div>
              <span class="text-sm font-semibold text-slate-700 step-label">Enter Title</span>
            </div>
            <div class="flex-1 h-0.5 bg-slate-200 mx-2 step-connector"></div>
            <div class="flex items-center gap-2 step-indicator opacity-40" data-step="2">
              <div class="flex items-center justify-center w-8 h-8 rounded-full bg-slate-300 text-slate-600 text-sm font-bold transition-all duration-300 step-number">2</div>
              <span class="text-sm font-semibold text-slate-500 step-label">Review Sections</span>
            </div>
            <div class="flex-1 h-0.5 bg-slate-200 mx-2 step-connector"></div>
            <div class="flex items-center gap-2 step-indicator opacity-40" data-step="3">
              <div class="flex items-center justify-center w-8 h-8 rounded-full bg-slate-300 text-slate-600 text-sm font-bold transition-all duration-300 step-number">3</div>
              <span class="text-sm font-semibold text-slate-500 step-label">Customize</span>
            </div>
          </div>
        </div>
        
        <div class="flex items-start justify-between gap-4">
          <div>
            <p class="text-xs font-semibold uppercase tracking-[0.3em] text-emerald-500 animate-pulse"> AI deck assistant</p>
            <h2 class="mt-1 text-xl font-semibold text-slate-800">Let's create your presentation! </h2>
            <p class="mt-2 text-sm text-slate-500">We'll draft a starter deck with AI-generated slides. Please verify all facts, numbers, and data before presenting.</p>
          </div>
          <button
            type="button"
            data-deck-setup-close
            class="inline-flex h-8 w-8 items-center justify-center rounded-full border border-slate-200 bg-white text-sm text-slate-400 transition hover:border-emerald-300 hover:text-emerald-600"
            title="Skip setup"
          >
            
          </button>
        </div>
        <form data-deck-setup-form class="mt-6 space-y-4">
          <div class="step-content" data-step-content="1">
            <label for="deck-setup-title" class="text-xs font-semibold uppercase tracking-[0.28em] text-slate-400 flex items-center gap-2">
              <span class="inline-flex items-center justify-center w-5 h-5 rounded-full bg-emerald-100 text-emerald-600 text-xs font-bold">1</span>
              Presentation title
            </label>
            <div class="mt-2 relative">
              <input
                id="deck-setup-title"
                name="title"
                type="text"
                placeholder="e.g. Operational Intelligence Update"
                class="w-full rounded-2xl border-2 border-slate-200 bg-white/90 px-4 py-3 text-sm text-slate-700 shadow-sm transition-all duration-300 focus:border-emerald-400 focus:ring-4 focus:ring-emerald-200 focus:scale-[1.02] transform"
                required
              />
              <div class="absolute right-3 top-1/2 -translate-y-1/2 text-emerald-500 opacity-0 transition-opacity duration-300 title-check-icon">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
              </div>
            </div>
            <p class="mt-2 text-xs text-slate-400 flex items-center gap-1">
              <span class="inline-block w-1.5 h-1.5 rounded-full bg-emerald-400 animate-pulse"></span>
              Type at least 3 characters to generate sub-titles automatically
            </p>
          </div>
          <!-- Sub-titles section - appears directly after title input -->
          <div id="deck-setup-slide-titles-section" class="mt-6 hidden step-content" data-step-content="2">
            <label class="text-xs font-semibold uppercase tracking-[0.28em] text-slate-400 mb-2 block flex items-center gap-2">
              <span class="inline-flex items-center justify-center w-5 h-5 rounded-full bg-emerald-100 text-emerald-600 text-xs font-bold">2</span>
              Review & Customize Sections
            </label>
            <div class="mb-3 p-3 rounded-xl bg-emerald-50 border border-emerald-200 animate-fadeIn">
              <p class="text-xs text-emerald-700 font-medium flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                AI has generated sections for your presentation. You can edit, reorder, or add more!
              </p>
            </div>
            <div id="deck-setup-slide-titles-list" class="space-y-3 mt-3">
              <!-- Slide titles will be rendered here -->
          </div>
            <div class="mt-3 mb-3">
              <button
                type="button"
                id="add-section-btn"
                class="w-full flex items-center justify-center gap-2 rounded-2xl border-2 border-dashed border-slate-300 bg-slate-50 px-4 py-3 text-sm font-semibold text-slate-600 transition hover:border-emerald-400 hover:bg-emerald-50 hover:text-emerald-700"
              >
                <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                </svg>
                Add section
              </button>
            </div>
            <div class="mt-3 flex flex-wrap gap-2">
              <button
                type="button"
                data-add-flowchart
                class="inline-flex items-center rounded-full border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs font-semibold text-emerald-700 transition hover:bg-emerald-100 hover:border-emerald-300"
              >
                + Flow Chart
              </button>
              <button
                type="button"
                data-add-introduction
                class="inline-flex items-center rounded-full border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs font-semibold text-emerald-700 transition hover:bg-emerald-100 hover:border-emerald-300"
              >
                + Introduction
              </button>
              <button
                type="button"
                data-add-conclusion
                class="inline-flex items-center rounded-full border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs font-semibold text-emerald-700 transition hover:bg-emerald-100 hover:border-emerald-300"
              >
                + Conclusion
              </button>
              <button
                type="button"
                data-add-summary
                class="inline-flex items-center rounded-full border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs font-semibold text-emerald-700 transition hover:bg-emerald-100 hover:border-emerald-300"
              >
                + Summary
              </button>
              <button
                type="button"
                data-add-qa
                class="inline-flex items-center rounded-full border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs font-semibold text-emerald-700 transition hover:bg-emerald-100 hover:border-emerald-300"
              >
                + Q&A
              </button>
            </div>
          </div>
          <div>
            <label class="text-xs font-semibold uppercase tracking-[0.28em] text-slate-400 mb-2 block">Background style</label>
            <div class="grid grid-cols-3 gap-2 mt-2">
              <button
                type="button"
                data-bg-option="gradient-light"
                class="bg-option h-16 rounded-xl border-2 border-slate-200 overflow-hidden relative cursor-pointer transition hover:scale-105"
                title="Light Gradient"
              >
                <div class="absolute inset-0 bg-gradient-to-br from-blue-50 via-indigo-50 to-emerald-50"></div>
              </button>
              <button
                type="button"
                data-bg-option="solid-dark"
                class="bg-option h-16 rounded-xl border-2 border-slate-200 overflow-hidden relative cursor-pointer transition hover:scale-105"
                title="Solid Dark"
              >
                <div class="absolute inset-0 bg-slate-900"></div>
              </button>
              <button
                type="button"
                data-bg-option="custom"
                class="bg-option h-16 rounded-xl border-2 border-slate-200 overflow-hidden relative cursor-pointer transition hover:scale-105 flex items-center justify-center"
                title="Custom Color"
              >
                <div class="absolute inset-0" id="custom-bg-preview" style="background-color: #0f172a;"></div>
                <span class="relative text-xs text-slate-400 font-semibold">Custom</span>
              </button>
            </div>
            <input
              id="deck-setup-background"
              name="background"
              type="hidden"
              value="gradient-light"
            />
          </div>
          <div id="deck-setup-custom-color-container" class="hidden">
            <label for="deck-setup-custom-color" class="text-xs font-semibold uppercase tracking-[0.28em] text-slate-400">Custom background color</label>
            <input
              id="deck-setup-custom-color"
              name="customColor"
              type="color"
              value="#0f172a"
              class="mt-2 w-full h-12 rounded-2xl border border-slate-200 cursor-pointer"
            />
          </div>
          <div>
            <label class="text-xs font-semibold uppercase tracking-[0.28em] text-slate-400 mb-2 block">Preview</label>
            <div id="deck-setup-background-preview" class="mt-2 h-32 w-full rounded-2xl border border-slate-200 overflow-hidden relative">
              <!-- Preview will be updated dynamically -->
            </div>
          </div>
          <p
            data-deck-setup-error
            class="hidden rounded-2xl border border-amber-200 bg-amber-50 px-3 py-2 text-sm text-amber-700"
          ></p>
          <div class="flex items-center justify-end gap-2 pt-2">
            <button
              type="button"
              data-deck-setup-close
              class="inline-flex items-center rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-500 transition hover:border-emerald-300 hover:text-emerald-600"
            >
              Skip for now
            </button>
            <button
              type="submit"
              class="inline-flex items-center rounded-full bg-emerald-600 px-5 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-emerald-500"
            >
              Generate deck
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Interactive Slide Titles Review Modal -->
    <div
      data-slide-titles-review-modal
      class="fixed inset-0 z-50 hidden items-center justify-center bg-slate-900/55 px-4 py-6 backdrop-blur-md overflow-y-auto"
    >
      <div class="relative w-full max-w-2xl rounded-3xl border border-white/60 bg-white/95 p-6 shadow-2xl shadow-emerald-500/20 my-8 max-h-[90vh] overflow-y-auto">
        <div class="flex items-start justify-between gap-4 mb-6">
          <div>
            <p class="text-xs font-semibold uppercase tracking-[0.3em] text-emerald-500">Review slide titles</p>
            <h2 class="mt-1 text-xl font-semibold text-slate-800">Review and customize your slide titles</h2>
            <p class="mt-2 text-sm text-slate-500">Review each title and customize as needed. You can edit, remove, or add new sections.</p>
          </div>
          <button
            type="button"
            data-slide-titles-review-close
            class="inline-flex h-8 w-8 items-center justify-center rounded-full border border-slate-200 bg-white text-sm text-slate-400 transition hover:border-emerald-300 hover:text-emerald-600"
            title="Close"
          >
            
          </button>
        </div>
        
        <div class="mb-4">
          <button
            type="button"
            data-add-section-btn
            class="w-full flex items-center justify-center gap-2 rounded-2xl border-2 border-dashed border-slate-300 bg-slate-50 px-4 py-3 text-sm font-semibold text-slate-600 transition hover:border-emerald-400 hover:bg-emerald-50 hover:text-emerald-700"
          >
            <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
            </svg>
            Add section
          </button>
        </div>
        
        <div id="slide-titles-review-list" class="space-y-3 mb-6">
          <!-- Slide titles will be rendered here -->
        </div>
        
        <div class="flex items-center justify-end gap-2 pt-4 border-t border-slate-200">
          <button
            type="button"
            data-slide-titles-review-close
            class="inline-flex items-center rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-500 transition hover:border-emerald-300 hover:text-emerald-600"
          >
            Cancel
          </button>
          <button
            type="button"
            data-generate-design-btn
            class="inline-flex items-center gap-2 rounded-full bg-purple-600 px-6 py-2.5 text-sm font-semibold text-white shadow-sm transition hover:bg-purple-700"
          >
            <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
            </svg>
            Generate design
          </button>
        </div>
      </div>
    </div>

    <div
      data-share-toast
      class="pointer-events-none fixed bottom-6 right-6 z-50 hidden rounded-2xl border border-emerald-200/70 bg-white/95 px-4 py-3 text-sm font-medium text-emerald-700 shadow-lg shadow-emerald-500/20"
      role="status"
      aria-live="polite"
    ></div>
</body>
</html>


